{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Arista's EOS SDK RPC","text":"<p>This is the official documentation for the gRPC API over Arista's EOS SDK.</p> <p>Sections of interest:</p> <ul> <li>API reference</li> <li>Guides</li> <li>FAQ</li> </ul> <p>EosSdkRpc is an agent built on top of the EosSdk that uses gRPC as a mechanism to provide remote access to the SDK.</p> <p>This agent is present in EOS, and starting in the 4.29 release is currently enabled via the <code>management api eos-sdk-rpc</code> CLI. The gRPC interface that the agent supports closely matches the interface provided by EosSdk, and the intent is that the <code>.proto</code> interface will be publicly supported. As well as potentially allowing for remote access, using protobuf to specify the interface isolates customer code from the Linux ABI issues that come with building C++ applications on different compiler, libc and kernel versions.</p> <p>The default listen port is <code>9543</code> but this can be changed to allow external access. Encrypted access is supported for EosSdkRpc agents configured via the <code>management api eos-sdk-rpc</code> CLI. An ACL should be used to limit the hosts that have access to the agent.</p> <p>The API mirroring is intended to be modular in the same fashion as the SDK itself. Each proto file mirrors one specific SDK module and the RPC definitions and messages also aim to be as close as possible to the original SDK API call, in an attempt to make the learning gap as small as possible.</p> <p>For performance reasons, \u201csetter\u201d RPC calls also come with bulk versions, which minimizes the RPC overhead. These calls differ from their original counterparts by providing a sequence of individual operations which are performed in batches, without requiring a round-trip to the client for each operation.</p> <p>Multiple clients are supported by EosSdkRpc and most state is shared between these clients. Requests are fulfilled without regard to which client invoked the RPC call.</p>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#general-grpc-questions","title":"General gRPC questions","text":""},{"location":"faq/#can-i-use-grpc-with-languages-other-than-c-and-python","title":"Can I use gRPC with languages other than C++ and Python?","text":"<p>Yes! gRPC supports many programming languages, including C++, Python, Go and C#. The gRPC tools can generate client and server code for these languages.</p> <p>See: https://grpc.io/docs/languages/</p>"},{"location":"faq/#how-do-i-create-a-grpc-client","title":"How do I create a gRPC client?","text":"<p>To create a gRPC client, you typically need to generate client code using the gRPC tools from your service definition file (.proto). Then, you can use the generated client classes to make RPC calls to the server.</p>"},{"location":"faq/#where-are-the-protobufs-located","title":"Where are the protobufs located?","text":"<p>The proto files for each service in EosSdkRpc are located either on this github repository, or in the /usr/share/EosSdkRpc/proto directory on an Arista EOS device.</p>"},{"location":"faq/#how-to-generate-source-files-for-a-given-language-from-the-proto-files","title":"How to generate source files for a given language from the proto files?","text":"<p>C++: see the simple c++ client</p> <p>Python: If you haven't already, you need to install the Protocol Buffers compiler (protoc). You can download precompiled binaries from the official repository: https://github.com/protocolbuffers/protobuf/releases</p> <p>You'll also need the grpcio-tools package to generate gRPC code for Python. You can install it using pip: <pre><code>pip install grpcio-tools\n</code></pre></p> <p>Use the protoc compiler and the python_out option to generate Python code from your .proto file: <pre><code>protoc -I /path/to/protobufs --python_out=/path/to/output_dir /path/to/protobufs/example.proto\n</code></pre> Replace /path/to/protobufs with the actual path to the directory containing your .proto file, and replace /path/to/output_dir with the directory where you want the Python code to be generated.</p>"},{"location":"faq/#how-many-clients-are-able-to-connect-to-a-single-transport","title":"How many clients are able to connect to a single transport?","text":"<p>There is no maximum number of clients for a gRPC server; it's a dynamic and context-dependent parameter that should be determined on a case by case basis due to hardware and performance constraints.</p> <p>However, as with most gRPC servers EosSdkRpc allows a max of 100 concurrent streams by default. A gRPC channel uses one HTTP/2 connection, and all concurrent calls are multiplexed on that single connection. If the amount of active calls hits the connection stream limit, any additional calls made will be added to a queue in the client. These calls in the queue must wait for other active calls to complete before they are sent.</p> <p>See: https://grpc.io/docs/guides/performance/</p>"},{"location":"faq/#what-is-the-maximum-message-size","title":"What is the maximum message size?","text":"<p>The max message size in gRPC is limited to 4MB by default. This can be increased by setting the following client channel options: - grpc.max_send_message_length - Grpc.max_receive_message_length</p> <p>This should only be required in very specific cases. For example, making a show command request with the EapiService that returns a large amount of content.</p>"},{"location":"faq/#how-can-i-handle-timeouts-and-deadlines-in-grpc-clients","title":"How can I handle timeouts and deadlines in gRPC clients?","text":"<p>You can set timeouts and deadlines when making RPC calls using gRPC. This helps ensure that calls do not hang indefinitely and fail gracefully when expected responses are not received within the specified time.</p> <p>Python Example:</p> <p>Python example</p> <p>Use the optional timeout parameter, which sets duration of time in seconds to allow for the RPC. <pre><code>my_timeout_in_seconds = 10\nself.grpc_client.fooRpc( fooRpcRequestMessage, timeout=my_timeout_in_seconds)\n</code></pre></p>"},{"location":"faq/#how-do-i-handle-errors-in-grpc-clients","title":"How do I handle errors in gRPC clients?","text":"<p>gRPC uses status codes to indicate the outcome of an RPC call. The returned grpc::Status object should be checked to determine the status of the call and handle errors accordingly.</p> <p>Info</p> <p>Sample mapping of EOS SDK errors to gRPC errors can be found in our HOWTO guide</p>"},{"location":"faq/#common-errors","title":"Common Errors:","text":"gRPC Status description GRPC_STATUS_CANCELLED The request was cancelled GRPC_STATUS_DEADLINE_EXCEEDED The request deadline expired before the server returned a response GRPC_STATUS_UNIMPLEMENTED The RPC has not been implemented on the server side. This could be because the service has not been enabled via the EosSdkRpc transport service configuration command: <code>service &lt;list of services to enable&gt; | all</code> GRPC_STATUS_UNAVAILABLE This status code usually indicates the client is unable to form a successful connection to the server. This can be caused by many issues depending on the language used by the client. Common causes are the gRPC server not running, ACL rules blocking the IP/port, certificate issues, attempting to connect to a different server. GRPC_STATUS_UNKNOWN Server may have thrown an exception <p>Info</p> <p>See: official gRPC website for further information.</p>"},{"location":"faq/#other","title":"Other:","text":""},{"location":"faq/#rpc-inactivefailed-to-connect-to-address","title":"RPC inactive/failed to connect to address","text":"<p>Please ensure the Arista device has the correct access control in place to permit traffic on the port used to configure the given EosSdkRpc transport. The default EosSdkRpc port is blocked by default and must be explicitly enabled for remote clients connecting over an interface.</p> <p>See the exposing the RPC port guide.</p>"},{"location":"faq/#no-match-found-for-server-name","title":"No match found for server name:  <p>If an SSL profile is in use and there is a mismatch between the common name (or SAN) of the certificate and the device the following trace will appear in the logs (/var/log/agents/EosSdkRpcAgent- ): <pre><code>E0223 09:47:05.375500672   30883 ssl_transport_security.cc:1839] No match found for server name: &lt;dns name&gt;\n</code></pre> <p>Ensure the server certificate has the dns name or IP address, which is used by the client to connect to the server present in the CN or SAN field.</p>","text":""},{"location":"faq/#peer-did-not-return-a-certificate","title":"Peer did not return a certificate. <p>If the transport is enabled with mTLS config ( <code>trust certificate &lt;certificate&gt;</code> configuration present in the configured SSL profile ) and the client does not provide a valid certificate, a similar trace to the following will appear in the logs:</p> <pre><code>E0223 09:53:34.288937269   32483 ssl_transport_security.cc:1469] Handshake failed with fatal error SSL_ERROR_SSL: error:140890C7:SSL routines:ssl3_get_client_certificate:peer did not return a certificate.\n</code></pre>  <p>Note</p> <p>A client certificate may also be validated against a trusted certificate manually using the following openssl command: <pre><code>$ openssl verify -verbose -CAfile ca.crt client.crt\nclient.crt: OK\n</code></pre></p>","text":""},{"location":"faq/#rsa_padding_check_pkcs1_type_1block-type-is-not-01","title":"RSA_padding_check_PKCS1_type_1:block type is not 01 <p>If the certificate presented to the server by the client is not signed by a trusted CA, a trace similar to the following may appear in the logs:</p> <pre><code>E0223 09:59:07.960911143   32483 ssl_transport_security.cc:1469] Handshake failed with fatal error SSL_ERROR_SSL: error:0407006A:rsa routines:RSA_padding_check_PKCS1_type_1:block type is not 01.\n</code></pre>","text":""},{"location":"faq/#questions-specific-to-eossdkrpc","title":"Questions specific to EosSdkRpc","text":""},{"location":"faq/#how-can-i-secure-grpc-communication","title":"How can I secure gRPC communication?","text":"<p>gRPC supports various security mechanisms, including Transport Layer Security (TLS) for securing communication between clients and servers. You can configure security options when setting up the server and client by first configuring an SSL profile within EOS. Optional, AAA username and password authentication is also supported as an additional layer ontop of TLS.</p> <p>See the security configuration guide for more information.</p>"},{"location":"faq/#troubleshooting-eossdkrpc","title":"Troubleshooting EosSdkRpc","text":""},{"location":"faq/#where-are-eossdkrpc-logs-located","title":"Where are EosSdkRpc logs located?","text":"<p>The logs for EosSdkRpc transports are located in /var/log/agents directory, the naming format for each transport will be <code>EosSdkRpcAgent-&lt;transport name&gt;-&lt;process id&gt;</code></p> <p>e.g <code>EosSdkRpcAgent-foo-12345</code></p>"},{"location":"faq/#how-to-enable-more-verbose-eossdkrpc-grpc-logging","title":"How to enable more verbose EosSdkRpc gRPC logging:","text":"<p>All C core library based gRPC implementations have built in support for both of the <code>GRPC_VERBOSITY</code> and <code>GRPC_TRACE</code> environment variables. These can be used to enable more verbose logging from within gRPC for both the EosSdkRpc transport and the client. </p> <p>Other gRPC environment variables may be found at the official gRPC github</p>"},{"location":"faq/#server-side","title":"Server-side","text":"<p>Set the environment variable for the transport named <code>foo</code> ( agent name: <code>EosSdkRpcAgent-foo</code> ): <pre><code>hostname(config)#\nhostname(config)#agent EosSdkRpcAgent-foo environ GRPC_VERBOSITY=DEBUG\n</code></pre></p> <p>The agent must be restarted for the environment variable to take effect: <pre><code>hostname(config)#\nhostname(config)#man api eos-sdk-rpc\nhostname(config-mgmt-api-eos-sdk-rpc)#transport grpc foo\nhostname(config-eos-sdk-rpc-transport-default)#disabled\nhostname(config-eos-sdk-rpc-transport-default)#no disabled\nThis is an EosSdk application\nFull agent name is 'EosSdkRpcAgent-foo\n</code></pre></p> <p>More verbose logging should now be present in: <code>/var/log/agents/EosSdkRpcAgent-foo-&lt;pid&gt;</code></p>"},{"location":"faq/#client-side","title":"Client-side","text":"<p>Examples:</p> <p>Python:</p> <p>GRPC_VERBOSITY=debug python Client.py</p> <p>Dotnet:</p> <p>GRPC_VERBOSITY=debug dotnet run</p>"},{"location":"faq/#how-to-verify-the-eossdkrpc-process-is-running","title":"How to verify the EosSdkRpc process is running?","text":"<p>bash and pgrep</p> <p>hostname(config)#bash pgrep EosSdkRpc | xargs ps PID TTY      STAT   TIME COMMAND 26963 ?        Sl     0:07 EosSdkRpc-RPC</p> <p>or</p> <p>Info</p> <p>sh daemon Agent: RPC (running with PID 26963) Uptime: 0:00:39 (Start time: Thu Feb 23 09:25:10 2023) No configuration options stored.</p> <p>No status data stored.</p>"},{"location":"faq/#how-to-verify-the-eossdkrpc-transport-is-actively-listening-on-the-configured-addresses","title":"How to verify the EosSdkRpc transport is actively listening on the configured addresses?","text":"<p>using netstat and grep: <pre><code>hostname(config)#bash sudo netstat -ptnl | grep 9543\ntcp6       0      0 :::9543                 :::*                    LISTEN      26963/EosSdkRpc-RPC\n</code></pre> <code>-x</code> for unix socket <code>-t</code> for tcp</p>"},{"location":"faq/#how-to-verify-the-port-is-being-forwarded-in-the-configured-acls","title":"How to verify the port is being forwarded in the configured ACLs?","text":"<p>Use the <code>show run | sec &lt;port&gt;</code> command to easily parse the running config for any custom access-list. <pre><code>hostname(config)#show run | sec 9543\nip access-list rpc\n   300 permit tcp any any eq 9543\n</code></pre></p> <p>Verify the correct access-list is in use: <pre><code>#show run | sec system control-plane\nsystem control-plane\n   ip access-group rpc in\n</code></pre></p>"},{"location":"api-reference/","title":"API reference","text":"<p>This API reference is automatically generated from protofiles comments using the protoc-gen-doc plugin.</p> <p>Anyone is welcome to signal any generation problem by opening an issue on the GitHub repository so we can fix it ASAP.</p> <p>Feel free to read source protofiles from the repository if the documentation is not explicit enough. Additionally, checking out the guides section might be helpful.</p>"},{"location":"api-reference/acl/","title":"acl.proto","text":""},{"location":"api-reference/acl/#aclmgrservice","title":"AclMgrService","text":""},{"location":"api-reference/acl/#watch","title":"watch","text":"<p>rpc watch(AclWatchRequest)     AclWatchResponse</p> <p>Subscription to monitor ACL hardware synchronization events. This request stays active until the client cancels or the server shuts down.</p> <p>EosSdk reference: eos::acl_handler (class)</p>"},{"location":"api-reference/acl/#acls","title":"acls","text":"<p>rpc acls(AclsRequest)     AclsResponse</p> <p>Returns a list of the ACLs created by this application.</p> <p>EosSdk reference: eos::acl_mgr::acl_iter</p>"},{"location":"api-reference/acl/#acls_all","title":"acls_all","text":"<p>rpc acls_all(AclsAllRequest)     AclsAllResponse</p> <p>Returns a list of all the ACLs.</p> <p>EosSdk reference: eos::acl_mgr::acl_all_iter</p>"},{"location":"api-reference/acl/#acl_rule_ips","title":"acl_rule_ips","text":"<p>rpc acl_rule_ips(AclRuleIpsRequest)     AclRuleIpsResponse</p> <p>Returns a list of all the IP ACL rules created by this application for a specified ACL.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_ip_iter</p>"},{"location":"api-reference/acl/#acl_all_rule_ips","title":"acl_all_rule_ips","text":"<p>rpc acl_all_rule_ips(AclAllRuleIpsRequest)     AclAllRuleIpsResponse</p> <p>Returns a list of all the IP ACL rules for a specified ACL.</p> <p>EosSdk reference: eos::acl_mgr::acl_all_rule_ip_iter</p>"},{"location":"api-reference/acl/#acl_rule_eths","title":"acl_rule_eths","text":"<p>rpc acl_rule_eths(AclRuleEthsRequest)     AclRuleEthsResponse</p> <p>Returns a list of all the ethernet ACL rules created by this application for a specified ACL.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_eth_iter</p>"},{"location":"api-reference/acl/#acl_all_rule_eths","title":"acl_all_rule_eths","text":"<p>rpc acl_all_rule_eths(AclAllRuleEthsRequest)     AclAllRuleEthsResponse</p> <p>Returns a list of all the ethernet ACL rules for a specified ACL.</p> <p>EosSdk reference: eos::acl_mgr::acl_all_rule_eth_iter</p>"},{"location":"api-reference/acl/#acl_exists","title":"acl_exists","text":"<p>rpc acl_exists(AclExistsRequest)     AclExistsResponse</p> <p>Queries whether the specified ACL has been configured in this application.</p> <p>EosSdk reference: eos::acl_mgr::acl_exists</p>"},{"location":"api-reference/acl/#acl_all_exists","title":"acl_all_exists","text":"<p>rpc acl_all_exists(AclAllExistsRequest)     AclAllExistsResponse</p> <p>Queries whether the specified ACL has been configured.</p> <p>EosSdk reference: eos::acl_mgr::acl_all_exists</p>"},{"location":"api-reference/acl/#acl_rule_set","title":"acl_rule_set","text":"<p>rpc acl_rule_set(AclRuleSetRequest)     AclRuleSetResponse</p> <p>Adds a rule to an ACL. If the specified ACL does not exist it is created. The type of the rule must be the same as the ACL's type.</p> <p>Note: Must call acl_commit for this change to take effect Note: An extremely large numbers of ACLs or rules per ACL can result in       undefined behavior, including a switch reload.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_set</p>"},{"location":"api-reference/acl/#bulk_acl_rule_set","title":"bulk_acl_rule_set","text":"<p>rpc bulk_acl_rule_set(BulkAclRuleSetRequest)     BulkAclRuleSetResponse</p> <p>Adds multiple rules to ACLs in a single call. Creates any ACLs that do not exist.</p> <p>Note: Must call acl_commit for this change to take effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_set</p>"},{"location":"api-reference/acl/#acl_rule_del","title":"acl_rule_del","text":"<p>rpc acl_rule_del(AclRuleDelRequest)     AclRuleDelResponse</p> <p>Removes a rule from an ACL. If the specified ACL does not exist or there is no rule at the specified sequence number no changes are made.</p> <p>Note: Must call acl_commit for this change to take effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_del</p>"},{"location":"api-reference/acl/#bulk_acl_rule_del","title":"bulk_acl_rule_del","text":"<p>rpc bulk_acl_rule_del(BulkAclRuleDelRequest)     BulkAclRuleDelResponse</p> <p>Removes multiple rules from ACLs in a single call.</p> <p>Note: Must call acl_commit for this change to take effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_rule_del</p>"},{"location":"api-reference/acl/#acl_commit","title":"acl_commit","text":"<p>rpc acl_commit(AclCommitRequest)     AclCommitResponse</p> <p>Commits all rule and setting changes made to all ACLs.</p> <p>Pushes ACLs into Sysdb's active configuration. This commit cannot fail, but it can lead to a state where not all ACLs can be loaded into hardware. You will be notified via an on_acl_sync event when this commit and all other outstanding operations such as interface applications are loaded into hardware, or an on_acl_sync_fail event if the newly committed configuration can't be loaded. If there are no changes pending, you will get one of those events depending on whether the current state in Sysdb can be loaded into hardware or not.</p> <p>EosSdk reference: eos::acl_mgr::acl_commit</p>"},{"location":"api-reference/acl/#acl_del","title":"acl_del","text":"<p>rpc acl_del(AclDelRequest)     AclDelResponse</p> <p>Deletes the specified ACL removing it from all interfaces and removing all of its rules. Any pending changes to the ACL are discarded. It is effective immediately (no commit needed and no watcher event is provided).</p> <p>EosSdk reference: eos::acl_mgr::acl_del</p>"},{"location":"api-reference/acl/#bulk_acl_del","title":"bulk_acl_del","text":"<p>rpc bulk_acl_del(BulkAclDelRequest)     BulkAclDelResponse</p> <p>Deletes multiple ACLs in a single call.</p> <p>EosSdk reference: eos::acl_mgr::acl_del</p>"},{"location":"api-reference/acl/#acl_apply","title":"acl_apply","text":"<p>rpc acl_apply(AclApplyRequest)     AclApplyResponse</p> <p>Requests that an ACL be (un)applied on the given interface and direction.</p> <p>ACL is loaded into hardware asynchronously. Like acl_commit, this call results in a watcher event when we have applied, or failed to apply, this ACL configuration. That is, an event will not be sent per call but instead an event will be sent when everything is loaded into hardware, or when we notice problems.</p> <p>API call ordering note: any acl_rule_set or acl_rule_del calls must be followed by an acl_commit prior to calling this rpc otherwise this call will return an error.</p> <p>EosSdk reference: eos::acl_mgr::acl_apply</p>"},{"location":"api-reference/acl/#bulk_acl_apply","title":"bulk_acl_apply","text":"<p>rpc bulk_acl_apply(BulkAclApplyRequest)     BulkAclApplyResponse</p> <p>Apply or unapply multiple ACLs on the specified interfaces and directions in a single call.</p> <p>EosSdk reference: eos::acl_mgr::acl_apply</p>"},{"location":"api-reference/acl/#acl_counters_enabled_set","title":"acl_counters_enabled_set","text":"<p>rpc acl_counters_enabled_set(AclCountersEnabledSetRequest)     AclCountersEnabledSetResponse</p> <p>Enable or disable counters for the ACL.</p> <p>Note: Must call acl_commit before this setting takes effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_counters_enabled_set</p>"},{"location":"api-reference/acl/#bulk_acl_counters_enabled_set","title":"bulk_acl_counters_enabled_set","text":"<p>rpc bulk_acl_counters_enabled_set(BulkAclCountersEnabledSetRequest)     BulkAclCountersEnabledSetResponse</p> <p>Enable or disable counters for multiple ACLs in a single call.</p> <p>Note: Must call acl_commit before this setting takes effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_counters_enabled_set</p>"},{"location":"api-reference/acl/#acl_fragments_enabled_set","title":"acl_fragments_enabled_set","text":"<p>rpc acl_fragments_enabled_set(AclFragmentsEnabledSetRequest)     AclFragmentsEnabledSetResponse</p> <p>Enable or disable fragments matching on the ACL.</p> <p>Note: Must call acl_commit before this setting takes effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set</p>"},{"location":"api-reference/acl/#bulk_acl_fragments_enabled_set","title":"bulk_acl_fragments_enabled_set","text":"<p>rpc bulk_acl_fragments_enabled_set(BulkAclFragmentsEnabledSetRequest)     BulkAclFragmentsEnabledSetResponse</p> <p>Enables or disables fragments matching on multiple ACLs in a single call.</p> <p>Note: Must call acl_commit before this setting takes effect.</p> <p>EosSdk reference: eos::acl_mgr::acl_fragments_enabled_set</p>"},{"location":"api-reference/acl/#stream_allowed","title":"stream_allowed","text":"<p>rpc stream_allowed(StreamAllowedRequest)     StreamAllowedResponse</p> <p>Check a connection against any applied ACL to determine if it should be dropped, incrementing the ACL counter if so. For use with SOCK_STREAM or SOCK_DGRAM.</p> <p>EosSdk reference: eos::acl_mgr::stream_allowed</p>"},{"location":"api-reference/acl/#dgram_allowed","title":"dgram_allowed","text":"<p>rpc dgram_allowed(DgramAllowedRequest)     DgramAllowedResponse</p> <p>Check a packet against any applied ACL to determine if it should be dropped, incrementing the ACL counter if so. For use with SOCK_DGRAM only.</p> <p>EosSdk reference: eos::acl_mgr::dgram_allowed</p>"},{"location":"api-reference/acl/#messages","title":"Messages","text":""},{"location":"api-reference/acl/#aclallexistsrequest","title":"AclAllExistsRequest","text":"Name Value Description key AclKey The key of the ACL to query."},{"location":"api-reference/acl/#aclallexistsresponse","title":"AclAllExistsResponse","text":"Name Value Description exists bool True if the ACL exists in any configuration in the device otherwise false."},{"location":"api-reference/acl/#aclallruleethsrequest","title":"AclAllRuleEthsRequest","text":"Name Value Description key AclKey The key of ACL to get the ethernet rules for."},{"location":"api-reference/acl/#aclallruleethsresponse","title":"AclAllRuleEthsResponse","text":"Name Value Description eth_rule AclRuleEthEntry"},{"location":"api-reference/acl/#aclallruleipsrequest","title":"AclAllRuleIpsRequest","text":"Name Value Description key AclKey The key of ACL to get the IP rules for."},{"location":"api-reference/acl/#aclallruleipsresponse","title":"AclAllRuleIpsResponse","text":"Name Value Description ip_rule AclRuleIpEntry"},{"location":"api-reference/acl/#aclapplyrequest","title":"AclApplyRequest","text":"Name Value Description key AclKey The key of the ACL to [un]apply. intf_id IntfId The inteface ID of the the interface to [un]apply the ACL. direction AclDirection The direction in which to [un]apply the ACL. apply bool True if the ACL should be applied otherwise false if it should be unapplied."},{"location":"api-reference/acl/#aclapplyresponse","title":"AclApplyResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclcommitrequest","title":"AclCommitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclcommitresponse","title":"AclCommitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclcountersenabledsetrequest","title":"AclCountersEnabledSetRequest","text":"Name Value Description key AclKey The key of the ACL to modify. enabled bool True if counters should be enabled for the ACL otherwise false if they should be disabled."},{"location":"api-reference/acl/#aclcountersenabledsetresponse","title":"AclCountersEnabledSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#acldelrequest","title":"AclDelRequest","text":"Name Value Description key AclKey The key of the ACL to remove."},{"location":"api-reference/acl/#acldelresponse","title":"AclDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclexistsrequest","title":"AclExistsRequest","text":"Name Value Description key AclKey The key of the ACL to query."},{"location":"api-reference/acl/#aclexistsresponse","title":"AclExistsResponse","text":"Name Value Description exists bool True if the ACL exists in the application's configuration otherwise false."},{"location":"api-reference/acl/#aclfragmentsenabledsetrequest","title":"AclFragmentsEnabledSetRequest","text":"Name Value Description key AclKey The key of the ACL to modify. enabled bool True if fragments matching should be enabled for the ACL otherwise false if it should be disabled."},{"location":"api-reference/acl/#aclfragmentsenabledsetresponse","title":"AclFragmentsEnabledSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclruledelrequest","title":"AclRuleDelRequest","text":"Name Value Description key AclKey The key of the ACL to modify. sequence_number uint32 The sequence number at which to remove the rule."},{"location":"api-reference/acl/#aclruledelresponse","title":"AclRuleDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclruleethentry","title":"AclRuleEthEntry","text":"Name Value Description sequence_number uint32 eth_rule AclRuleEth"},{"location":"api-reference/acl/#aclruleethsrequest","title":"AclRuleEthsRequest","text":"Name Value Description key AclKey The key of ACL to get the ethernet rules for."},{"location":"api-reference/acl/#aclruleethsresponse","title":"AclRuleEthsResponse","text":"Name Value Description eth_rule AclRuleEthEntry"},{"location":"api-reference/acl/#aclruleipentry","title":"AclRuleIpEntry","text":"Name Value Description sequence_number uint32 ip_rule AclRuleIp"},{"location":"api-reference/acl/#aclruleipsrequest","title":"AclRuleIpsRequest","text":"Name Value Description key AclKey The key of ACL to get the IP rules for."},{"location":"api-reference/acl/#aclruleipsresponse","title":"AclRuleIpsResponse","text":"Name Value Description ip_rule AclRuleIpEntry"},{"location":"api-reference/acl/#aclrulesetrequest","title":"AclRuleSetRequest","text":"Name Value Description key AclKey The key of the ACL to create or modify. sequence_number uint32 The sequence number to add the rule at. oneof acl_rule.ip_rule AclRuleIp IP ACL rule to add to the ACL. oneof acl_rule.eth_rule AclRuleEth Ethenet ACL rule to add to the ACL."},{"location":"api-reference/acl/#aclrulesetresponse","title":"AclRuleSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclwatchrequest","title":"AclWatchRequest","text":"Name Value Description ack bool Set to true if an immediate acknowledgment is desired."},{"location":"api-reference/acl/#aclwatchresponse","title":"AclWatchResponse","text":"Name Value Description oneof acl_event.ack bool If true the agent is now actively watching for events. oneof acl_event.on_acl_sync OnAclSync All pending transactions have been successfully committed to hardware. oneof acl_event.on_acl_sync_fail OnAclSyncFail A problem has stopped the ACL configuration from being committed to hardware."},{"location":"api-reference/acl/#aclsallrequest","title":"AclsAllRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclsallresponse","title":"AclsAllResponse","text":"<p>An acl that was created by this application.</p> Name Value Description key AclKey"},{"location":"api-reference/acl/#aclsrequest","title":"AclsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/acl/#aclsresponse","title":"AclsResponse","text":"<p>An acl that was created by this application.</p> Name Value Description key AclKey"},{"location":"api-reference/acl/#bulkaclapplyrequest","title":"BulkAclApplyRequest","text":"Name Value Description requests repeated AclApplyRequest List of AclApplyRequests."},{"location":"api-reference/acl/#bulkaclapplyresponse","title":"BulkAclApplyResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#bulkaclcountersenabledsetrequest","title":"BulkAclCountersEnabledSetRequest","text":"Name Value Description requests repeated AclCountersEnabledSetRequest List of AclCountersEnabledSetRequests."},{"location":"api-reference/acl/#bulkaclcountersenabledsetresponse","title":"BulkAclCountersEnabledSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#bulkacldelrequest","title":"BulkAclDelRequest","text":"Name Value Description requests repeated AclDelRequest List of AclDelRequests."},{"location":"api-reference/acl/#bulkacldelresponse","title":"BulkAclDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#bulkaclfragmentsenabledsetrequest","title":"BulkAclFragmentsEnabledSetRequest","text":"Name Value Description requests repeated AclFragmentsEnabledSetRequest List of AclFragmentsEnabledSetRequests."},{"location":"api-reference/acl/#bulkaclfragmentsenabledsetresponse","title":"BulkAclFragmentsEnabledSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#bulkaclruledelrequest","title":"BulkAclRuleDelRequest","text":"Name Value Description requests repeated AclRuleDelRequest List of AclRuleDelRequests."},{"location":"api-reference/acl/#bulkaclruledelresponse","title":"BulkAclRuleDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#bulkaclrulesetrequest","title":"BulkAclRuleSetRequest","text":"Name Value Description requests repeated AclRuleSetRequest List of AclRuleSetRequests."},{"location":"api-reference/acl/#bulkaclrulesetresponse","title":"BulkAclRuleSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/acl/#dgramallowedrequest","title":"DgramAllowedRequest","text":"Name Value Description source_addr bytes The source IP address. dest_addr bytes The destination IP address. source_port uint32 The source port. Must be in range 0 to 65535. dest_port uint32 The desitionation port. Must be in range 0 to 65535. ttl uint32 Time to live if IPv4 otherwise hop limit if IPv6. Must be in range 0 to 255. tos uint32 Type of service if IPv4 othersiwe traffic class if IPv6. Must be in range 0 to 255 recipient_intf IntfId Recipient interface."},{"location":"api-reference/acl/#dgramallowedresponse","title":"DgramAllowedResponse","text":"Name Value Description dgram_allowed bool True if packet is allowed otherwise false if it should be dropped."},{"location":"api-reference/acl/#onaclsync","title":"OnAclSync","text":"<p>Notification for when all pending transactions have been successfully committed  to hardware. May be called multiple times for a single transaction or only once  for a whole bunch of seperate updates. May also be called due to ACL updates  made using the CLI.</p> <p>Empty message.   </p>"},{"location":"api-reference/acl/#onaclsyncfail","title":"OnAclSyncFail","text":"<p>Notification for when a problem has stopped ACL configuration from being  committed to hardware. The config must be modified in some way to get Sysdb and  hardware back in sync. The most common problem is too many ACLs or ACL entries.  It is up to the client to find and fix the issue. After committing the  required modifications an on_acl_sync notification will be sent if the problem is  fixed otherwsie another on_acl_sync_fail notification will be sent to indicate  there is still a problem.</p> <p>Note: Multiple nofitications may be sent for a single problem and notifications        may be sent due to misconfigurations made using the CLI.</p> Name Value Description linecard string The linecard reporting the issue. message string An error message describing the problem."},{"location":"api-reference/acl/#streamallowedrequest","title":"StreamAllowedRequest","text":"Name Value Description source_addr bytes The source IP address. dest_addr bytes The destination IP address. protocol uint32 Optional: The protocol. Must be in range 0 to 255. source_port uint32 Optional: The source port. Must be in range 0 to 65535. dest_port uint32 Optional: The desitionation port. Must be in range 0 to 65535."},{"location":"api-reference/acl/#streamallowedresponse","title":"StreamAllowedResponse","text":"Name Value Description stream_allowed bool True if the connection is allowed otherwise false if it should be dropped."},{"location":"api-reference/acl_types/","title":"acl_types.proto","text":""},{"location":"api-reference/acl_types/#messages","title":"Messages","text":""},{"location":"api-reference/acl_types/#aclkey","title":"AclKey","text":"<p>An ACL key is the combination of its name and ACL type.</p> <p>EosSdk reference: eos::acl_key_t</p> Name Value Description acl_name string acl_type AclType"},{"location":"api-reference/acl_types/#aclportspec","title":"AclPortSpec","text":"<p>A UDP or TCP port specifier.</p> <p>EosSdk reference: eos::acl_port_spec_t</p> Name Value Description oneof oper_present.oper AclRangeOperator Default value is ACL_RANGE_ANY. ports repeated uint32 Must be in range 0 to 65535."},{"location":"api-reference/acl_types/#aclrulebase","title":"AclRuleBase","text":"<p>Contains common fields for ACL rules.</p> <p>EosSdk reference: eos::acl_rule_base_t</p> Name Value Description oneof action_present.action AclAction Default value is ACL_PERMIT. log bool"},{"location":"api-reference/acl_types/#aclruleeth","title":"AclRuleEth","text":"<p>An Ethernet ACL rule which can be applied to Ethernet, Vlan and MLAG interfaces.</p> <p>EosSdk reference: eos::acl_rule_eth_t</p> Name Value Description base_fields AclRuleBase vlan uint32 Must be in range 0 to 65535. oneof vlan_mask_present.vlan_mask uint32 Must be in range 0 to 65535. Default value is 0xFFF. inner_vlan uint32 Must be in range 0 to 65535. oneof inner_vlan_mask_present.inner_vlan_mask uint32 Must be in range 0 to 65535. Default value is 0xFFF. source_addr bytes destination_addr bytes source_mask bytes destination_mask bytes oneof eth_protocol_present.eth_protocol uint32 Default value is 0xFFFFFFFF."},{"location":"api-reference/acl_types/#aclruleip","title":"AclRuleIp","text":"<p>An individual ACL rule for IPv4 or IPv6 ACLs.</p> <p>EosSdk reference: eos::acl_rule_ip_t</p> Name Value Description base_fields AclRuleBase vlan uint32 Must be in range 0 to 65535. oneof vlan_mask_present.vlan_mask uint32 Must be in range 0 to 65535. Default value is 0xFFF. inner_vlan uint32 Must be in range 0 to 65535. oneof inner_vlan_mask_present.inner_vlan_mask uint32 Must be in range 0 to 65535. Default value is 0xFFF. ip_protocol uint32 Must be in range 0 to 255. ttl AclTtlSpec source_addr IpAddrMask destination_addr IpAddrMask source_port AclPortSpec destination_port AclPortSpec nexthop_group string tcp_flags uint32 Bitmask of TCP flags. Bits should match the desired flag values defined in the enum AclTcpFlag. Must be in range 0 to 65535. oneof ip_type_present.ip_type AclIpType Default value is ACL_IP_TYPE_ANY. established bool oneof icmp_type_present.icmp_type uint32 Default value is 65535. oneof icmp_code_present.icmp_code uint32 Must be in range 0 to 65535. Default value is 65535. priority_value uint32 Must be in range 0 to 255. priority_mask uint32 Must be in range 0 to 255. match_fragments bool match_ip_priority bool"},{"location":"api-reference/acl_types/#aclttlspec","title":"AclTtlSpec","text":"<p>A TTL specifier, used in an IP ACL rule to define TTLs to match.</p> <p>EosSdk reference: eos::acl_ttl_spec_t</p> Name Value Description oneof oper_present.oper AclRangeOperator Default value is ACL_RANGE_ANY. ttl uint32 Must be in range 0 to 255."},{"location":"api-reference/acl_types/#enums","title":"Enums","text":""},{"location":"api-reference/acl_types/#aclaction","title":"AclAction","text":"<p>The action to take for an individual ACL rule.</p> <p>EosSdk reference: eos::acl_action_t</p> Name Value Description ACL_ACTION_NULL 0 ACL_PERMIT 1 ACL_DENY 2"},{"location":"api-reference/acl_types/#acldirection","title":"AclDirection","text":"<p>The direction in which an ACL is applied. Can apply to both directions by specifying them in two separate calls.</p> <p>EosSdk reference: eos::acl_direction_t</p> Name Value Description ACL_DIRECTION_NULL 0 ACL_IN 1 ACL_OUT 2"},{"location":"api-reference/acl_types/#acliptype","title":"AclIpType","text":"<p>IP traffic type to be matched.</p> <p>EosSdk reference: eos::acl_ip_type_t</p> Name Value Description ACL_IP_TYPE_NOT_SET 0 ACL_IP_TYPE_ANY 1 ACL_IP_TYPE_IP 2 ACL_IP_TYPE_MPLS 3"},{"location":"api-reference/acl_types/#aclrangeoperator","title":"AclRangeOperator","text":"<p>The type of range operator for TTL and port specifications.</p> <p>EosSdk reference: eos::acl_range_operator_t</p> Name Value Description ACL_RANGE_NULL 0 ACL_RANGE_ANY 1 ACL_RANGE_EQ 2 ACL_RANGE_GT 3 ACL_RANGE_LT 4 ACL_RANGE_NEQ 5 ACL_RANGE_BETWEEN 6"},{"location":"api-reference/acl_types/#acltcpflag","title":"AclTcpFlag","text":"<p>TCP flags used in IP rules to specify which TCP flags to match. Shows which bits correspond to which flags.</p> <p>EosSdk reference: eos::acl_tcp_flag_t</p> Name Value Description ACL_TCP_NULL 0 ACL_TCP_FIN 1 ACL_TCP_SYN 2 ACL_TCP_RST 4 ACL_TCP_PSH 8 ACL_TCP_ACK 16 ACL_TCP_URG 32 ACL_TCP_ECE 64 ACL_TCP_CWR 128"},{"location":"api-reference/acl_types/#acltype","title":"AclType","text":"<p>The ACL type.</p> <p>EosSdk reference: eos::acl_type_t</p> Name Value Description ACL_TYPE_NULL 0 ACL_TYPE_IPV4 1 ACL_TYPE_IPV6 2 ACL_TYPE_ETH 3 ACL_TYPE_MPLS 4"},{"location":"api-reference/agent/","title":"agent.proto","text":""},{"location":"api-reference/agent/#agentservice","title":"AgentService","text":""},{"location":"api-reference/agent/#watch","title":"watch","text":"<p>rpc watch(WatchAgentRequest)     WatchAgentResponse</p> <p>Subscription to monitor changes of the agent. This request stays active until it is cancelled from client side or the server is shut down. Supported events:    eos::agent_handler::on_agent_option:       Configuration option of the agent has changed.</p> <p>The events on_initialized and on_agent_enabled are out of rpc scope since they imply on creation and destruction of the RPC server itself.</p> <p>EosSdk reference: eos::agent_handler (class)</p>"},{"location":"api-reference/agent/#agent_id","title":"agent_id","text":"<p>rpc agent_id(AgentIdRequest)     AgentIdResponse</p> <p>Queries for the unique numeric ID of the given agent.</p> <p>EosSdk reference: eos::agent_mgr::id</p>"},{"location":"api-reference/agent/#enabled","title":"enabled","text":"<p>rpc enabled(AgentEnabledRequest)     AgentEnabledResponse</p> <p>Queries whether the agent is enabled or not.</p> <p>EosSdk reference: eos::agent_mgr::enabled</p>"},{"location":"api-reference/agent/#agent_option","title":"agent_option","text":"<p>rpc agent_option(AgentOptionRequest)     AgentOptionResponse</p> <p>Queries for the configured value of the given agent option.</p> <p>EosSdk reference: eos:agent_mgr::agent_option</p>"},{"location":"api-reference/agent/#agent_option_exists","title":"agent_option_exists","text":"<p>rpc agent_option_exists(AgentOptionExistsRequest)     AgentOptionExistsResponse</p> <p>Queries whether the given option exists in the configuration or not.</p> <p>EosSdk reference: eos::agent_mgr::agent_option_exists</p>"},{"location":"api-reference/agent/#agent_options","title":"agent_options","text":"<p>rpc agent_options(AgentOptionsRequest)     AgentOptionsResponse</p> <p>Enumerates all configured agent options.</p> <p>EosSdk reference: eos::agent::agent_option_iter</p>"},{"location":"api-reference/agent/#status","title":"status","text":"<p>rpc status(AgentStatusRequest)     AgentStatusResponse</p> <p>Queries for the last set value for the given status name.</p> <p>EosSdk reference: eos::agent::status</p>"},{"location":"api-reference/agent/#statuses","title":"statuses","text":"<p>rpc statuses(AgentStatusesRequest)     AgentStatusesResponse</p> <p>Enumerates all status values set by this agent.</p> <p>EosSdk reference: eos::agent::status_iter</p>"},{"location":"api-reference/agent/#status_set","title":"status_set","text":"<p>rpc status_set(AgentStatusSetRequest)     AgentStatusSetResponse</p> <p>Sets a status value for the given status name.</p> <p>EosSdk reference: eos::agent_mgr::status_set</p>"},{"location":"api-reference/agent/#bulk_status_set","title":"bulk_status_set","text":"<p>rpc bulk_status_set(AgentBulkStatusSetRequest)     AgentBulkStatusSetResponse</p> <p>Sets multiple status name/value pairs at once for this agent.</p> <p>EosSdk reference: eos::agent_mgr::status_set</p>"},{"location":"api-reference/agent/#status_del","title":"status_del","text":"<p>rpc status_del(AgentStatusDelRequest)     AgentStatusDelResponse</p> <p>Deletes the stored agent status for the given status name.</p> <p>EosSdk reference: eos::agent_mgr::status_del</p>"},{"location":"api-reference/agent/#bulk_status_del","title":"bulk_status_del","text":"<p>rpc bulk_status_del(AgentBulkStatusDelRequest)     AgentBulkStatusDelResponse</p> <p>Deletes multiple statuses at once for each given status name.</p> <p>EosSdk reference: eos::agent_mgr::status_del</p>"},{"location":"api-reference/agent/#agent_uptime","title":"agent_uptime","text":"<p>rpc agent_uptime(AgentUptimeRequest)     AgentUptimeResponse</p> <p>Gets the time elapsed since the start of this agent.</p> <p>EosSdk reference: eos::agent_mgr::agent_uptime</p>"},{"location":"api-reference/agent/#ping","title":"ping","text":"<p>rpc ping(AgentPingRequest)     AgentPingResponse</p> <p>Causes EosSdkRpc agent to echo the payload and verify that the SDK thread is also responsive.</p> <p>This function is specific to RPC and does not match any EOS SDK function.</p>"},{"location":"api-reference/agent/#messages","title":"Messages","text":""},{"location":"api-reference/agent/#agentbulkstatusdelrequest","title":"AgentBulkStatusDelRequest","text":"Name Value Description requests repeated AgentStatusDelRequest Array of AgentStatusDelRequest."},{"location":"api-reference/agent/#agentbulkstatusdelresponse","title":"AgentBulkStatusDelResponse","text":"Name Value Description processed uint64 Number of successfully deleted statuses. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/agent/#agentbulkstatussetrequest","title":"AgentBulkStatusSetRequest","text":"Name Value Description requests repeated AgentStatusSetRequest Array of AgentStatusSetRequest"},{"location":"api-reference/agent/#agentbulkstatussetresponse","title":"AgentBulkStatusSetResponse","text":"Name Value Description processed uint64 Number of successfully deleted statuses. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/agent/#agentenabledrequest","title":"AgentEnabledRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentenabledresponse","title":"AgentEnabledResponse","text":"Name Value Description enabled bool True if the agent is enabled, otherwise False."},{"location":"api-reference/agent/#agentidrequest","title":"AgentIdRequest","text":"Name Value Description name string The name of the agent to query ID for."},{"location":"api-reference/agent/#agentidresponse","title":"AgentIdResponse","text":"Name Value Description id uint32 Numeric identifier for the agent."},{"location":"api-reference/agent/#agentoption","title":"AgentOption","text":"Name Value Description name string The name of the option for which the notification is received. value string The new option value."},{"location":"api-reference/agent/#agentoptionexistsrequest","title":"AgentOptionExistsRequest","text":"Name Value Description name string The name of the agent option to query for."},{"location":"api-reference/agent/#agentoptionexistsresponse","title":"AgentOptionExistsResponse","text":"Name Value Description exists bool True if the given option name exists, otherwise False."},{"location":"api-reference/agent/#agentoptionrequest","title":"AgentOptionRequest","text":"Name Value Description name string The name of the agent option to query for."},{"location":"api-reference/agent/#agentoptionresponse","title":"AgentOptionResponse","text":"Name Value Description value string The value for the given option name."},{"location":"api-reference/agent/#agentoptionsrequest","title":"AgentOptionsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentoptionsresponse","title":"AgentOptionsResponse","text":"Name Value Description name string Configured agent option name."},{"location":"api-reference/agent/#agentpingrequest","title":"AgentPingRequest","text":"Name Value Description payload string A user-defined payload."},{"location":"api-reference/agent/#agentpingresponse","title":"AgentPingResponse","text":"Name Value Description payload string An echo of the request's payload. rpc_ack_timestamp uint64 Wall-time timestamp when the request gets acknowledged by the RPC thread expressed in nanoseconds. sdk_ack_timestamp uint64 Wall-time timestamp when the request gets acknowledged by the SDK thread, expressed in nanoseconds."},{"location":"api-reference/agent/#agentstatusdelrequest","title":"AgentStatusDelRequest","text":"Name Value Description name string"},{"location":"api-reference/agent/#agentstatusdelresponse","title":"AgentStatusDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentstatusrequest","title":"AgentStatusRequest","text":"Name Value Description name string The status name to query for."},{"location":"api-reference/agent/#agentstatusresponse","title":"AgentStatusResponse","text":"Name Value Description value string The last set status value."},{"location":"api-reference/agent/#agentstatussetrequest","title":"AgentStatusSetRequest","text":"Name Value Description name string The status name to set. value string The corresponding status value to set."},{"location":"api-reference/agent/#agentstatussetresponse","title":"AgentStatusSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentstatusesrequest","title":"AgentStatusesRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentstatusesresponse","title":"AgentStatusesResponse","text":"Name Value Description name string Status value set by this agent."},{"location":"api-reference/agent/#agentuptimerequest","title":"AgentUptimeRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/agent/#agentuptimeresponse","title":"AgentUptimeResponse","text":"Name Value Description seconds double The elapsed time in seconds."},{"location":"api-reference/agent/#watchagentrequest","title":"WatchAgentRequest","text":"Name Value Description ack bool Set to true when an ackowledgment is desired."},{"location":"api-reference/agent/#watchagentresponse","title":"WatchAgentResponse","text":"<p>Events are streamed as changes happen.</p> Name Value Description oneof agent_event.option_event AgentOption ack bool If true, this is not an event and the fields below are invalid."},{"location":"api-reference/bgp/","title":"bgp.proto","text":""},{"location":"api-reference/bgp/#bgpmgrservice","title":"BgpMgrService","text":""},{"location":"api-reference/bgp/#watch","title":"watch","text":"<p>rpc watch(BgpPeerWatchRequest)     BgpPeerWatchResponse</p> <p>Subscription to monitor changes to BGP peers. This request stays active until the client cancels or the server shuts down.</p> <p>EosSdk reference: eos::bgp_peer_handler (class)</p>"},{"location":"api-reference/bgp/#exists","title":"exists","text":"<p>rpc exists(BgpPeerExistsRequest)     BgpPeerExistsResponse</p> <p>Queries whether a BGP peer exists or not.</p> <p>EosSdk reference: eos::bgp_mgr::exists.</p>"},{"location":"api-reference/bgp/#peer_state","title":"peer_state","text":"<p>rpc peer_state(BgpPeerStateRequest)     BgpPeerStateResponse</p> <p>Queries the state of a peer session.</p> <p>EosSdk reference: eos::bgp_mgr::peer_state.</p>"},{"location":"api-reference/bgp/#messages","title":"Messages","text":""},{"location":"api-reference/bgp/#bgppeerexistsrequest","title":"BgpPeerExistsRequest","text":"Name Value Description peer_key BgpPeerKey The key of the BGP peer to query."},{"location":"api-reference/bgp/#bgppeerexistsresponse","title":"BgpPeerExistsResponse","text":"Name Value Description exists bool True if the BGP peer exists otherwise false."},{"location":"api-reference/bgp/#bgppeerstaterequest","title":"BgpPeerStateRequest","text":"Name Value Description peer_key BgpPeerKey The key of the BGP peer to query."},{"location":"api-reference/bgp/#bgppeerstateresponse","title":"BgpPeerStateResponse","text":"Name Value Description peer_state BgpPeerState State of the specified peer session."},{"location":"api-reference/bgp/#bgppeerwatchrequest","title":"BgpPeerWatchRequest","text":"Name Value Description ack bool Set to true if an immediate acknowledgement is desired. oneof overload.all bool True if all BGP peers should be watched. oneof overload.peer_key BgpPeerKey The peer key of a particular peer to watch."},{"location":"api-reference/bgp/#bgppeerwatchresponse","title":"BgpPeerWatchResponse","text":"Name Value Description ack bool If true the agent is now actively watching for events. oneof peer_event.on_peer_set OnBgpPeerSet The specified BGP peer has been programmed by the BGP agent. oneof peer_event.on_peer_del OnBgpPeerDel The specified BGP peer has been deleted from the BGP agent. on_peer_state OnBgpPeerState The specified BGP peer changed state."},{"location":"api-reference/bgp/#onbgppeerdel","title":"OnBgpPeerDel","text":"Name Value Description peer_key BgpPeerKey"},{"location":"api-reference/bgp/#onbgppeerset","title":"OnBgpPeerSet","text":"Name Value Description peer_key BgpPeerKey"},{"location":"api-reference/bgp/#onbgppeerstate","title":"OnBgpPeerState","text":"Name Value Description peer_key BgpPeerKey peer_state BgpPeerState"},{"location":"api-reference/bgp_link/","title":"bgp_link.proto","text":""},{"location":"api-reference/bgp_link/#bgplinkweightmgrservice","title":"BgpLinkWeightMgrService","text":"<p>Update the link weight to be used in the BGP control plane for outbound link-bandwidth advertisements if the interface is used as the directly connected peering interface.</p>"},{"location":"api-reference/bgp_link/#link_weights","title":"link_weights","text":"<p>rpc link_weights(BgpLinkWeightsRequest)     BgpLinkWeightsResponse</p> <p>Get the link weights for one or multiple interfaces.</p>"},{"location":"api-reference/bgp_link/#bulk_link_weight_set","title":"bulk_link_weight_set","text":"<p>rpc bulk_link_weight_set(BulkBgpLinkWeightSetRequest)     BulkBgpLinkWeightSetResponse</p> <p>Set the link weight for multiple interfaces.</p>"},{"location":"api-reference/bgp_link/#bulk_link_weight_del","title":"bulk_link_weight_del","text":"<p>rpc bulk_link_weight_del(BulkBgpLinkWeightDelRequest)     BulkBgpLinkWeightDelResponse</p> <p>Delete the link weight for multiple interfaces.</p>"},{"location":"api-reference/bgp_link/#link_weight_resync_init","title":"link_weight_resync_init","text":"<p>rpc link_weight_resync_init(BgpLinkWeightResyncInitRequest)     BgpLinkWeightResyncInitResponse</p> <p>Starts the link weight resync process, to set the link weights to a known state. The resync_complete rpc, must be called to end the resync. To remove the link weight for all interfaces use with no operations in between: link_weight_resync_init() link_weight_resync_complete()</p>"},{"location":"api-reference/bgp_link/#link_weight_resync_complete","title":"link_weight_resync_complete","text":"<p>rpc link_weight_resync_complete(BgpLinkWeightResyncCompleteRequest)     BgpLinkWeightResyncCompleteResponse</p> <p>Ends the current link weight resync process. All link weights not added or modified during the resync will be deleted.</p>"},{"location":"api-reference/bgp_link/#messages","title":"Messages","text":""},{"location":"api-reference/bgp_link/#bgplinkweightdelrequest","title":"BgpLinkWeightDelRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/bgp_link/#bgplinkweightresynccompleterequest","title":"BgpLinkWeightResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_link/#bgplinkweightresynccompleteresponse","title":"BgpLinkWeightResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_link/#bgplinkweightresyncinitrequest","title":"BgpLinkWeightResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_link/#bgplinkweightresyncinitresponse","title":"BgpLinkWeightResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_link/#bgplinkweightsetrequest","title":"BgpLinkWeightSetRequest","text":"Name Value Description intf_id IntfId Name of the interface. link_weight uint32 Link weight associated with the interface, 0 &lt; link_weight &lt; 2^24."},{"location":"api-reference/bgp_link/#bgplinkweightsrequest","title":"BgpLinkWeightsRequest","text":"Name Value Description intf_id_regex string Optional regex to filter out interfaces. If blank, no filters will be applied."},{"location":"api-reference/bgp_link/#bgplinkweightsresponse","title":"BgpLinkWeightsResponse","text":"Name Value Description intf_id IntfId Name of the interface. link_weight uint32 Link weight associated with the interface, 0 &lt; link_weight &lt; 2^24."},{"location":"api-reference/bgp_link/#bulkbgplinkweightdelrequest","title":"BulkBgpLinkWeightDelRequest","text":"Name Value Description requests repeated BgpLinkWeightDelRequest List of BgpLinkWeightDelRequests."},{"location":"api-reference/bgp_link/#bulkbgplinkweightdelresponse","title":"BulkBgpLinkWeightDelResponse","text":"Name Value Description processed uint64 Number of successful requests processed. status RpcResponseStatus Error details, if any."},{"location":"api-reference/bgp_link/#bulkbgplinkweightsetrequest","title":"BulkBgpLinkWeightSetRequest","text":"Name Value Description requests repeated BgpLinkWeightSetRequest List of BgpLinkWeightSetRequests."},{"location":"api-reference/bgp_link/#bulkbgplinkweightsetresponse","title":"BulkBgpLinkWeightSetResponse","text":"Name Value Description processed uint64 Number of successful requests processed. status RpcResponseStatus Error details, if any."},{"location":"api-reference/bgp_path/","title":"bgp_path.proto","text":""},{"location":"api-reference/bgp_path/#bgppathmgrservice","title":"BgpPathMgrService","text":""},{"location":"api-reference/bgp_path/#watch","title":"watch","text":"<p>rpc watch(BgpPathWatchRequest)     BgpPathWatchResponse</p> <p>Subscription to monitor changes to bgp paths. This request stays active until the client cancels or the server shuts down. When all = false and no version is specified, this request has no effect.</p> <p>EosSdk reference: eos::bgp_path_handler (class)</p>"},{"location":"api-reference/bgp_path/#ipv4_unicast_paths","title":"ipv4_unicast_paths","text":"<p>rpc ipv4_unicast_paths(Ipv4UnicastPathsRequest)     Ipv4UnicastPathsResponse</p> <p>Iterates through all IPv4 paths in adj-RIB-in that match the search criteria.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv4_unicast_path_iter</p>"},{"location":"api-reference/bgp_path/#ipv4_unicast_path","title":"ipv4_unicast_path","text":"<p>rpc ipv4_unicast_path(Ipv4UnicastPathRequest)     Ipv4UnicastPathResponse</p> <p>Queries a single path, given its key and search criteria.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv4_unicast_path</p>"},{"location":"api-reference/bgp_path/#ipv4_unicast_bgp_convergence","title":"ipv4_unicast_bgp_convergence","text":"<p>rpc ipv4_unicast_bgp_convergence(Ipv4UnicastBgpConvergenceRequest)     Ipv4UnicastBgpConvergenceResponse</p> <p>Queries if IPv4 family has converged.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv4_unicast_bgp_convergence</p>"},{"location":"api-reference/bgp_path/#ipv6_unicast_paths","title":"ipv6_unicast_paths","text":"<p>rpc ipv6_unicast_paths(Ipv6UnicastPathsRequest)     Ipv6UnicastPathsResponse</p> <p>Iterates through adj-RIB-in for paths that match the criteria.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv6_unicast_path_iter</p>"},{"location":"api-reference/bgp_path/#ipv6_unicast_path","title":"ipv6_unicast_path","text":"<p>rpc ipv6_unicast_path(Ipv6UnicastPathRequest)     Ipv6UnicastPathResponse</p> <p>Queries a single path, given its key and search criteria.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv6_unicast_path</p>"},{"location":"api-reference/bgp_path/#ipv6_unicast_bgp_convergence","title":"ipv6_unicast_bgp_convergence","text":"<p>rpc ipv6_unicast_bgp_convergence(Ipv6UnicastBgpConvergenceRequest)     Ipv6UnicastBgpConvergenceResponse</p> <p>Queries if IPv6 family has converged.</p> <p>EosSdk reference: eos::bgp_path_mgr::ipv6_unicast_bgp_convergence</p>"},{"location":"api-reference/bgp_path/#messages","title":"Messages","text":""},{"location":"api-reference/bgp_path/#bgppathwatchrequest","title":"BgpPathWatchRequest","text":"Name Value Description oneof overloads.all_paths bool oneof overloads.ipv4_unicast_paths bool True if IPv4 unicast paths should be monitored. oneof overloads.ipv6_unicast_paths bool True if IPv6 unicast paths should be monitored. ack bool Set to true when an ackowledgment is desired."},{"location":"api-reference/bgp_path/#bgppathwatchresponse","title":"BgpPathWatchResponse","text":"<p>Events are streamed as changes happen.</p> Name Value Description ip_version IpVersion IP family affected by the event. oneof events.path_key BgpPathKey Path changed in adj-RIB-in. oneof events.converged bool BGP convergence changed for that IP family. ack bool If true, this is not an event and the fields below are invalid."},{"location":"api-reference/bgp_path/#ipv4unicastbgpconvergencerequest","title":"Ipv4UnicastBgpConvergenceRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_path/#ipv4unicastbgpconvergenceresponse","title":"Ipv4UnicastBgpConvergenceResponse","text":"Name Value Description converged bool True if IPv4 family has converged."},{"location":"api-reference/bgp_path/#ipv4unicastpathrequest","title":"Ipv4UnicastPathRequest","text":"Name Value Description path_key BgpPathKey path_options BgpPathOptions"},{"location":"api-reference/bgp_path/#ipv4unicastpathresponse","title":"Ipv4UnicastPathResponse","text":"Name Value Description path BgpPath Path matching criteria or empty if not found."},{"location":"api-reference/bgp_path/#ipv4unicastpathsrequest","title":"Ipv4UnicastPathsRequest","text":"Name Value Description path_options BgpPathOptions"},{"location":"api-reference/bgp_path/#ipv4unicastpathsresponse","title":"Ipv4UnicastPathsResponse","text":"Name Value Description path BgpPath List of paths that match the criteria."},{"location":"api-reference/bgp_path/#ipv6unicastbgpconvergencerequest","title":"Ipv6UnicastBgpConvergenceRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/bgp_path/#ipv6unicastbgpconvergenceresponse","title":"Ipv6UnicastBgpConvergenceResponse","text":"Name Value Description converged bool True if IPv6 family has converged."},{"location":"api-reference/bgp_path/#ipv6unicastpathrequest","title":"Ipv6UnicastPathRequest","text":"Name Value Description path_key BgpPathKey path_options BgpPathOptions"},{"location":"api-reference/bgp_path/#ipv6unicastpathresponse","title":"Ipv6UnicastPathResponse","text":"Name Value Description path BgpPath Path matching criteria or empty if not found."},{"location":"api-reference/bgp_path/#ipv6unicastpathsrequest","title":"Ipv6UnicastPathsRequest","text":"Name Value Description path_options BgpPathOptions"},{"location":"api-reference/bgp_path/#ipv6unicastpathsresponse","title":"Ipv6UnicastPathsResponse","text":"Name Value Description path BgpPath A path that matches the criteria."},{"location":"api-reference/bgp_path_types/","title":"bgp_path_types.proto","text":""},{"location":"api-reference/bgp_path_types/#messages","title":"Messages","text":""},{"location":"api-reference/bgp_path_types/#bgppath","title":"BgpPath","text":"Name Value Description path_key BgpPathKey path_attrs BgpPathAttrs"},{"location":"api-reference/bgp_path_types/#bgppathattrfields","title":"BgpPathAttrFields","text":"Name Value Description next_hop bool Perform next hop lookup. community_list bool Perform community list lookup."},{"location":"api-reference/bgp_path_types/#bgppathattrs","title":"BgpPathAttrs","text":"Name Value Description next_hop bytes origin int32 med uint32 local_pref uint32 community_list repeated uint32"},{"location":"api-reference/bgp_path_types/#bgppathkey","title":"BgpPathKey","text":"Name Value Description prefix Prefix peer_addr bytes vrf_name string"},{"location":"api-reference/bgp_path_types/#bgppathoptions","title":"BgpPathOptions","text":"Name Value Description stage BgpReceiveRouteStages Either BGP_PATH_PRE_POLICY or BGP_PATH_POST_POLICY. attrs BgpPathAttrFields"},{"location":"api-reference/bgp_path_types/#enums","title":"Enums","text":""},{"location":"api-reference/bgp_path_types/#bgpreceiveroutestages","title":"BgpReceiveRouteStages","text":"Name Value Description BGP_PATH_PRE_POLICY 0 BGP_PATH_POST_POLICY 1"},{"location":"api-reference/bgp_types/","title":"bgp_types.proto","text":""},{"location":"api-reference/bgp_types/#messages","title":"Messages","text":""},{"location":"api-reference/bgp_types/#bgppeerkey","title":"BgpPeerKey","text":"Name Value Description vrf_name string peer_addr string"},{"location":"api-reference/bgp_types/#enums","title":"Enums","text":""},{"location":"api-reference/bgp_types/#bgppeerstate","title":"BgpPeerState","text":"Name Value Description BGP_PEER_STATE_UNKNOWN 0 BGP_PEER_STATE_IDLE 1 BGP_PEER_STATE_CONNECT 2 BGP_PEER_STATE_ACTIVE 3 BGP_PEER_STATE_OPENSENT 4 BGP_PEER_STATE_OPENCONFIRM 5 BGP_PEER_STATE_ESTABLISHED 6"},{"location":"api-reference/class_map/","title":"class_map.proto","text":""},{"location":"api-reference/class_map/#classmapmgrservice","title":"ClassMapMgrService","text":""},{"location":"api-reference/class_map/#resync_init","title":"resync_init","text":"<p>rpc resync_init(ClassMapResyncInitRequest)     ClassMapResyncInitResponse</p> <p>Initiates a class map resync process. Starts a blank configuration to be applied once resync_complete is called.</p> <p>EosSdk reference: eos::class_map_mgr::resync_init</p>"},{"location":"api-reference/class_map/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(ClassMapResyncCompleteRequest)     ClassMapResyncCompleteResponse</p> <p>Ends the current class map resync process.</p> <p>EosSdk reference: eos::class_map_mgr::resync_complete</p>"},{"location":"api-reference/class_map/#exists","title":"exists","text":"<p>rpc exists(ClassMapExistsRequest)     ClassMapExistsResponse</p> <p>Queries whether the specified class map is configured or not.</p> <p>EosSdk reference: eos::class_map_mgr::exists</p>"},{"location":"api-reference/class_map/#class_map","title":"class_map","text":"<p>rpc class_map(ClassMapRequest)     ClassMapResponse</p> <p>Queries a class map given its key.</p> <p>EosSdk reference: eos::class_map_mgr::class_map</p>"},{"location":"api-reference/class_map/#class_map_is","title":"class_map_is","text":"<p>rpc class_map_is(ClassMapIsRequest)     ClassMapIsResponse</p> <p>Creates or updates a class map.</p> <p>EosSdk reference: eos::class_map_mgr::class_map_is</p>"},{"location":"api-reference/class_map/#bulk_class_map_is","title":"bulk_class_map_is","text":"<p>rpc bulk_class_map_is(BulkClassMapIsRequest)     BulkClassMapIsResponse</p> <p>Creates or updates multiple class maps in a single call.</p> <p>EosSdk reference: eos::class_map_mgr::class_map_is</p>"},{"location":"api-reference/class_map/#class_map_del","title":"class_map_del","text":"<p>rpc class_map_del(ClassMapDelRequest)     ClassMapDelResponse</p> <p>Deletes a class map.</p> <p>EosSdk reference: eos::class_map_mgr::class_map_del</p>"},{"location":"api-reference/class_map/#bulk_class_map_del","title":"bulk_class_map_del","text":"<p>rpc bulk_class_map_del(BulkClassMapDelRequest)     BulkClassMapDelResponse</p> <p>Deletes multiple class maps in a single call.</p> <p>EosSdk reference: eos::class_map_mgr::class_map_del</p>"},{"location":"api-reference/class_map/#class_maps","title":"class_maps","text":"<p>rpc class_maps(ClassMapsRequest)     ClassMapsResponse</p> <p>Returns a list of the keys of the configured class maps for a  specified policy_feature</p> <p>EosSdk reference: eos::class_map_mgr::class_map_iter</p>"},{"location":"api-reference/class_map/#messages","title":"Messages","text":""},{"location":"api-reference/class_map/#bulkclassmapdelrequest","title":"BulkClassMapDelRequest","text":"Name Value Description requests repeated ClassMapDelRequest List of ClassMapDelRequests specifying the class maps to delete"},{"location":"api-reference/class_map/#bulkclassmapdelresponse","title":"BulkClassMapDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the case of failure."},{"location":"api-reference/class_map/#bulkclassmapisrequest","title":"BulkClassMapIsRequest","text":"Name Value Description requests repeated ClassMapIsRequest List of ClassMapIsRequests specifying the class maps to create."},{"location":"api-reference/class_map/#bulkclassmapisresponse","title":"BulkClassMapIsResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the case of failure."},{"location":"api-reference/class_map/#classmapdelrequest","title":"ClassMapDelRequest","text":"Name Value Description key PolicyMapKey The key of the class map to delete."},{"location":"api-reference/class_map/#classmapdelresponse","title":"ClassMapDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmapexistsrequest","title":"ClassMapExistsRequest","text":"Name Value Description key PolicyMapKey The key of the class map to query."},{"location":"api-reference/class_map/#classmapexistsresponse","title":"ClassMapExistsResponse","text":"Name Value Description exists bool True if the class map is configured otherwise false."},{"location":"api-reference/class_map/#classmapisrequest","title":"ClassMapIsRequest","text":"Name Value Description class_map ClassMap The class map to create or update."},{"location":"api-reference/class_map/#classmapisresponse","title":"ClassMapIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmaprequest","title":"ClassMapRequest","text":"Name Value Description key PolicyMapKey The key of the class map to query."},{"location":"api-reference/class_map/#classmapresponse","title":"ClassMapResponse","text":"Name Value Description class_map ClassMap The class map corresponding to the key or empty if not found."},{"location":"api-reference/class_map/#classmapresynccompleterequest","title":"ClassMapResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmapresynccompleteresponse","title":"ClassMapResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmapresyncinitrequest","title":"ClassMapResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmapresyncinitresponse","title":"ClassMapResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/class_map/#classmapsrequest","title":"ClassMapsRequest","text":"Name Value Description feature PolicyFeature The policy feature to list the configured class maps for"},{"location":"api-reference/class_map/#classmapsresponse","title":"ClassMapsResponse","text":"Name Value Description key PolicyMapKey The key of the feature's configured class maps."},{"location":"api-reference/class_map_types/","title":"class_map_types.proto","text":""},{"location":"api-reference/class_map_types/#messages","title":"Messages","text":""},{"location":"api-reference/class_map_types/#classmap","title":"ClassMap","text":"Name Value Description key PolicyMapKey rules map ClassMap.RulesEntry"},{"location":"api-reference/class_map_types/#classmaprulesentry","title":"ClassMap.RulesEntry","text":"Name Value Description key uint32 value ClassMapRule"},{"location":"api-reference/class_map_types/#classmaprule","title":"ClassMapRule","text":"Name Value Description acl_key AclKey"},{"location":"api-reference/eapi/","title":"eapi.proto","text":""},{"location":"api-reference/eapi/#eapimgrservice","title":"EapiMgrService","text":""},{"location":"api-reference/eapi/#run_show_cmd","title":"run_show_cmd","text":"<p>rpc run_show_cmd(RunShowCmdRequest)     RunShowCmdResponse</p> <p>Queries for the output of a CLI show command.</p> <p>EosSdk reference: eos::eapi_mgr::run_show_cmd</p>"},{"location":"api-reference/eapi/#run_config_cmds","title":"run_config_cmds","text":"<p>rpc run_config_cmds(RunConfigCmdsRequest)     RunConfigCmdsResponse</p> <p>Executes one or more configuration commands.</p> <p>EosSdk reference: eos::eapi_mgr::run_config_cmds</p>"},{"location":"api-reference/eapi/#messages","title":"Messages","text":""},{"location":"api-reference/eapi/#runconfigcmdsrequest","title":"RunConfigCmdsRequest","text":"Name Value Description commands repeated string Array of configuration commands to execute."},{"location":"api-reference/eapi/#runconfigcmdsresponse","title":"RunConfigCmdsResponse","text":"Name Value Description response EapiResponse EapiResponse, containing any output and/or any errors."},{"location":"api-reference/eapi/#runshowcmdrequest","title":"RunShowCmdRequest","text":"Name Value Description command string The show command to execute e.g \"show version\"."},{"location":"api-reference/eapi/#runshowcmdresponse","title":"RunShowCmdResponse","text":"Name Value Description response EapiResponse EapiResponse, containing the output and/or any errors."},{"location":"api-reference/eapi_types/","title":"eapi_types.proto","text":""},{"location":"api-reference/eapi_types/#messages","title":"Messages","text":""},{"location":"api-reference/eapi_types/#eapiresponse","title":"EapiResponse","text":"Name Value Description success bool error_code uint32 error_message string responses repeated string raw_response string"},{"location":"api-reference/eth_lag_intf/","title":"eth_lag_intf.proto","text":""},{"location":"api-reference/eth_lag_intf/#ethlagintfmgrservice","title":"EthLagIntfMgrService","text":""},{"location":"api-reference/eth_lag_intf/#watch","title":"watch","text":"<p>rpc watch(EthLagIntfWatchRequest)     EthLagIntfWatchResponse</p> <p>Subscription to monitor LAG interface events. This request stays active until the client cancels or the server shuts down. When all = false and no version is specified, this request has no effect.</p> <p>EosSdk reference: eos::eth_lag_intf_handler (class)</p>"},{"location":"api-reference/eth_lag_intf/#eth_lag_intfs","title":"eth_lag_intfs","text":"<p>rpc eth_lag_intfs(EthLagIntfsRequest)     EthLagIntfsResponse</p> <p>Returns a list of interfaces configured as members of any LAG interface in system.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_iter</p>"},{"location":"api-reference/eth_lag_intf/#exists","title":"exists","text":"<p>rpc exists(EthLagIntfExistsRequest)     EthLagIntfExistsResponse</p> <p>Queries whether an ethernet LAG interface exists.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_exists</p>"},{"location":"api-reference/eth_lag_intf/#eth_lag_intf_members","title":"eth_lag_intf_members","text":"<p>rpc eth_lag_intf_members(EthLagIntfMembersRequest)     EthLagIntfMembersResponse</p> <p>Returns a list of physical interfaces configured as members of any LAG interface in the system.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_member_iter</p>"},{"location":"api-reference/eth_lag_intf/#eth_lag_intf_is","title":"eth_lag_intf_is","text":"<p>rpc eth_lag_intf_is(EthLagIntfIsRequest)     EthLagIntfIsResponse</p> <p>Creates a LAG interface.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_eth_lag_intf_is","title":"bulk_eth_lag_intf_is","text":"<p>rpc bulk_eth_lag_intf_is(BulkEthLagIntfIsRequest)     BulkEthLagIntfIsResponse</p> <p>Creates many LAG interfaces in a single request.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_is</p>"},{"location":"api-reference/eth_lag_intf/#eth_lag_intf","title":"eth_lag_intf","text":"<p>rpc eth_lag_intf(EthLagIntfRequest)     EthLagIntfResponse</p> <p>Returns the details for a LAG interface given its ID.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf</p>"},{"location":"api-reference/eth_lag_intf/#eth_lag_intf_del","title":"eth_lag_intf_del","text":"<p>rpc eth_lag_intf_del(EthLagIntfDelRequest)     EthLagIntfDelResponse</p> <p>Deletes a LAG interface.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_del</p>"},{"location":"api-reference/eth_lag_intf/#bulk_eth_lag_intf_del","title":"bulk_eth_lag_intf_del","text":"<p>rpc bulk_eth_lag_intf_del(BulkEthLagIntfDelRequest)     BulkEthLagIntfDelResponse</p> <p>Deletes many LAG interfaces in a single request.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_del</p>"},{"location":"api-reference/eth_lag_intf/#speed","title":"speed","text":"<p>rpc speed(EthLagIntfSpeedRequest)     EthLagIntfSpeedResponse</p> <p>Returns the speed of a LAG interface, in Mbits/s.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::speed</p>"},{"location":"api-reference/eth_lag_intf/#min_links","title":"min_links","text":"<p>rpc min_links(EthLagIntfMinLinksRequest)     EthLagIntfMinLinksResponse</p> <p>Returns the minimum number of links that must be up for a LAG interface to be considered up too.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::min_links</p>"},{"location":"api-reference/eth_lag_intf/#min_links_is","title":"min_links_is","text":"<p>rpc min_links_is(EthLagIntfMinLinksIsRequest)     EthLagIntfMinLinksIsResponse</p> <p>Sets min links values for a LAG interface.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_min_links_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_min_links_is","title":"bulk_min_links_is","text":"<p>rpc bulk_min_links_is(BulkEthLagIntfMinLinksIsRequest)     BulkEthLagIntfMinLinksIsResponse</p> <p>Sets min links values for many LAG interfaces.</p> <p>EosSdk reference:: eos::eth_lag_intf_mgr::eth_lag_intf_min_links_is</p>"},{"location":"api-reference/eth_lag_intf/#min_speed","title":"min_speed","text":"<p>rpc min_speed(EthLagIntfMinSpeedRequest)     EthLagIntfMinSpeedResponse</p> <p>Returns the configured value for minimum speed (in Mbps)</p> <p>EosSdk reference: eos::eth_lag_intf_mgr::min_speed</p>"},{"location":"api-reference/eth_lag_intf/#min_speed_is","title":"min_speed_is","text":"<p>rpc min_speed_is(EthLagIntfMinSpeedIsRequest)     EthLagIntfMinSpeedIsResponse</p> <p>Sets the configuration for minimum speed (in Mbps)</p> <p>EosSdk reference: eos::eth_lag_intf_mgr::min_speed_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_min_speed_is","title":"bulk_min_speed_is","text":"<p>rpc bulk_min_speed_is(BulkEthLagIntfMinSpeedIsRequest)     BulkEthLagIntfMinSpeedIsResponse</p> <p>Bulk variant for min_speed_is</p> <p>EosSdk reference: eos::eth_lag_intf_mgr::min_speed_is</p>"},{"location":"api-reference/eth_lag_intf/#fallback_type_is","title":"fallback_type_is","text":"<p>rpc fallback_type_is(EthLagIntfFallbackTypeIsRequest)     EthLagIntfFallbackTypeIsResponse</p> <p>Sets the fallback type for a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_type_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_fallback_type_is","title":"bulk_fallback_type_is","text":"<p>rpc bulk_fallback_type_is(BulkEthLagIntfFallbackTypeIsRequest)     BulkEthLagIntfFallbackTypeIsResponse</p> <p>Sets the fallback type for many LAG interfaces.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_type_is</p>"},{"location":"api-reference/eth_lag_intf/#fallback_type","title":"fallback_type","text":"<p>rpc fallback_type(EthLagIntfFallbackTypeRequest)     EthLagIntfFallbackTypeResponse</p> <p>Returns the fallback mode for a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_type</p>"},{"location":"api-reference/eth_lag_intf/#fallback_timeout_is","title":"fallback_timeout_is","text":"<p>rpc fallback_timeout_is(EthLagIntfFallbackTimeoutIsRequest)     EthLagIntfFallbackTimeoutIsResponse</p> <p>Sets the fallback timeout for a LAG interface, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_timeout_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_fallback_timeout_is","title":"bulk_fallback_timeout_is","text":"<p>rpc bulk_fallback_timeout_is(BulkEthLagIntfFallbackTimeoutIsRequest)     BulkEthLagIntfFallbackTimeoutIsResponse</p> <p>Sets fallback timeouts for multiple LAG interfaces, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_timeout_is</p>"},{"location":"api-reference/eth_lag_intf/#fallback_timeout","title":"fallback_timeout","text":"<p>rpc fallback_timeout(EthLagIntfFallbackTimeoutRequest)     EthLagIntfFallbackTimeoutResponse</p> <p>Returns the LACP active mode timeout value, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_timeout</p>"},{"location":"api-reference/eth_lag_intf/#fallback_timeout_default","title":"fallback_timeout_default","text":"<p>rpc fallback_timeout_default(EthLagIntfFallbackTimeoutDefaultRequest)     EthLagIntfFallbackTimeoutDefaultResponse</p> <p>Returns the default fallback timeout value, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::fallback_timeout_default</p>"},{"location":"api-reference/eth_lag_intf/#membership_set","title":"membership_set","text":"<p>rpc membership_set(EthLagIntfMembershipSetRequest)     EthLagIntfMembershipSetResponse</p> <p>Adds a physical interface to a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership_set</p>"},{"location":"api-reference/eth_lag_intf/#bulk_membership_set","title":"bulk_membership_set","text":"<p>rpc bulk_membership_set(BulkEthLagIntfMembershipSetRequest)     BulkEthLagIntfMembershipSetResponse</p> <p>Adds multiple physical interfaces to multiple LAG interfaces.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership_set</p>"},{"location":"api-reference/eth_lag_intf/#membership_del","title":"membership_del","text":"<p>rpc membership_del(EthLagIntfMembershipDelRequest)     EthLagIntfMembershipDelResponse</p> <p>Removes an interface from a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership_del</p>"},{"location":"api-reference/eth_lag_intf/#bulk_membership_del","title":"bulk_membership_del","text":"<p>rpc bulk_membership_del(BulkEthLagIntfMembershipDelRequest)     BulkEthLagIntfMembershipDelResponse</p> <p>Removes multiple interfaces from muliple LAG interfaces.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership_del</p>"},{"location":"api-reference/eth_lag_intf/#membership","title":"membership","text":"<p>rpc membership(EthLagIntfMembershipRequest)     EthLagIntfMembershipResponse</p> <p>Returns the LAG interface ID to which the physical interface is configured to belong.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership</p>"},{"location":"api-reference/eth_lag_intf/#membership_status","title":"membership_status","text":"<p>rpc membership_status(EthLagIntfMembershipStatusRequest)     EthLagIntfMembershipStatusResponse</p> <p>Returns the member interface's status details.</p> <p>EosSdk reference: eth_lag_intf_mgr::membership_status</p>"},{"location":"api-reference/eth_lag_intf/#member_priority_is","title":"member_priority_is","text":"<p>rpc member_priority_is(EthLagIntfMemberPriorityIsRequest)     EthLagIntfMemberPriorityIsResponse</p> <p>Sets the port LACP priority.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_priority_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_member_priority_is","title":"bulk_member_priority_is","text":"<p>rpc bulk_member_priority_is(BulkEthLagIntfMemberPriorityIsRequest)     BulkEthLagIntfMemberPriorityIsResponse</p> <p>Sets LACP priorities of multiple ports.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_priority_is</p>"},{"location":"api-reference/eth_lag_intf/#member_priority","title":"member_priority","text":"<p>rpc member_priority(EthLagIntfMemberPriorityRequest)     EthLagIntfMemberPriorityResponse</p> <p>Gets the interface's configured LACP priority.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_priority</p>"},{"location":"api-reference/eth_lag_intf/#member_mode_is","title":"member_mode_is","text":"<p>rpc member_mode_is(EthLagIntfMemberModeIsRequest)     EthLagIntfMemberModeIsResponse</p> <p>Sets the mode of this member in a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_mode_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_member_mode_is","title":"bulk_member_mode_is","text":"<p>rpc bulk_member_mode_is(BulkEthLagIntfMemberModeIsRequest)     BulkEthLagIntfMemberModeIsResponse</p> <p>Sets the modes of multiple members in LAG interfaces.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_mode_is</p>"},{"location":"api-reference/eth_lag_intf/#member_mode","title":"member_mode","text":"<p>rpc member_mode(EthLagIntfMemberModeRequest)     EthLagIntfMemberModeResponse</p> <p>Returns the mode of this member in a LAG interface.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_mode</p>"},{"location":"api-reference/eth_lag_intf/#member_timeout_is","title":"member_timeout_is","text":"<p>rpc member_timeout_is(EthLagIntfMemberTimeoutIsRequest)     EthLagIntfMemberTimeoutIsResponse</p> <p>Sets the LACP timeout for a member in a LAG, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_timeout_is</p>"},{"location":"api-reference/eth_lag_intf/#bulk_member_timeout_is","title":"bulk_member_timeout_is","text":"<p>rpc bulk_member_timeout_is(BulkEthLagIntfMemberTimeoutIsRequest)     BulkEthLagIntfMemberTimeoutIsResponse</p> <p>Sets the LACP timeout for multiple members in LAG interfaces, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_timeout_is</p>"},{"location":"api-reference/eth_lag_intf/#member_timeout","title":"member_timeout","text":"<p>rpc member_timeout(EthLagIntfMemberTimeoutRequest)     EthLagIntfMemberTimeoutResponse</p> <p>Gets the configured LACP timeout for a member in a LAG, in seconds.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_timeout</p>"},{"location":"api-reference/eth_lag_intf/#member_active","title":"member_active","text":"<p>rpc member_active(EthLagIntfMemberActiveRequest)     EthLagIntfMemberActiveResponse</p> <p>Returns whether this interface is active in a LAG.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_active</p>"},{"location":"api-reference/eth_lag_intf/#member_time","title":"member_time","text":"<p>rpc member_time(EthLagIntfMemberTimeRequest)     EthLagIntfMemberTimeResponse</p> <p>Returns the time in seconds since reboot when this interface was last added  or removed as a member from a LAG.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_time</p>"},{"location":"api-reference/eth_lag_intf/#member_reason","title":"member_reason","text":"<p>rpc member_reason(EthLagIntfMemberReasonRequest)     EthLagIntfMemberReasonResponse</p> <p>Returns the reason this interface isn't active in a LAG.</p> <p>EosSdk reference: eth_lag_intf_mgr::member_reason</p>"},{"location":"api-reference/eth_lag_intf/#messages","title":"Messages","text":""},{"location":"api-reference/eth_lag_intf/#bulkethlagintfdelrequest","title":"BulkEthLagIntfDelRequest","text":"Name Value Description requests repeated EthLagIntfDelRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfdelresponse","title":"BulkEthLagIntfDelResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintffallbacktimeoutisrequest","title":"BulkEthLagIntfFallbackTimeoutIsRequest","text":"Name Value Description requests repeated EthLagIntfFallbackTimeoutIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintffallbacktimeoutisresponse","title":"BulkEthLagIntfFallbackTimeoutIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintffallbacktypeisrequest","title":"BulkEthLagIntfFallbackTypeIsRequest","text":"Name Value Description requests repeated EthLagIntfFallbackTypeIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintffallbacktypeisresponse","title":"BulkEthLagIntfFallbackTypeIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfisrequest","title":"BulkEthLagIntfIsRequest","text":"Name Value Description requests repeated EthLagIntfIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfisresponse","title":"BulkEthLagIntfIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembermodeisrequest","title":"BulkEthLagIntfMemberModeIsRequest","text":"Name Value Description requests repeated EthLagIntfMemberModeIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembermodeisresponse","title":"BulkEthLagIntfMemberModeIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmemberpriorityisrequest","title":"BulkEthLagIntfMemberPriorityIsRequest","text":"Name Value Description requests repeated EthLagIntfMemberPriorityIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmemberpriorityisresponse","title":"BulkEthLagIntfMemberPriorityIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembertimeoutisrequest","title":"BulkEthLagIntfMemberTimeoutIsRequest","text":"Name Value Description requests repeated EthLagIntfMemberTimeoutIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembertimeoutisresponse","title":"BulkEthLagIntfMemberTimeoutIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembershipdelrequest","title":"BulkEthLagIntfMembershipDelRequest","text":"Name Value Description requests repeated EthLagIntfMembershipDelRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembershipdelresponse","title":"BulkEthLagIntfMembershipDelResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembershipsetrequest","title":"BulkEthLagIntfMembershipSetRequest","text":"Name Value Description requests repeated EthLagIntfMembershipSetRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfmembershipsetresponse","title":"BulkEthLagIntfMembershipSetResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfminlinksisrequest","title":"BulkEthLagIntfMinLinksIsRequest","text":"Name Value Description requests repeated EthLagIntfMinLinksIsRequest List of individual requests."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfminlinksisresponse","title":"BulkEthLagIntfMinLinksIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#bulkethlagintfminspeedisrequest","title":"BulkEthLagIntfMinSpeedIsRequest","text":"Name Value Description requests repeated EthLagIntfMinSpeedIsRequest List of individual requests"},{"location":"api-reference/eth_lag_intf/#bulkethlagintfminspeedisresponse","title":"BulkEthLagIntfMinSpeedIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Cause of error (if any)."},{"location":"api-reference/eth_lag_intf/#ethlagintfdelrequest","title":"EthLagIntfDelRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfdelresponse","title":"EthLagIntfDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfexistsrequest","title":"EthLagIntfExistsRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfexistsresponse","title":"EthLagIntfExistsResponse","text":"Name Value Description exists bool True if LAG interface exists."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutdefaultrequest","title":"EthLagIntfFallbackTimeoutDefaultRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutdefaultresponse","title":"EthLagIntfFallbackTimeoutDefaultResponse","text":"Name Value Description fallback_timeout uint32 Default fallback timeout, in seconds."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutisrequest","title":"EthLagIntfFallbackTimeoutIsRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface. fallback_timeout uint32 Fallback timeout, in seconds."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutisresponse","title":"EthLagIntfFallbackTimeoutIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutrequest","title":"EthLagIntfFallbackTimeoutRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktimeoutresponse","title":"EthLagIntfFallbackTimeoutResponse","text":"Name Value Description fallback_timeout uint32 LAG interface fallback timeout, in seconds."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktypeisrequest","title":"EthLagIntfFallbackTypeIsRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface. fallback_type EthLagIntfFallbackType"},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktypeisresponse","title":"EthLagIntfFallbackTypeIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktyperequest","title":"EthLagIntfFallbackTypeRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintffallbacktyperesponse","title":"EthLagIntfFallbackTypeResponse","text":"Name Value Description fallback_type EthLagIntfFallbackType LAG interface fallback type."},{"location":"api-reference/eth_lag_intf/#ethlagintffieldscontrol","title":"EthLagIntfFieldsControl","text":"Name Value Description fields repeated EthLagIntfUpdateField"},{"location":"api-reference/eth_lag_intf/#ethlagintfisrequest","title":"EthLagIntfIsRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfisresponse","title":"EthLagIntfIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberactiverequest","title":"EthLagIntfMemberActiveRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberactiveresponse","title":"EthLagIntfMemberActiveResponse","text":"Name Value Description active bool"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembermodeisrequest","title":"EthLagIntfMemberModeIsRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member. mode EthLagIntfMemberLacpMode LACP member mode for LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembermodeisresponse","title":"EthLagIntfMemberModeIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembermoderequest","title":"EthLagIntfMemberModeRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembermoderesponse","title":"EthLagIntfMemberModeResponse","text":"Name Value Description mode EthLagIntfMemberLacpMode LACP member mode for LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberpriorityisrequest","title":"EthLagIntfMemberPriorityIsRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member. priority uint32 Member priority. Valid values from 0 to 65535"},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberpriorityisresponse","title":"EthLagIntfMemberPriorityIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberpriorityrequest","title":"EthLagIntfMemberPriorityRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberpriorityresponse","title":"EthLagIntfMemberPriorityResponse","text":"Name Value Description priority uint32 Member priority."},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberreasonrequest","title":"EthLagIntfMemberReasonRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmemberreasonresponse","title":"EthLagIntfMemberReasonResponse","text":"Name Value Description member_reason string"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimerequest","title":"EthLagIntfMemberTimeRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimeresponse","title":"EthLagIntfMemberTimeResponse","text":"Name Value Description member_time double"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimeoutisrequest","title":"EthLagIntfMemberTimeoutIsRequest","text":"Name Value Description member_intf_id IntfId Interface ID for member. timeout EthLagIntfMemberLacpTimeout LACP timeout for member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimeoutisresponse","title":"EthLagIntfMemberTimeoutIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimeoutrequest","title":"EthLagIntfMemberTimeoutRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembertimeoutresponse","title":"EthLagIntfMemberTimeoutResponse","text":"Name Value Description response EthLagIntfMemberLacpTimeout"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembersrequest","title":"EthLagIntfMembersRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembersresponse","title":"EthLagIntfMembersResponse","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipdelrequest","title":"EthLagIntfMembershipDelRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipdelresponse","title":"EthLagIntfMembershipDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershiprequest","title":"EthLagIntfMembershipRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipresponse","title":"EthLagIntfMembershipResponse","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipsetrequest","title":"EthLagIntfMembershipSetRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member. eth_lag_intf_id IntfId Interface ID for the LAG interface. mode EthLagIntfMemberLacpMode LACP member mode for LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipsetresponse","title":"EthLagIntfMembershipSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipstatusrequest","title":"EthLagIntfMembershipStatusRequest","text":"Name Value Description member_intf_id IntfId Interface ID for the member."},{"location":"api-reference/eth_lag_intf/#ethlagintfmembershipstatusresponse","title":"EthLagIntfMembershipStatusResponse","text":"Name Value Description membership EthLagIntfMembership membership details."},{"location":"api-reference/eth_lag_intf/#ethlagintfminlinksisrequest","title":"EthLagIntfMinLinksIsRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface. min_links uint32 Minimum number of links that need to be up for LAG to be considered up."},{"location":"api-reference/eth_lag_intf/#ethlagintfminlinksisresponse","title":"EthLagIntfMinLinksIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfminlinksrequest","title":"EthLagIntfMinLinksRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfminlinksresponse","title":"EthLagIntfMinLinksResponse","text":"Name Value Description min_links uint32 Minimum number of links that need to be up for LAG to be considered up."},{"location":"api-reference/eth_lag_intf/#ethlagintfminspeedisrequest","title":"EthLagIntfMinSpeedIsRequest","text":"Name Value Description eth_lag_intf_id IntfId LAG interface ID (Port-Channel) min_speed uint64 Speed in Mbps"},{"location":"api-reference/eth_lag_intf/#ethlagintfminspeedisresponse","title":"EthLagIntfMinSpeedIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfminspeedrequest","title":"EthLagIntfMinSpeedRequest","text":"Name Value Description eth_lag_intf_id IntfId LAG interface ID (Port-Channel)"},{"location":"api-reference/eth_lag_intf/#ethlagintfminspeedresponse","title":"EthLagIntfMinSpeedResponse","text":"Name Value Description min_speed uint64 Speed in Mbps"},{"location":"api-reference/eth_lag_intf/#ethlagintfrequest","title":"EthLagIntfRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfresponse","title":"EthLagIntfResponse","text":"Name Value Description response EthLagIntf LAG interface parameters."},{"location":"api-reference/eth_lag_intf/#ethlagintfspeedrequest","title":"EthLagIntfSpeedRequest","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#ethlagintfspeedresponse","title":"EthLagIntfSpeedResponse","text":"Name Value Description speed uint64 Interface speed, in Mbits/s."},{"location":"api-reference/eth_lag_intf/#ethlagintfwatchrequest","title":"EthLagIntfWatchRequest","text":"Name Value Description oneof overloads.all_intfs bool Watch all LAG interfaces. oneof overloads.eth_lag_intf_id IntfId Watch a single interface. ack bool Set to true if acknowledgment is desired. dump_fields EthLagIntfFieldsControl Specification of which fields to receive on dump."},{"location":"api-reference/eth_lag_intf/#ethlagintfwatchresponse","title":"EthLagIntfWatchResponse","text":"Name Value Description event EthLagIntfEvents Descriptor of the event. eth_lag_intf_id IntfId LAG interface that changed state. member_intf_id IntfId Member interface (if event is member related) oneof speed_present.speed uint64 ack bool This message is merely an ack and not an event. oneof eth_lag_intf_present.eth_lag_intf EthLagIntf all_member_intf_id repeated IntfId"},{"location":"api-reference/eth_lag_intf/#ethlagintfsrequest","title":"EthLagIntfsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_lag_intf/#ethlagintfsresponse","title":"EthLagIntfsResponse","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface."},{"location":"api-reference/eth_lag_intf/#enums","title":"Enums","text":""},{"location":"api-reference/eth_lag_intf/#ethlagintfevents","title":"EthLagIntfEvents","text":"<p>Possible events for LAG interfaces.</p> Name Value Description ETH_LAG_INTF_EVENT_NONE 0 ETH_LAG_INTF_EVENT_CREATED 1 ETH_LAG_INTF_EVENT_DELETED 2 ETH_LAG_INTF_EVENT_MEMBER_SET 3 ETH_LAG_INTF_EVENT_MEMBER_DEL 4 ETH_LAG_INTF_EVENT_SPEED 5 ETH_LAG_INTF_MESSAGE_DUMP 6 Dump message is not an actual event and gets prefixed as MESSAGE instead."},{"location":"api-reference/eth_lag_intf/#ethlagintfupdatefield","title":"EthLagIntfUpdateField","text":"Name Value Description ETH_LAG_INTF_ALL_FIELDS 0 ETH_LAG_INTF_FULL_MEMBER_LIST 1 ETH_LAG_INTF_SPEED 2"},{"location":"api-reference/eth_lag_intf_types/","title":"eth_lag_intf_types.proto","text":""},{"location":"api-reference/eth_lag_intf_types/#messages","title":"Messages","text":""},{"location":"api-reference/eth_lag_intf_types/#ethlagintf","title":"EthLagIntf","text":"Name Value Description intf IntfId The ID of this lag interface. speed uint64 The aggregated capacity of this LAG interface, in Mbits/s. min_links uint32 Number of required links to bring up this LAG interface. fallback_type EthLagIntfFallbackType Fallback type for this LAG interface. fallback_timeout uint32 The LACP active mode timeout value, in seconds. default_fallback_timeout uint32 Default value for the timeout above, in seconds. min_speed uint64 Minimal speed in Mbps."},{"location":"api-reference/eth_lag_intf_types/#ethlagintfmembership","title":"EthLagIntfMembership","text":"Name Value Description eth_lag_intf_id IntfId Interface ID for the LAG interface. active bool Indicates whether the interface is active in the LAG. reason string If this interface is not in the LAG, the reason is stated here. member_time double Time this interface got added to or removed from a LAG. mode EthLagIntfMemberLacpMode The LACP mode this interface is configured in the LAG."},{"location":"api-reference/eth_lag_intf_types/#enums","title":"Enums","text":""},{"location":"api-reference/eth_lag_intf_types/#ethlagintffallbacktype","title":"EthLagIntfFallbackType","text":"Name Value Description ETH_LAG_INTF_FALLBACK_NULL 0 Not a valid fallback type. ETH_LAG_INTF_FALLBACK_NONE 1 No fallback if no LACPDUs seen. ETH_LAG_INTF_FALLBACK_STATIC 2 Fallback to static mode. ETH_LAG_INTF_FALLBACK_INDIVIDUAL 3 Fallback to individual mode."},{"location":"api-reference/eth_lag_intf_types/#ethlagintfmemberlacpmode","title":"EthLagIntfMemberLacpMode","text":"Name Value Description ETH_LAG_INTF_MEMBER_LACP_MODE_NULL 0 ETH_LAG_INTF_MEMBER_LACP_MODE_OFF 1 ETH_LAG_INTF_MEMBER_LACP_MODE_PASSIVE 2 ETH_LAG_INTF_MEMBER_LACP_MODE_ACTIVE 3"},{"location":"api-reference/eth_lag_intf_types/#ethlagintfmemberlacptimeout","title":"EthLagIntfMemberLacpTimeout","text":"Name Value Description ETH_LAG_INTF_MEMBER_LACP_TIMEOUT_NULL 0 ETH_LAG_INTF_MEMBER_LACP_TIMEOUT_SHORT 1 ETH_LAG_INTF_MEMBER_LACP_TIMEOUT_LONG 2"},{"location":"api-reference/eth_phy_intf/","title":"eth_phy_intf.proto","text":""},{"location":"api-reference/eth_phy_intf/#ethphyintfcountersmgrservice","title":"EthPhyIntfCountersMgrService","text":"<p>Counter service.</p>"},{"location":"api-reference/eth_phy_intf/#counters","title":"counters","text":"<p>rpc counters(EthPhyIntfCountersRequest)     EthPhyIntfCountersResponse</p> <p>Gets the current counters of the given ethernet interface.</p> <p>EOS SDK reference: eos::eth_phy_intf_counter_mgr::counters</p>"},{"location":"api-reference/eth_phy_intf/#bin_counters","title":"bin_counters","text":"<p>rpc bin_counters(EthPhyIntfBinCountersRequest)     EthPhyIntfBinCountersResponse</p> <p>Gets the current bin counters of the given ethernet interface.</p> <p>EOS SDK reference: eos::eth_phy_intf_counter_mgr::bin_counters</p>"},{"location":"api-reference/eth_phy_intf/#ethphyintfmgrservice","title":"EthPhyIntfMgrService","text":""},{"location":"api-reference/eth_phy_intf/#watch","title":"watch","text":"<p>rpc watch(EthPhyIntfWatchRequest)     EthPhyIntfWatchResponse</p> <p>Subscription to monitor interface events. This request stays active until the client cancels or the server shuts down. When all = false and no version is specified, this request has no effect.</p> <p>EOS SDK reference:: eos::eth_phy_intf_handler (class)</p>"},{"location":"api-reference/eth_phy_intf/#eth_phy_intfs","title":"eth_phy_intfs","text":"<p>rpc eth_phy_intfs(EthPhyIntfsRequest)     EthPhyIntfsResponse</p> <p>Returns the list of interfaces.</p> <p>EOS SDK reference:: eos::eth_phy_intf_mgr::eth_phy_intf_iter</p>"},{"location":"api-reference/eth_phy_intf/#exists","title":"exists","text":"<p>rpc exists(EthPhyIntfExistsRequest)     EthPhyIntfExistsResponse</p> <p>Returns whether the given physical ethernet interface exists.</p> <p>If exists returns true, then this intf_id_t can be successfully passed into every method of the eth_intf_mgr. If not, then methods of the eth_intf_mgr can throw a no_such_interface_error exception.</p> <p>The exists method of all *intf_mgr classes that manage a given interface (ie intf_mgr, eth_intf_mgr, and eth_phy_intf_mgr for physical interfaces) are all guaranteed to return the same result.</p> <p>EOS SDK reference: : eos::eth_phy_intf_mgr::exists</p>"},{"location":"api-reference/eth_phy_intf/#hardware_present","title":"hardware_present","text":"<p>rpc hardware_present(EthPhyIntfHardwarePresentRequest)     EthPhyIntfHardwarePresentResponse</p> <p>Returns whether the underlying hardware for this interface is present.</p> <p>EOS SDK reference:: eos::eth_phy_intf_mgr::hardware_present</p>"},{"location":"api-reference/eth_phy_intf/#burned_in_eth_addr","title":"burned_in_eth_addr","text":"<p>rpc burned_in_eth_addr(EthPhyIntfBurnedInEthAddrRequest)     EthPhyIntfBurnedInEthAddrResponse</p> <p>Returns the \"burned in\" address of the interface.</p> <p>EOS SDK reference:: eos::eth_phy_intf_mgr::burned_in_eth_addr</p>"},{"location":"api-reference/eth_phy_intf/#link_speed","title":"link_speed","text":"<p>rpc link_speed(EthPhyIntfLinkSpeedRequest)     EthPhyIntfLinkSpeedResponse</p> <p>Returns the operational link speed.</p> <p>EOS SDK reference:: eos::eth_phy_intf_mgr::link_speed</p>"},{"location":"api-reference/eth_phy_intf/#transceiver_present","title":"transceiver_present","text":"<p>rpc transceiver_present(EthPhyIntfTransceiverPresentRequest)     EthPhyIntfTransceiverPresentResponse</p> <p>Returns the presence of transceiver for the given interface</p> <p>EOS SDK reference:: eos::eth_phy_intf_mgr::transceiver_present</p>"},{"location":"api-reference/eth_phy_intf/#messages","title":"Messages","text":""},{"location":"api-reference/eth_phy_intf/#ethphyintfbincountersrequest","title":"EthPhyIntfBinCountersRequest","text":"Name Value Description intf_id IntfId Interface to query counters."},{"location":"api-reference/eth_phy_intf/#ethphyintfbincountersresponse","title":"EthPhyIntfBinCountersResponse","text":"Name Value Description counters EthPhyIntfBinCounters Counters for the requested interface."},{"location":"api-reference/eth_phy_intf/#ethphyintfburnedinethaddrrequest","title":"EthPhyIntfBurnedInEthAddrRequest","text":"Name Value Description intf_id IntfId Interface to be queried for."},{"location":"api-reference/eth_phy_intf/#ethphyintfburnedinethaddrresponse","title":"EthPhyIntfBurnedInEthAddrResponse","text":"Name Value Description eth_addr bytes Once hardware_present is true, burned_in_eth_addr is guaranteed to be available. Otherwise, the return is empty."},{"location":"api-reference/eth_phy_intf/#ethphyintfcountersrequest","title":"EthPhyIntfCountersRequest","text":"Name Value Description intf_id IntfId Interface to query counters."},{"location":"api-reference/eth_phy_intf/#ethphyintfcountersresponse","title":"EthPhyIntfCountersResponse","text":"Name Value Description counters EthPhyIntfCounters Counters for the requested interface."},{"location":"api-reference/eth_phy_intf/#ethphyintfexistsrequest","title":"EthPhyIntfExistsRequest","text":"Name Value Description intf_id IntfId Interface ID to be checked."},{"location":"api-reference/eth_phy_intf/#ethphyintfexistsresponse","title":"EthPhyIntfExistsResponse","text":"Name Value Description exists bool True if the interface exists."},{"location":"api-reference/eth_phy_intf/#ethphyintfhardwarepresentrequest","title":"EthPhyIntfHardwarePresentRequest","text":"Name Value Description intf_id IntfId Interface ID to be checked."},{"location":"api-reference/eth_phy_intf/#ethphyintfhardwarepresentresponse","title":"EthPhyIntfHardwarePresentResponse","text":"Name Value Description hardware_present bool True if hardware is present."},{"location":"api-reference/eth_phy_intf/#ethphyintflinkspeedrequest","title":"EthPhyIntfLinkSpeedRequest","text":"Name Value Description intf_id IntfId Interface to be queried for."},{"location":"api-reference/eth_phy_intf/#ethphyintflinkspeedresponse","title":"EthPhyIntfLinkSpeedResponse","text":"Name Value Description link_speed EthPhyIntfLinkSpeed One of the value speeds or ETH_PHY_INTF_LINK_SPEED_UNKNOWN if the hardware is not present."},{"location":"api-reference/eth_phy_intf/#ethphyintftransceiverpresentrequest","title":"EthPhyIntfTransceiverPresentRequest","text":"Name Value Description intf_id IntfId Interface to be queried for."},{"location":"api-reference/eth_phy_intf/#ethphyintftransceiverpresentresponse","title":"EthPhyIntfTransceiverPresentResponse","text":"Name Value Description transceiver_present bool True if the transceiver is present."},{"location":"api-reference/eth_phy_intf/#ethphyintfwatchrequest","title":"EthPhyIntfWatchRequest","text":"Name Value Description ack bool Set to true when instant acknowledgment is desired. oneof options.all_intfs bool Subscribes events on all interfaces. oneof options.intf_id IntfId Subscribes for events on a specified interface."},{"location":"api-reference/eth_phy_intf/#ethphyintfwatchresponse","title":"EthPhyIntfWatchResponse","text":"<p>ack = True if message is only an acknowledgment or possible combinations of events. Whenever multiple events are present in a single message, the event on_eth_phy_intf_created, if present, is always the first in the sequence and the event on_eth_intf_deleted, if present, is always the last one in the original sequence. The order of the remaining events is not relevant.</p> Name Value Description on_eth_phy_intf_create OnEthPhyIntfCreate on_eth_phy_intf_delete OnEthPhyIntfDelete on_eth_phy_intf_hardware_present OnEthPhyIntfHardwarePresent on_eth_phy_intf_link_speed OnEthPhyIntfLinkSpeed on_eth_phy_intf_transceiver_present OnEthPhyIntfTransceiverPresent ack bool Simple acknowledgment."},{"location":"api-reference/eth_phy_intf/#ethphyintfsrequest","title":"EthPhyIntfsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/eth_phy_intf/#ethphyintfsresponse","title":"EthPhyIntfsResponse","text":"Name Value Description intf_id IntfId A present interface."},{"location":"api-reference/eth_phy_intf/#onethphyintfcreate","title":"OnEthPhyIntfCreate","text":"<p>Notification when a physical ethernet interface is created.</p> <p>After on_eth_phy_intf_create is sent, the given intf_id is guaranteed to exist (ie eth_phy_intf_mgr::exists will return true). At that point, the intf_id can be used with all methods of the eth_phy_intf_mgr class.</p> <p>This also means that the intf_id can be used with all other relevant *intf_mgr classes (ie intf_mgr and eth_intf_mgr).</p> Name Value Description intf_id IntfId"},{"location":"api-reference/eth_phy_intf/#onethphyintfdelete","title":"OnEthPhyIntfDelete","text":"<p>Notification when a physical ethernet interface is deleted.</p> <p>After on_eth_phy_intf_delete is sent, the given intf_id is guaranteed to not exist (ie eth_phy_intf_mgr::exists will return false). At that point, the intf_id cannot be used with any methods in the eth_phy_intf_mgr class.</p> <p>This also means that the intf_id can no longer be used with all other relevant *intf_mgr classes (ie intf_mgr and eth_intf_mgr).</p> Name Value Description intf_id IntfId"},{"location":"api-reference/eth_phy_intf/#onethphyintfhardwarepresent","title":"OnEthPhyIntfHardwarePresent","text":"<p>Notification when the presence of the underlying hardware for the physical ethernet interface changes.</p> <p>When a physical interface goes from not-present to present, only on_eth_phy_intf_hardware_present is sent even though other attributes (like the link_speed) of the eth_phy_intf may have changed. Similarly, when the physical interface hardware goes from present to not-present, attributes of the eth_phy_intf (like the link_speed) that are based on the underlying hardware will go back to their default values even though specific events for these changes are not sent. It is up to the user to handle the new values of those attributes upon reception of on_eth_phy_intf_hardware_present handler.</p> Name Value Description intf_id IntfId hardware_present bool"},{"location":"api-reference/eth_phy_intf/#onethphyintflinkspeed","title":"OnEthPhyIntfLinkSpeed","text":"<p>Notification when the operational link speed changes.</p> Name Value Description intf_id IntfId link_speed EthPhyIntfLinkSpeed"},{"location":"api-reference/eth_phy_intf/#onethphyintftransceiverpresent","title":"OnEthPhyIntfTransceiverPresent","text":"<p>Notification when a transceiver insertion or removal is detected.</p> Name Value Description intf_id IntfId transceiver_present bool"},{"location":"api-reference/eth_phy_intf_types/","title":"eth_phy_intf_types.proto","text":""},{"location":"api-reference/eth_phy_intf_types/#messages","title":"Messages","text":""},{"location":"api-reference/eth_phy_intf_types/#ethphyintfbincounters","title":"EthPhyIntfBinCounters","text":"<p>Ethernet interface counters.</p> <p>All of these attributes have the same meanings as the corresponding objects in the Ethernetlike (RFC3635) and RMON (RFC2819) MIBs.</p> Name Value Description in_64_octet_frames uint64 Input 64 octet frame counter. in_65_to_127_octet_frames uint64 Input 65 to 127 octet frame counter. in_128_to_255_octet_frames uint64 Input 128 to 255 octet frame counter. in_256_to_511_octet_frames uint64 Input 256 to 511 octet frame counter. in_512_to_1023_octet_frames uint64 Input 512 to 1023 octet frame counter. in_1024_to_1522_octet_frames uint64 Input 1024 to 1522 octet frame counter. in_1523_to_max_octet_frames uint64 Input 1523 to max octet frame counter. out_64_octet_frames uint64 Output 64 octet frame counter. out_65_to_127_octet_frames uint64 Output 65 to 127 octet frame counter. out_128_to_255_octet_frames uint64 Output 128 to 255 octet frame counter. out_256_to_511_octet_frames uint64 Output 256 to 511 octet frame counter. out_512_to_1023_octet_frames uint64 Output 512 to 1023 octet frame counter. out_1024_to_1522_octet_frames uint64 Output 1024 to 1522 octet frame counter. out_1523_to_max_octet_frames uint64 Output 1523 to max octet frame counter."},{"location":"api-reference/eth_phy_intf_types/#ethphyintfcounters","title":"EthPhyIntfCounters","text":"<p>Ethernet interface counter.</p> <p>All of these attributes have the same meanings as the corresponding objects in the Ethernetlike (RFC3635) and RMON (RFC2819) MIBs.</p> Name Value Description single_collision_frames uint64 Etherlike-MIB singleCollisionFrames counter. multiple_collision_frames uint64 Etherlike-MIB multipleCollisionFrames counter. fcs_errors uint64 Etherlike-MIB fcsErrors counter. alignment_errors uint64 Etherlike-MIB alignmentErrors counter. deferred_transmissions uint64 Etherlike-MIB deferredTransmissions counter. late_collisions uint64 Etherlike-MIB lateCollisions counter. excessive_collisions uint64 Etherlike-MIB excessiveCollisions counter. internal_mac_transmit_errors uint64 Etherlike-MIB internalMacTransmitErrors counter. carrier_sense_errors uint64 Etherlike-MIB carrierSenseErrors counter. internal_mac_receive_errors uint64 Etherlike-MIB internalMacReceiveErrors counter. frame_too_shorts uint64 Etherlike-MIB frameTooShorts counter. frame_too_longs uint64 Etherlike-MIB frameTooLongs counter. sqe_test_errors uint64 Etherlike-MIB sqeTestErrors counter. symbol_errors uint64 Etherlike-MIB symbolErrors counter. in_unknown_opcodes uint64 Etherlike-MIB inUnknownOpcodes counter. out_pause_frames uint64 Etherlike-MIB outPauseFrames counter. in_pause_frames uint64 Etherlike-MIB inPauseFrames counter. fragments uint64 RMON-MIB fragments counter. jabbers uint64 RMON-MIB jabbers counter."},{"location":"api-reference/eth_phy_intf_types/#enums","title":"Enums","text":""},{"location":"api-reference/eth_phy_intf_types/#ethphyintflinkspeed","title":"EthPhyIntfLinkSpeed","text":"Name Value Description ETH_PHY_INTF_LINK_SPEED_UNKNOWN 0 ETH_PHY_INTF_LINK_SPEED_10MBPS 1 ETH_PHY_INTF_LINK_SPEED_100MBPS 2 ETH_PHY_INTF_LINK_SPEED_1GBPS 3 ETH_PHY_INTF_LINK_SPEED_2P5GBPS 4 ETH_PHY_INTF_LINK_SPEED_5GBPS 5 ETH_PHY_INTF_LINK_SPEED_10GBPS 6 ETH_PHY_INTF_LINK_SPEED_25GBPS 7 ETH_PHY_INTF_LINK_SPEED_40GBPS 8 ETH_PHY_INTF_LINK_SPEED_50GBPS 9 ETH_PHY_INTF_LINK_SPEED_100GBPS 10 ETH_PHY_INTF_LINK_SPEED_200GBPS 11 ETH_PHY_INTF_LINK_SPEED_400GBPS 12 ETH_PHY_INTF_LINK_SPEED_800GBPS 13 ETH_PHY_INTF_LINK_SPEED_UNEXPECTED 14 ETH_PHY_INTF_LINK_SPEED_1P6TBPS 15"},{"location":"api-reference/fib_override/","title":"fib_override.proto","text":""},{"location":"api-reference/fib_override/#fiboverrideservice","title":"FibOverrideService","text":"<p>A service for managing FIB overrides.</p> <p>The FIB contains mappings between a prefix (identifying a destination network) and its associated FEC, with the FEC containing one or more resolved Vias defining how traffic should be forwarded towards that destination network.</p> <p>The FIB override service allows these FECs and their Vias to be modified/replaced by defining a number of Via-specific overrides. Each Via override contains a unique matcher which identifies those Vias in a FEC that should be modified as specified by the override (subject to any additional qualifying criteria).</p> <p>A FEC will only be overridden when one or more of its Vias match a configured override, even if some of its other Vias have no matching override. Any unmatched Vias in the FEC will still be implicitly overridden by applying default values for the overridable properties (as mentioned below). It's important to note that FECs with no explicitly overridden Vias will remain unchanged.</p> <p>At the moment, the following Via properties can be overridden:    1. The UCMP weight associated with the Via. If not specified, the configured       default UCMP weight will be used. Note that a default UCMP weight must be       configured before configuring a Via override with an explicit UCMP weight. Note the these overridden properties will take precedence over the equivalent properties in the matched Via.</p>"},{"location":"api-reference/fib_override/#default_ucmp_weight","title":"default_ucmp_weight","text":"<p>rpc default_ucmp_weight(FibOverrideDefaultUcmpWeightRequest)     FibOverrideDefaultUcmpWeightResponse</p> <p>Returns the currently configured default UCMP weight.</p> <p>When configured, this default weight will be used for any Vias in an overridden FEC without an explicitly overridden UCMP weight.</p>"},{"location":"api-reference/fib_override/#default_ucmp_weight_set","title":"default_ucmp_weight_set","text":"<p>rpc default_ucmp_weight_set(FibOverrideDefaultUcmpWeightSetRequest)     FibOverrideDefaultUcmpWeightSetResponse</p> <p>Sets the default UCMP weight to the specified value.</p> <p>This must be configured before attempting to configure any Via overrides with an explicitly overridden UCMP weight.</p> <p>Note that modifying the default weight will cause the re-evaluation of any already overridden FECs.</p>"},{"location":"api-reference/fib_override/#via_overrides","title":"via_overrides","text":"<p>rpc via_overrides(FibOverrideViasRequest)     FibOverrideViasResponse</p> <p>Enumerates all the configured per-Via FIB overrides.</p>"},{"location":"api-reference/fib_override/#bulk_via_override_set","title":"bulk_via_override_set","text":"<p>rpc bulk_via_override_set(BulkFibOverrideViaSetRequest)     BulkFibOverrideViaSetResponse</p> <p>Set the FIB override for multiple Vias.</p>"},{"location":"api-reference/fib_override/#bulk_via_override_del","title":"bulk_via_override_del","text":"<p>rpc bulk_via_override_del(BulkFibOverrideViaDelRequest)     BulkFibOverrideViaDelResponse</p> <p>Remove the FIB override for multiple Vias.</p>"},{"location":"api-reference/fib_override/#via_override_resync_init","title":"via_override_resync_init","text":"<p>rpc via_override_resync_init(FibOverrideViaResyncInitRequest)     FibOverrideViaResyncInitResponse</p> <p>Begins the process of resyncing the configured per-Via FIB overrides to the desired state.</p> <p>Once called, the per-Via overrides can be modified in the usual way (and those modifications will be applied immediately). Once all desired modifications have been made, call via_override_resync_complete() to delete any per-Via overrides that were not added/modified during the resync.</p>"},{"location":"api-reference/fib_override/#via_override_resync_complete","title":"via_override_resync_complete","text":"<p>rpc via_override_resync_complete(FibOverrideViaResyncCompleteRequest)     FibOverrideViaResyncCompleteResponse</p> <p>Completes the process of resyncing the configured per-Via FIB overrides to the desired states.</p> <p>Any per-Via overrides that were not explicitly added/modified after calling via_override_resync_init() will now be deleted.</p> <p>A FAILED_PRECONDITION error will be returned if this is called without first calling via_override_resync_init().</p>"},{"location":"api-reference/fib_override/#messages","title":"Messages","text":""},{"location":"api-reference/fib_override/#bulkfiboverrideviadelrequest","title":"BulkFibOverrideViaDelRequest","text":"Name Value Description requests repeated FibOverrideViaDelRequest The FIB override delete requests for multiple Via matchers."},{"location":"api-reference/fib_override/#bulkfiboverrideviadelresponse","title":"BulkFibOverrideViaDelResponse","text":"Name Value Description processed uint64 The number of requests processed successfully. status RpcResponseStatus Success, or error details in the event of failure."},{"location":"api-reference/fib_override/#bulkfiboverrideviasetrequest","title":"BulkFibOverrideViaSetRequest","text":"Name Value Description requests repeated FibOverrideViaSetRequest The FIB override set requests for multiple Vias."},{"location":"api-reference/fib_override/#bulkfiboverrideviasetresponse","title":"BulkFibOverrideViaSetResponse","text":"Name Value Description processed uint64 The number of requests processed successfully. status RpcResponseStatus Success, or error details in the event of failure."},{"location":"api-reference/fib_override/#fiboverridedefaultucmpweightrequest","title":"FibOverrideDefaultUcmpWeightRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverridedefaultucmpweightresponse","title":"FibOverrideDefaultUcmpWeightResponse","text":"Name Value Description ucmp_weight uint32 The current default UCMP weight.A value of 0 indicates that no default UCMP weight is currently set."},{"location":"api-reference/fib_override/#fiboverridedefaultucmpweightsetrequest","title":"FibOverrideDefaultUcmpWeightSetRequest","text":"Name Value Description ucmp_weight uint32 The UCMP weight to use by default.An INVALID_ARGUMENT error will be returned if the specified weight is not within the range 1 to (2^24)-1 inclusive."},{"location":"api-reference/fib_override/#fiboverridedefaultucmpweightsetresponse","title":"FibOverrideDefaultUcmpWeightSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviadelrequest","title":"FibOverrideViaDelRequest","text":"Name Value Description via_matcher FibOverrideViaMatcher The Via matcher whose associated override should be removed.An INVALID_ARGUMENT error will be returned if no matcher is specified, or if any of its mandatory fields are missing/malformed."},{"location":"api-reference/fib_override/#fiboverrideviaresynccompleterequest","title":"FibOverrideViaResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviaresynccompleteresponse","title":"FibOverrideViaResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviaresyncinitrequest","title":"FibOverrideViaResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviaresyncinitresponse","title":"FibOverrideViaResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviasetrequest","title":"FibOverrideViaSetRequest","text":"Name Value Description via_override FibOverrideVia The FIB override to be set for a particular Via.An INVALID_ARGUMENT error will be returned if no override is specified, if any of its mandatory fields are missing or if any of its fields are malformed.A FAILED_PRECONDITION error will be returned if UCMP parameters are specified in the override without having first configured a default UCMP weight (using the default_ucmp_weight_set() RPC)."},{"location":"api-reference/fib_override/#fiboverrideviasrequest","title":"FibOverrideViasRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/fib_override/#fiboverrideviasresponse","title":"FibOverrideViasResponse","text":"Name Value Description via_overrides repeated FibOverrideVia The FIB override for a particular Via."},{"location":"api-reference/fib_override_types/","title":"fib_override_types.proto","text":""},{"location":"api-reference/fib_override_types/#messages","title":"Messages","text":""},{"location":"api-reference/fib_override_types/#fiboverridevia","title":"FibOverrideVia","text":"<p>A message defining the overrides that should be applied to any matching Vias.</p> Name Value Description via_matcher FibOverrideViaMatcher The matcher identifying the Via(s) the override should be applied to.A valid matcher must be present. ucmp FibOverrideViaUcmp The UCMP parameters that should be used to load-balance traffic across the matching Vias in a FEC.Valid UCMP parameters must be present."},{"location":"api-reference/fib_override_types/#fiboverrideviamatcher","title":"FibOverrideViaMatcher","text":"<p>A message defining a matcher used to identify the resolved Vias in a FEC that a particular Via override should be applied to.</p> <p>A Via override will only apply to a Via in a FEC if all the fields of the matcher are identical to the equivalent fields in the Via.</p> Name Value Description nexthop_addr bytes Match the resolved nexthop IP address in the Via.An address must be present and it must not be malformed. intf_id IntfId Match the egress interface ID in the Via.An ID must be present and it must refer to a valid interface."},{"location":"api-reference/fib_override_types/#fiboverrideviaucmp","title":"FibOverrideViaUcmp","text":"<p>A message defining the UCMP parameters that should be applied to an overridden Via.</p> <p>These parameters specify how traffic should be distributed across the Vias in any multi-path FEC that uses the overridden Via.</p> <p>These parameters will replace any existing UCMP related parameters already carried by the Via.</p> Name Value Description weight uint32 The UCMP weight to associate with the Via when it is used for forwarding.A weight must be present and must be within the range 1 to (2^24)-1 inclusive.In the context of a FEC, traffic will be forwarded based on the configured weights of the overridden Vias in that FEC. If some of the Vias in the FEC are not explicitly overridden (or have no overridden weight), the configured default weight will be used for them."},{"location":"api-reference/intf/","title":"intf.proto","text":""},{"location":"api-reference/intf/#intfcountermgrservice","title":"IntfCounterMgrService","text":""},{"location":"api-reference/intf/#intf_counters","title":"intf_counters","text":"<p>rpc intf_counters(IntfCountersRequest)     IntfCountersResponse</p> <p>Queries the given interface for the current counters.</p> <p>EosSdk reference: eos::intf_counter_mgr::counters</p>"},{"location":"api-reference/intf/#intf_traffic_rates","title":"intf_traffic_rates","text":"<p>rpc intf_traffic_rates(IntfTrafficRatesRequest)     IntfTrafficRatesResponse</p> <p>Queries the given interface for the current traffic rates.</p> <p>EosSdk reference: eos::intf_counter_mgr::traffic_rates</p>"},{"location":"api-reference/intf/#intf_traffic_rates_stream","title":"intf_traffic_rates_stream","text":"<p>rpc intf_traffic_rates_stream(IntfTrafficRatesStreamRequest)     IntfTrafficRatesStreamResponse</p> <p>Streams traffic rate updates</p>"},{"location":"api-reference/intf/#intfmgrservice","title":"IntfMgrService","text":""},{"location":"api-reference/intf/#watch","title":"watch","text":"<p>rpc watch(WatchIntfRequest)     WatchIntfResponse</p> <p>Subscription to monitor changes on interface properties or status. This request stays active until it is cancelled from client side or the server is shut down. Making this request with all = false and no intf_id has no effect.</p> <p>EosSdk reference: eos::intf_handler (class)</p>"},{"location":"api-reference/intf/#intfs","title":"intfs","text":"<p>rpc intfs(IntfsRequest)     IntfsResponse</p> <p>Enumerates the interfaces.</p> <p>EosSdk reference: eos::intf_mgr::intf_iter</p>"},{"location":"api-reference/intf/#exists","title":"exists","text":"<p>rpc exists(IntfExistsRequest)     IntfExistsResponse</p> <p>Queries whether an interface exists or not.</p> <p>EosSdk reference: eos::intf_mgr::exists</p>"},{"location":"api-reference/intf/#kernel_intf_name","title":"kernel_intf_name","text":"<p>rpc kernel_intf_name(KernelIntfNameRequest)     KernelIntfNameResponse</p> <p>Queries the kernel device for a particular interface.</p> <p>EosSdk reference: eos::intf_mgr::kernel_intf_name</p>"},{"location":"api-reference/intf/#eos_intf_name","title":"eos_intf_name","text":"<p>rpc eos_intf_name(EosIntfNameRequest)     EosIntfNameResponse</p> <p>Queries EOS interface name for a particular kernel device.</p> <p>EosSdk reference: eos::intf_mgr::eos_intf_name</p>"},{"location":"api-reference/intf/#admin_enabled","title":"admin_enabled","text":"<p>rpc admin_enabled(AdminEnabledRequest)     AdminEnabledResponse</p> <p>Queries if an interface is configured to be enabled.</p> <p>EosSdk reference: eos::intf_mgr::admin_enabled</p>"},{"location":"api-reference/intf/#admin_enabled_is","title":"admin_enabled_is","text":"<p>rpc admin_enabled_is(AdminEnabledIsRequest)     AdminEnabledIsResponse</p> <p>Changes the enabled status of an interface.</p> <p>EosSdk reference: eos::intf_mgr::admin_enabled_is</p>"},{"location":"api-reference/intf/#bulk_admin_enabled_is","title":"bulk_admin_enabled_is","text":"<p>rpc bulk_admin_enabled_is(BulkAdminEnabledIsRequest)     BulkAdminEnabledIsResponse</p> <p>Changes the enabled status of multiple interfaces.</p> <p>EosSdk reference: eos::intf_mgr::admin_enabled_is</p>"},{"location":"api-reference/intf/#description","title":"description","text":"<p>rpc description(DescriptionRequest)     DescriptionResponse</p> <p>Queries the description of an interface</p> <p>EosSdk reference: eos::intf_mgr::description</p>"},{"location":"api-reference/intf/#description_is","title":"description_is","text":"<p>rpc description_is(DescriptionIsRequest)     DescriptionIsResponse</p> <p>Changes the description of an interface</p> <p>EosSdk reference: eos::intf_mgr::description_is</p>"},{"location":"api-reference/intf/#bulk_description_is","title":"bulk_description_is","text":"<p>rpc bulk_description_is(BulkDescriptionIsRequest)     BulkDescriptionIsResponse</p> <p>Changes descriptions of multiple interfaces</p> <p>EosSdk reference: eos::intf_mgr::oper_description_is</p>"},{"location":"api-reference/intf/#oper_status","title":"oper_status","text":"<p>rpc oper_status(OperStatusRequest)     OperStatusResponse</p> <p>Queries the current operational status of the given interface.</p> <p>EosSdk reference: eos::intf_mgr::oper_status</p>"},{"location":"api-reference/intf/#messages","title":"Messages","text":""},{"location":"api-reference/intf/#adminenabledisrequest","title":"AdminEnabledIsRequest","text":"Name Value Description intf_id IntfId Name of the interface. enabled bool New enabled status for the interface."},{"location":"api-reference/intf/#adminenabledisresponse","title":"AdminEnabledIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/intf/#adminenabledrequest","title":"AdminEnabledRequest","text":"Name Value Description intf_id IntfId Linux kernel device name for the interface."},{"location":"api-reference/intf/#adminenabledresponse","title":"AdminEnabledResponse","text":"Name Value Description enabled bool True if interface is enabled, false otherwise."},{"location":"api-reference/intf/#bulkadminenabledisrequest","title":"BulkAdminEnabledIsRequest","text":"Name Value Description requests repeated AdminEnabledIsRequest Array of AdminEnabledIsRequest."},{"location":"api-reference/intf/#bulkadminenabledisresponse","title":"BulkAdminEnabledIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Error details in case of failure."},{"location":"api-reference/intf/#bulkdescriptionisrequest","title":"BulkDescriptionIsRequest","text":"Name Value Description requests repeated DescriptionIsRequest Array of DescriptionIsRequest."},{"location":"api-reference/intf/#bulkdescriptionisresponse","title":"BulkDescriptionIsResponse","text":"Name Value Description processed uint64 Number of successful requests. status RpcResponseStatus Error details in case of failure."},{"location":"api-reference/intf/#descriptionisrequest","title":"DescriptionIsRequest","text":"Name Value Description intf_id IntfId Name of the interface. description string New description for the interface."},{"location":"api-reference/intf/#descriptionisresponse","title":"DescriptionIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/intf/#descriptionrequest","title":"DescriptionRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#descriptionresponse","title":"DescriptionResponse","text":"Name Value Description description string Description currently set for the interface."},{"location":"api-reference/intf/#eosintfnamerequest","title":"EosIntfNameRequest","text":"Name Value Description name string Linux kernel device name for the interface."},{"location":"api-reference/intf/#eosintfnameresponse","title":"EosIntfNameResponse","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#intfcountersrequest","title":"IntfCountersRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#intfcountersresponse","title":"IntfCountersResponse","text":"Name Value Description counters IntfCounters The counters associated with the interface."},{"location":"api-reference/intf/#intfexistsrequest","title":"IntfExistsRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#intfexistsresponse","title":"IntfExistsResponse","text":"Name Value Description exists bool True if the interface is present, false otherwise."},{"location":"api-reference/intf/#intffieldscontrol","title":"IntfFieldsControl","text":"Name Value Description fields repeated IntfWatchedField"},{"location":"api-reference/intf/#intftrafficratesrequest","title":"IntfTrafficRatesRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#intftrafficratesresponse","title":"IntfTrafficRatesResponse","text":"Name Value Description rates IntfTrafficRates The traffic rates associated with the interface."},{"location":"api-reference/intf/#intftrafficratesstreamrequest","title":"IntfTrafficRatesStreamRequest","text":"Name Value Description ack bool Set to true when an ackowledgment is desired. intf_name_regex string Regular expression to report only interfaces with matching names. When empty, all interfaces are sent."},{"location":"api-reference/intf/#intftrafficratesstreamresponse","title":"IntfTrafficRatesStreamResponse","text":"Name Value Description ack bool If true the agent is now actively watching for events. data map IntfTrafficRatesStreamResponse.DataEntry Traffic rates data"},{"location":"api-reference/intf/#intftrafficratesstreamresponsedataentry","title":"IntfTrafficRatesStreamResponse.DataEntry","text":"Name Value Description intf_id IntfId Interface name rates IntfTrafficRates The traffic rates associated with the interface."},{"location":"api-reference/intf/#intfsrequest","title":"IntfsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/intf/#intfsresponse","title":"IntfsResponse","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#kernelintfnamerequest","title":"KernelIntfNameRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#kernelintfnameresponse","title":"KernelIntfNameResponse","text":"Name Value Description name string Linux kernel device name for the interface."},{"location":"api-reference/intf/#operstatusrequest","title":"OperStatusRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/intf/#operstatusresponse","title":"OperStatusResponse","text":"Name Value Description status OperStatuses Operational status of the interface."},{"location":"api-reference/intf/#watchintfrequest","title":"WatchIntfRequest","text":"Name Value Description oneof overloads.all_intfs bool oneof overloads.intf_id IntfId Name of a particular interface to watch. ack bool Set to true when an ackowledgment is desired. dump_fields IntfFieldsControl Controls whether a dump of the existing state is performed and what data it contains. This dump takes place when the watcher starts up. At least one IntfWatchedField must be specified in order to perform a dump."},{"location":"api-reference/intf/#watchintfresponse","title":"WatchIntfResponse","text":"<p>Events are streamed as changes happen.</p> Name Value Description intf_id IntfId Interface whose status changed. oneof event_present.event IntfEvents Interface has been added or removed. oneof oper_status_present.status OperStatuses oneof admin_enabled_present.admin_enabled bool Enabled status has been changed. oneof description_present.description string Interface's description has changed. ack bool If true, this is not an event and the fields below are invalid. It will be sent immediately if a dump is not being performed and an acknowledgement was requested. If a dump is taking place it will instead be sent at the end of the dump regardless of whether an acknowledgement was requested or not."},{"location":"api-reference/intf/#enums","title":"Enums","text":""},{"location":"api-reference/intf/#intfevents","title":"IntfEvents","text":"Name Value Description EVENT_INTF_NO_CHANGES 0 EVENT_INTF_CREATED 1 EVENT_INTF_DELETED 2"},{"location":"api-reference/intf/#intfwatchedfield","title":"IntfWatchedField","text":"Name Value Description INTF_ALL_FIELDS 0 INTF_OPER_STATUS 1 INTF_ADMIN_ENABLED 2 INTF_DESCRIPTION 3"},{"location":"api-reference/intf_types/","title":"intf_types.proto","text":""},{"location":"api-reference/intf_types/#messages","title":"Messages","text":""},{"location":"api-reference/intf_types/#intfcounters","title":"IntfCounters","text":"Name Value Description out_ucast_pkts uint64 out_multicast_pkts uint64 out_broadcast_pkts uint64 in_ucast_pkts uint64 in_multicast_pkts uint64 in_broadcast_pkts uint64 out_octets uint64 in_octets uint64 out_discards uint64 out_errors uint64 in_discards uint64 in_errors uint64 sample_time double"},{"location":"api-reference/intf_types/#intfid","title":"IntfId","text":"Name Value Description name string"},{"location":"api-reference/intf_types/#intftrafficrates","title":"IntfTrafficRates","text":"Name Value Description out_pkts_rate double in_pkts_rate double out_bits_rate double in_bits_rate double sample_time double"},{"location":"api-reference/intf_types/#enums","title":"Enums","text":""},{"location":"api-reference/intf_types/#interfacetypes","title":"InterfaceTypes","text":"Name Value Description INTF_TYPE_NULL 0 INTF_TYPE_OTHER 1 INTF_TYPE_ETH 2 INTF_TYPE_VLAN 3 INTF_TYPE_MANAGEMENT 4 INTF_TYPE_LOOPBACK 5 INTF_TYPE_LAG 6 INTF_TYPE_NULL0 7 INTF_TYPE_CPU 8 INTF_TYPE_VXLAN 9"},{"location":"api-reference/intf_types/#operstatuses","title":"OperStatuses","text":"Name Value Description INTF_OPER_STATUS_NULL 0 INTF_OPER_STATUS_UP 1 INTF_OPER_STATUS_DOWN 2"},{"location":"api-reference/ip_intf/","title":"ip_intf.proto","text":""},{"location":"api-reference/ip_intf/#ipintfmgrservice","title":"IpIntfMgrService","text":""},{"location":"api-reference/ip_intf/#watch","title":"watch","text":"<p>rpc watch(IpIntfWatchRequest)     IpIntfEvent</p> <p>Subscription to monitor changes on the IP addresses of interfaces. This request stays active until it is cancelled from client side or the server is shut down.</p> <p>EosSdk reference: eos::ip_intf_handler (class)</p>"},{"location":"api-reference/ip_intf/#exists","title":"exists","text":"<p>rpc exists(IpIntfExistsRequest)     IpIntfExistsResponse</p> <p>Queries whether the given interface exists and is able to have IP addresses.</p> <p>EosSdk reference: eos::ip_intf_mgr::exists</p>"},{"location":"api-reference/ip_intf/#ip_addrs","title":"ip_addrs","text":"<p>rpc ip_addrs(IpIntfAddrsRequest)     IpIntfAddrsResponse</p> <p>Queries all IP addresses associated with an interface.</p> <p>EosSdk reference: eos::ip_intf_mgr::ip_addrs</p>"},{"location":"api-reference/ip_intf/#ip_addrs_is","title":"ip_addrs_is","text":"<p>rpc ip_addrs_is(IpIntfAddrsIsRequest)     IpIntfAddrsIsResponse</p> <p>Sets IP addresses for an interface.</p> <p>EosSdk reference: eos::ip_intf_mgr::ip_addrs_is</p>"},{"location":"api-reference/ip_intf/#bulk_ip_addrs_is","title":"bulk_ip_addrs_is","text":"<p>rpc bulk_ip_addrs_is(BulkIpIntfAddrsIsRequest)     BulkIpIntfAddrsIsResponse</p> <p>Sets IP addresses for multiple interfaces.</p> <p>EosSdk reference: eos::ip_intf_mgr::ip_addrs_is</p>"},{"location":"api-reference/ip_intf/#ip_addr_modify","title":"ip_addr_modify","text":"<p>rpc ip_addr_modify(IpIntfAddrModifyRequest)     IpIntfAddrModifyResponse</p> <p>Adds or deletes one address to an interface.</p> <p>EosSdk references: eos::ip_intf_mgr::ip_addr_add and eos::ip_intf_mgr::ip_addr_del</p>"},{"location":"api-reference/ip_intf/#bulk_ip_addr_modify","title":"bulk_ip_addr_modify","text":"<p>rpc bulk_ip_addr_modify(BulkIpIntfAddrModifyRequest)     BulkIpIntfAddrModifyResponse</p> <p>Applies multiple IP address changes in a single call.</p> <p>EosSdk references: eos::ip_intf_mgr::ip_addr_add and eos::ip_intf_mgr::ip_addr_del</p>"},{"location":"api-reference/ip_intf/#ip_addr_merge_mode","title":"ip_addr_merge_mode","text":"<p>rpc ip_addr_merge_mode(IpIntfAddrMergeModeRequest)     IpIntfAddrMergeModeResponse</p> <p>Queries the IP address merge mode for an interface.</p> <p>EosSdk references: eos::ip_intf_mgr::ip_addr_merge_mode and eos::ip_intf_mgr::ip_addr_merge_mode_is</p>"},{"location":"api-reference/ip_intf/#ip_addr_merge_mode_is","title":"ip_addr_merge_mode_is","text":"<p>rpc ip_addr_merge_mode_is(IpIntfAddrMergeModeIsRequest)     IpIntfAddrMergeModeIsResponse</p> <p>Updates the IP address merge mode for an interface.</p> <p>EosSdk reference: eos::ip_intf_mgr::ip_addr_merge_mode_is</p>"},{"location":"api-reference/ip_intf/#bulk_ip_addr_merge_mode_is","title":"bulk_ip_addr_merge_mode_is","text":"<p>rpc bulk_ip_addr_merge_mode_is(BulkIpIntfAddrMergeModeIsRequest)     BulkIpIntfAddrMergeModeIsResponse</p> <p>Updates the IP address merge mode for multiple interfaces.</p> <p>EosSdk reference: eos::ip_intf_mgr::ip_addr_merge_mode_is</p>"},{"location":"api-reference/ip_intf/#internal_vlan_id","title":"internal_vlan_id","text":"<p>rpc internal_vlan_id(IpIntfInternalVlanIdRequest)     IpIntfInternalVlanIdResponse</p> <p>Queries the internal VLAN ID associated with an interface</p> <p>EosSdk reference: eos::ip_intf_mgr::internal_vlan_id</p>"},{"location":"api-reference/ip_intf/#messages","title":"Messages","text":""},{"location":"api-reference/ip_intf/#bulkipintfaddrmergemodeisrequest","title":"BulkIpIntfAddrMergeModeIsRequest","text":"Name Value Description requests repeated IpIntfAddrMergeModeIsRequest List of IpIntfAddrMergeModeRequest."},{"location":"api-reference/ip_intf/#bulkipintfaddrmergemodeisresponse","title":"BulkIpIntfAddrMergeModeIsResponse","text":"Name Value Description processed uint64 Number of requests processed. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_intf/#bulkipintfaddrmodifyrequest","title":"BulkIpIntfAddrModifyRequest","text":"Name Value Description requests repeated IpIntfAddrModifyRequest List of IpIntfAddrModifyRequest."},{"location":"api-reference/ip_intf/#bulkipintfaddrmodifyresponse","title":"BulkIpIntfAddrModifyResponse","text":"Name Value Description processed uint64 Number of requests processed. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_intf/#bulkipintfaddrsisrequest","title":"BulkIpIntfAddrsIsRequest","text":"Name Value Description requests repeated IpIntfAddrsIsRequest List of IpIntfAddrsRequest."},{"location":"api-reference/ip_intf/#bulkipintfaddrsisresponse","title":"BulkIpIntfAddrsIsResponse","text":"Name Value Description processed uint64 Number of requests processed. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_intf/#ipintfaddrmergemodeisrequest","title":"IpIntfAddrMergeModeIsRequest","text":"Name Value Description intf_id IntfId Name of the interface. merge_mode bool New IP address merge mode for the interface."},{"location":"api-reference/ip_intf/#ipintfaddrmergemodeisresponse","title":"IpIntfAddrMergeModeIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_intf/#ipintfaddrmergemoderequest","title":"IpIntfAddrMergeModeRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/ip_intf/#ipintfaddrmergemoderesponse","title":"IpIntfAddrMergeModeResponse","text":"Name Value Description merge_mode bool True if configuration should be merged with configuration from other agents or false if it should be replaced by those."},{"location":"api-reference/ip_intf/#ipintfaddrmodifyrequest","title":"IpIntfAddrModifyRequest","text":"Name Value Description operation IpAddrOperations IP_ADDR_OP_ADD or IP_ADDR_OP_DELETE. intf_id IntfId Name of the interface. ip_addr_mask IpAddrMask IP address with mask."},{"location":"api-reference/ip_intf/#ipintfaddrmodifyresponse","title":"IpIntfAddrModifyResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_intf/#ipintfaddrsisrequest","title":"IpIntfAddrsIsRequest","text":"Name Value Description intf_id IntfId Name of the interface. ip_addr_mask repeated IpAddrMask List of IP address with their masks."},{"location":"api-reference/ip_intf/#ipintfaddrsisresponse","title":"IpIntfAddrsIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_intf/#ipintfaddrsrequest","title":"IpIntfAddrsRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/ip_intf/#ipintfaddrsresponse","title":"IpIntfAddrsResponse","text":"Name Value Description addrs repeated IpAddrMask List of IP addresses wtih masks."},{"location":"api-reference/ip_intf/#ipintfevent","title":"IpIntfEvent","text":"Name Value Description intf_id IntfId Name of the interface. oneof ip_intf_event.addr IpAddrEvent Notifies a change in the interface's addresses. oneof ip_intf_event.vlan_id VlanId Change in the interface's VLAN ID has changed. ack bool If true, this is not an event and the fields below are invalid."},{"location":"api-reference/ip_intf/#ipintfexistsrequest","title":"IpIntfExistsRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/ip_intf/#ipintfexistsresponse","title":"IpIntfExistsResponse","text":"Name Value Description exists bool True if the interface exists, false otherwise."},{"location":"api-reference/ip_intf/#ipintfinternalvlanidrequest","title":"IpIntfInternalVlanIdRequest","text":"Name Value Description intf_id IntfId Name of the interface."},{"location":"api-reference/ip_intf/#ipintfinternalvlanidresponse","title":"IpIntfInternalVlanIdResponse","text":"Name Value Description vlan_id VlanId Internal VLAN ID associated with the interface."},{"location":"api-reference/ip_intf/#ipintfwatchrequest","title":"IpIntfWatchRequest","text":"<p>Making this request with all = false and no intf_id has no effect.</p> Name Value Description oneof overloads.all_intfs bool oneof overloads.intf_id IntfId Name of a particular interface to watch. ack bool Set to true when an ackowledgment is desired."},{"location":"api-reference/ip_intf_types/","title":"ip_intf_types.proto","text":""},{"location":"api-reference/ip_intf_types/#messages","title":"Messages","text":""},{"location":"api-reference/ip_intf_types/#ipaddrevent","title":"IpAddrEvent","text":"Name Value Description operation IpAddrOperations ip_addr_mask IpAddrMask"},{"location":"api-reference/ip_intf_types/#ipaddrmask","title":"IpAddrMask","text":"Name Value Description addr bytes mask_length uint32"},{"location":"api-reference/ip_intf_types/#vlanid","title":"VlanId","text":"Name Value Description id uint32"},{"location":"api-reference/ip_intf_types/#enums","title":"Enums","text":""},{"location":"api-reference/ip_intf_types/#ipaddroperations","title":"IpAddrOperations","text":"Name Value Description IP_ADDR_OP_NONE 0 IP_ADDR_OP_ADD 1 IP_ADDR_OP_DELETE 2"},{"location":"api-reference/ip_route/","title":"ip_route.proto","text":""},{"location":"api-reference/ip_route/#iproutemgrservice","title":"IpRouteMgrService","text":""},{"location":"api-reference/ip_route/#tag","title":"tag","text":"<p>rpc tag(TagRequest)     TagResponse</p> <p>Queries for the current tag assigned to the ip route manager.</p> <p>EosSdk reference: eos::ip_route_mgr::tag</p>"},{"location":"api-reference/ip_route/#tag_is","title":"tag_is","text":"<p>rpc tag_is(TagIsRequest)     TagIsResponse</p> <p>Sets the current tag for the ip route manager. This service will only interact with routes with the given tag.</p> <p>EosSdk reference: eos::ip_route_mgr::tag_is</p>"},{"location":"api-reference/ip_route/#resync_init","title":"resync_init","text":"<p>rpc resync_init(IpRouteResyncInitRequest)     IpRouteResyncInitResponse</p> <p>Starts the route resync process, to set the routes to a known state. The resync_complete rpc, must be called to end the resync. Please check the EosSdk reference for further details.</p> <p>EosSdk reference: eos::ip_route_mgr::resync_init</p>"},{"location":"api-reference/ip_route/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(IpRouteResyncCompleteRequest)     IpRouteResyncCompleteResponse</p> <p>Ends the current route resync process. All routes and vias not added or modified during the resync will be deleted.</p> <p>EosSdk reference: eos::ip_route_mgr::resync_complete</p>"},{"location":"api-reference/ip_route/#ip_routes","title":"ip_routes","text":"<p>rpc ip_routes(IpRoutesRequest)     IpRoutesResponse</p> <p>Enumerates all configured static routes.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_iter</p>"},{"location":"api-reference/ip_route/#ip_route_vias","title":"ip_route_vias","text":"<p>rpc ip_route_vias(IpRouteViasRequest)     IpRouteViasResponse</p> <p>Enumerates all configured vias for a given route.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_via_iter</p>"},{"location":"api-reference/ip_route/#ip_route_exists","title":"ip_route_exists","text":"<p>rpc ip_route_exists(IpRouteExistsRequest)     IpRouteExistsResponse</p> <p>Queries whether the given route is configured or not.</p> <p>EosSdk reference: eos::ip_route_mgr::exists</p>"},{"location":"api-reference/ip_route/#ip_route_via_exists","title":"ip_route_via_exists","text":"<p>rpc ip_route_via_exists(IpRouteViaExistsRequest)     IpRouteViaExistsResponse</p> <p>Queries whether the given via exists for the given route.</p> <p>EosSdk reference: eos::ip_route_mgr::exists</p>"},{"location":"api-reference/ip_route/#ip_route","title":"ip_route","text":"<p>rpc ip_route(IpRouteRequest)     IpRouteResponse</p> <p>Queries the route for the given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route</p>"},{"location":"api-reference/ip_route/#ip_route_set","title":"ip_route_set","text":"<p>rpc ip_route_set(IpRouteSetRequest)     IpRouteSetResponse</p> <p>Sets a static route.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_set</p>"},{"location":"api-reference/ip_route/#bulk_ip_route_set","title":"bulk_ip_route_set","text":"<p>rpc bulk_ip_route_set(BulkIpRouteSetRequest)     BulkIpRouteSetResponse</p> <p>Sets multiple routes at once for each given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_set</p>"},{"location":"api-reference/ip_route/#ip_route_del","title":"ip_route_del","text":"<p>rpc ip_route_del(IpRouteDelRequest)     IpRouteDelResponse</p> <p>Deletes a static route.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_del</p>"},{"location":"api-reference/ip_route/#bulk_ip_route_del","title":"bulk_ip_route_del","text":"<p>rpc bulk_ip_route_del(BulkIpRouteDelRequest)     BulkIpRouteDelResponse</p> <p>Deletes multiple static routes at once for each given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_del</p>"},{"location":"api-reference/ip_route/#ip_route_via_set","title":"ip_route_via_set","text":"<p>rpc ip_route_via_set(IpRouteViaSetRequest)     IpRouteViaSetResponse</p> <p>Sets the via for a given route key. See EosSdk reference for more information.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_via_set</p>"},{"location":"api-reference/ip_route/#bulk_ip_route_via_set","title":"bulk_ip_route_via_set","text":"<p>rpc bulk_ip_route_via_set(BulkIpRouteViaSetRequest)     BulkIpRouteViaSetResponse</p> <p>Sets multiple vias at once for each given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_via_set</p>"},{"location":"api-reference/ip_route/#ip_route_via_del","title":"ip_route_via_del","text":"<p>rpc ip_route_via_del(IpRouteViaDelRequest)     IpRouteViaDelResponse</p> <p>Deletes the via for a given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_via_delete</p>"},{"location":"api-reference/ip_route/#bulk_ip_route_via_del","title":"bulk_ip_route_via_del","text":"<p>rpc bulk_ip_route_via_del(BulkIpRouteViaDelRequest)     BulkIpRouteViaDelResponse</p> <p>Deletes multiple vias at once for each given route key.</p> <p>EosSdk reference: eos::ip_route_mgr::ip_route_via_delete</p>"},{"location":"api-reference/ip_route/#messages","title":"Messages","text":""},{"location":"api-reference/ip_route/#bulkiproutedelrequest","title":"BulkIpRouteDelRequest","text":"Name Value Description requests repeated IpRouteDelRequest Array of IpRouteDelRequest."},{"location":"api-reference/ip_route/#bulkiproutedelresponse","title":"BulkIpRouteDelResponse","text":"Name Value Description processed uint64 Number of successfully deleted routes. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_route/#bulkiproutesetrequest","title":"BulkIpRouteSetRequest","text":"Name Value Description requests repeated IpRouteSetRequest Array of IpRouteSetRequest."},{"location":"api-reference/ip_route/#bulkiproutesetresponse","title":"BulkIpRouteSetResponse","text":"Name Value Description processed uint64 Number of successfully set routes. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_route/#bulkiprouteviadelrequest","title":"BulkIpRouteViaDelRequest","text":"Name Value Description requests repeated IpRouteViaDelRequest Array of IpRouteViaDelRequest."},{"location":"api-reference/ip_route/#bulkiprouteviadelresponse","title":"BulkIpRouteViaDelResponse","text":"Name Value Description processed uint64 Number of successfully deleted vias. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_route/#bulkiprouteviasetrequest","title":"BulkIpRouteViaSetRequest","text":"Name Value Description requests repeated IpRouteViaSetRequest Array of IpRouteViaSetRequest."},{"location":"api-reference/ip_route/#bulkiprouteviasetresponse","title":"BulkIpRouteViaSetResponse","text":"Name Value Description processed uint64 Number of successfully set vias. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/ip_route/#iproutedelrequest","title":"IpRouteDelRequest","text":"Name Value Description key IpRouteKey The route to delete. vrf_name string Optional: the VRF where the route is present."},{"location":"api-reference/ip_route/#iproutedelresponse","title":"IpRouteDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteexistsrequest","title":"IpRouteExistsRequest","text":"Name Value Description key IpRouteKey The route to query. vrf_name string Optional: the VRF where the route is present."},{"location":"api-reference/ip_route/#iprouteexistsresponse","title":"IpRouteExistsResponse","text":"Name Value Description exists bool True if the route exists, otherwise False."},{"location":"api-reference/ip_route/#iprouterequest","title":"IpRouteRequest","text":"Name Value Description key IpRouteKey The route to query. vrf_name string Optional: the VRF where the route is present."},{"location":"api-reference/ip_route/#iprouteresponse","title":"IpRouteResponse","text":"Name Value Description response IpRoute If a match is found."},{"location":"api-reference/ip_route/#iprouteresynccompleterequest","title":"IpRouteResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteresynccompleteresponse","title":"IpRouteResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteresyncinitrequest","title":"IpRouteResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteresyncinitresponse","title":"IpRouteResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iproutesetrequest","title":"IpRouteSetRequest","text":"Name Value Description route IpRoute The route to set. oneof additional_arg.action IpRouteActions The type of vias to be attached. Used for more efficient route configuration. oneof additional_arg.vrf_name string The VRF where the route will be present. vias repeated IpRouteVia Optional: number of IpRouteVia messages to be created along with the route. If any of the vias fail, the route will be deleted at once and the error returned will be the reason for the via creation failure. vias_action IpRouteSetViasAction defines how vias should be replaced, when applicable."},{"location":"api-reference/ip_route/#iproutesetresponse","title":"IpRouteSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteviadelrequest","title":"IpRouteViaDelRequest","text":"Name Value Description via IpRouteVia The via to delete, including the route key. vrf_name string Optional: the VRF where the via is present."},{"location":"api-reference/ip_route/#iprouteviadelresponse","title":"IpRouteViaDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteviaexistsrequest","title":"IpRouteViaExistsRequest","text":"Name Value Description via IpRouteVia The via to query, including the route key. vrf_name string Optional: the VRF where the via is present."},{"location":"api-reference/ip_route/#iprouteviaexistsresponse","title":"IpRouteViaExistsResponse","text":"Name Value Description exists bool True if the via exists, otherwise False."},{"location":"api-reference/ip_route/#iprouteviasetrequest","title":"IpRouteViaSetRequest","text":"Name Value Description via IpRouteVia The via to set, including the route key. vrf_name string Optional: the VRF where the via should be present."},{"location":"api-reference/ip_route/#iprouteviasetresponse","title":"IpRouteViaSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#iprouteviasrequest","title":"IpRouteViasRequest","text":"Name Value Description key IpRouteKey The route to query vias for. vrf_name string Optonal: the VRF where the route is present."},{"location":"api-reference/ip_route/#iprouteviasresponse","title":"IpRouteViasResponse","text":"Name Value Description response IpRouteVia The configured via for the given route."},{"location":"api-reference/ip_route/#iproutesrequest","title":"IpRoutesRequest","text":"<p>Setting more than one field below will apply AND logic. With an exception for vrf_name, leaving filters unset disables them. In case of vrf_name, if unset, it reverts to the default VRF, in accordance with all SDK APIs. A special value \"all\" has been introduced to allow this function to return routes from all VRFs, in the same fashion as CLI commands.</p> <p>In the presence of multiple vias, a route is selected if any of the underlying vias matches the criteria.</p> Name Value Description vrf_name string Filters response by VRF Name. vtep_addr bytes Filters response by vtep address. vni uint32 Filters responses by VNI. vxlan_intf_id IntfId Filters responses by VXLAN Interface. report_vias bool If true, the stream response will also include vias for every reported path. suppress_routes bool If true, the stream response will contain only vias if <code>report_vias</code> is true, and be empty otherwise. packed_route_vias bool If true, each route and all its vias will be streamed in a single message. When this flag is set to true, 'report_vias' and 'suppress_routes' are ignored."},{"location":"api-reference/ip_route/#iproutesresponse","title":"IpRoutesResponse","text":"Name Value Description oneof item.response IpRoute The configured static route. oneof item.via IpRouteVia VIA of a configured static route. vias repeated IpRouteVia"},{"location":"api-reference/ip_route/#tagisrequest","title":"TagIsRequest","text":"Name Value Description tag uint32 The numeric value of the tag"},{"location":"api-reference/ip_route/#tagisresponse","title":"TagIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#tagrequest","title":"TagRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/ip_route/#tagresponse","title":"TagResponse","text":"Name Value Description tag uint32 The numeric value of the current tag"},{"location":"api-reference/ip_route/#enums","title":"Enums","text":""},{"location":"api-reference/ip_route/#iproutesetviasaction","title":"IpRouteSetViasAction","text":"Name Value Description IP_ROUTE_SET_VIAS_CREATE 0 Convenience method to create routes and vias in a single RPC call. This is intended for route creation but when used with an existing route key will cause it to erase all previous vias associated with that key (at the SDK level). In case of failure to add vias, the route shall be deleted. IP_ROUTE_SET_VIAS_REPLACE 1 Choosing this action with an existing route will replace vias in a make-before-break fashion within the RPC server, when possible. Vias that are common between the old set and the new set should remain untouched. If the operation fails, then the original via set is restored."},{"location":"api-reference/ip_route_types/","title":"ip_route_types.proto","text":""},{"location":"api-reference/ip_route_types/#messages","title":"Messages","text":""},{"location":"api-reference/ip_route_types/#iproute","title":"IpRoute","text":"Name Value Description key IpRouteKey tag uint32 rib_bypass bool command_tag string"},{"location":"api-reference/ip_route_types/#iproutekey","title":"IpRouteKey","text":"Name Value Description prefix Prefix oneof preference_present.preference uint32 Default value is 1."},{"location":"api-reference/ip_route_types/#iproutevia","title":"IpRouteVia","text":"Name Value Description key IpRouteKey hop_addr bytes intf_id IntfId nhg_name string oneof mpls_label_present.mpls_label uint32 Default value is 1048576 (invalid label). vni uint32 vtep_addr bytes router_mac_eth_addr bytes egress_vrf string metric uint32 vtep_sip_validation bool vxlan_intf_id IntfId weight uint32 Valid range of 1 - (2^24)-1, set to 0 if unused."},{"location":"api-reference/ip_route_types/#enums","title":"Enums","text":""},{"location":"api-reference/ip_route_types/#iprouteactions","title":"IpRouteActions","text":"Name Value Description IP_ROUTE_ACTION_NULL 0 IP_ROUTE_ACTION_FORWARD 1 IP_ROUTE_ACTION_DROP 2 IP_ROUTE_ACTION_NEXTHOP_GROUP 3"},{"location":"api-reference/ip_types/","title":"ip_types.proto","text":""},{"location":"api-reference/ip_types/#messages","title":"Messages","text":""},{"location":"api-reference/ip_types/#prefix","title":"Prefix","text":"Name Value Description ip_addr bytes length int32"},{"location":"api-reference/ip_types/#enums","title":"Enums","text":""},{"location":"api-reference/ip_types/#ipversion","title":"IpVersion","text":"Name Value Description IP_VERSION_NONE 0 IP_VERSION_4 4 IP_VERSION_6 6"},{"location":"api-reference/isis_interface/","title":"isis_interface.proto","text":""},{"location":"api-reference/isis_interface/#isisinterfacemgrservice","title":"IsisInterfaceMgrService","text":"<p>Service for retrieving IS-IS configured interface(s) along with providing a watch on all the IS-IS configured interfaces.</p> <p>This service provides the following functionality: - Watching all the interfaces and streaming the interface's configuration if any   new interface is configured with one or more IS-IS instances or existing interface    is removed from any IS-IS instance. - Fetching a specific IS-IS configured interface's configuration parameters. - Fetching all IS-IS configured interfaces associated with a specified VRF. - Fetching all IS-IS configured interfaces across all VRFs.</p>"},{"location":"api-reference/isis_interface/#watch","title":"watch","text":"<p>rpc watch(IsisInterfaceWatchRequest)     IsisInterfaceWatchResponse</p> <p>Subscription to monitor changes on IS-IS enabled interfaces. This request stays  active until the client cancels or the server shuts down. The watch will be enabled  on all the IS-IS configured interfaces.</p>"},{"location":"api-reference/isis_interface/#isis_interface","title":"isis_interface","text":"<p>rpc isis_interface(IsisInterfaceRequest)     IsisInterfaceResponse</p> <p>When intfId is specified: Returns IS-IS configured interface. When intfId is not specified or intfId is specified but hasn't been configured with IS-IS: Returns an error.</p>"},{"location":"api-reference/isis_interface/#isis_interfaces","title":"isis_interfaces","text":"<p>rpc isis_interfaces(IsisInterfacesRequest)     IsisInterfacesResponse</p> <p>When VRF is specified: Returns IS-IS configured interfaces for the given VRF. When VRF is not specified: Returns all IS-IS configured interfaces. If VRF is specified but has no IS-IS interfaces configured: Returns an empty response.</p>"},{"location":"api-reference/isis_interface/#messages","title":"Messages","text":""},{"location":"api-reference/isis_interface/#isisinterfacerequest","title":"IsisInterfaceRequest","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/isis_interface/#isisinterfaceresponse","title":"IsisInterfaceResponse","text":"Name Value Description isis_interface IsisInterface Interface that matches the criteria."},{"location":"api-reference/isis_interface/#isisinterfacewatchrequest","title":"IsisInterfaceWatchRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/isis_interface/#isisinterfacewatchresponse","title":"IsisInterfaceWatchResponse","text":"Name Value Description event IsisInterfaceEvents Descriptor of an event. isis_interface IsisInterface IS-IS interface's configuration. stream_ready bool"},{"location":"api-reference/isis_interface/#isisinterfacesrequest","title":"IsisInterfacesRequest","text":"Name Value Description vrf_name string"},{"location":"api-reference/isis_interface/#isisinterfacesresponse","title":"IsisInterfacesResponse","text":"Name Value Description isis_interface IsisInterface List of interfaces that matches the criteria."},{"location":"api-reference/isis_interface/#enums","title":"Enums","text":""},{"location":"api-reference/isis_interface/#isisinterfaceevents","title":"IsisInterfaceEvents","text":"Name Value Description ISIS_INTERFACE_EVENT_NONE 0 ISIS_INTERFACE_EVENT_SET 1 ISIS_INTERFACE_EVENT_DEL 2 ISIS_INTERFACE_MESSAGE_DUMP 3"},{"location":"api-reference/isis_interface_types/","title":"isis_interface_types.proto","text":""},{"location":"api-reference/isis_interface_types/#messages","title":"Messages","text":""},{"location":"api-reference/isis_interface_types/#isisinterface","title":"IsisInterface","text":"Name Value Description key IsisInterfaceKey Unique identity of the IS-IS configured interface. ipv4_metric uint32 Ipv4 metric value of an IS-IS configured interface. ipv6_metric uint32 Ipv6 metric value of an IS-IS configured interface. level IsisLevel Level of an IS-IS configured interface. type IsisInterfaceType Type of an IS-IS configured interface."},{"location":"api-reference/isis_interface_types/#isisinterfacekey","title":"IsisInterfaceKey","text":"Name Value Description vrf_name string VRF name of an IS-IS inteface. instances_names repeated string IS-IS instances configured on an inteface. intf_id IntfId Interface name of an IS-IS configured interface."},{"location":"api-reference/isis_interface_types/#enums","title":"Enums","text":""},{"location":"api-reference/isis_interface_types/#isisinterfacetype","title":"IsisInterfaceType","text":"Name Value Description ISIS_INTF_TYPE_NULL 0 ISIS_INTF_TYPE_LAN 1 ISIS_INTF_TYPE_P2P 2"},{"location":"api-reference/isis_interface_types/#isislevel","title":"IsisLevel","text":"Name Value Description ISIS_LEVEL_NULL 0 ISIS_LEVEL_LEVEL1 1 ISIS_LEVEL_LEVEL2 2 ISIS_LEVEL_LEVEL1_2 3"},{"location":"api-reference/macsec/","title":"macsec.proto","text":""},{"location":"api-reference/macsec/#macsecmgrservice","title":"MacsecMgrService","text":""},{"location":"api-reference/macsec/#watch","title":"watch","text":"<p>rpc watch(MacsecWatchRequest)     MacsecWatchResponse</p> <p>Register to receive notifications.</p>"},{"location":"api-reference/macsec/#exists","title":"exists","text":"<p>rpc exists(MacsecExistsRequest)     MacsecExistsResponse</p> <p>Returns whether or not a profile with the given name exists.</p>"},{"location":"api-reference/macsec/#profile","title":"profile","text":"<p>rpc profile(MacsecProfileRequest)     MacsecProfileResponse</p> <p>Returns the MACsec profile with the given name, if no profile is found, the response is empty.</p>"},{"location":"api-reference/macsec/#profile_set","title":"profile_set","text":"<p>rpc profile_set(MacsecProfileSetRequest)     MacsecProfileSetResponse</p> <p>Writes the given profile to MACsec config. If a profile with the given name already exists, it will be updated with the given fields.</p>"},{"location":"api-reference/macsec/#bulk_profile_set","title":"bulk_profile_set","text":"<p>rpc bulk_profile_set(BulkMacsecProfileSetRequest)     BulkMacsecProfileSetResponse</p> <p>Bulk version of profile_set.</p>"},{"location":"api-reference/macsec/#profile_del","title":"profile_del","text":"<p>rpc profile_del(MacsecProfileDelRequest)     MacsecProfileDelResponse</p> <p>Deletes the profile with the given name if such a profile exists.</p>"},{"location":"api-reference/macsec/#bulk_profile_del","title":"bulk_profile_del","text":"<p>rpc bulk_profile_del(BulkMacsecProfileDelRequest)     BulkMacsecProfileDelResponse</p> <p>Bulk version of profile_del.</p>"},{"location":"api-reference/macsec/#intf_profile","title":"intf_profile","text":"<p>rpc intf_profile(MacsecIntfProfileRequest)     MacsecIntfProfileResponse</p> <p>Returns the profile name of the profile attached to the interface. If there is no profile configured, return an empty message.</p>"},{"location":"api-reference/macsec/#intf_profile_is","title":"intf_profile_is","text":"<p>rpc intf_profile_is(MacsecIntfProfileIsRequest)     MacsecIntfProfileIsResponse</p> <p>Configures the given interface to use the given MACsec profile.</p>"},{"location":"api-reference/macsec/#bulk_intf_profile_is","title":"bulk_intf_profile_is","text":"<p>rpc bulk_intf_profile_is(BulkMacsecIntfProfileIsRequest)     BulkMacsecIntfProfileIsResponse</p> <p>Bulk version of intf_profile_set.</p>"},{"location":"api-reference/macsec/#macsec_capable","title":"macsec_capable","text":"<p>rpc macsec_capable(MacsecCapableRequest)     MacsecCapableResponse</p> <p>Returns whether or not an interface supports MACsec.</p>"},{"location":"api-reference/macsec/#intf_status","title":"intf_status","text":"<p>rpc intf_status(MacsecIntfStatusRequest)     MacsecIntfStatusResponse</p> <p>Returns the MACsec related status information of the given interface.</p>"},{"location":"api-reference/macsec/#intf_counters","title":"intf_counters","text":"<p>rpc intf_counters(MacsecIntfCountersRequest)     MacsecIntfCountersResponse</p> <p>Returns the current MACsec counters for the given interface.</p>"},{"location":"api-reference/macsec/#macsec_profiles","title":"macsec_profiles","text":"<p>rpc macsec_profiles(MacsecProfilesRequest)     MacsecProfilesResponse</p> <p>Returns all MACsec profile config.</p>"},{"location":"api-reference/macsec/#macsec_intf_statuses","title":"macsec_intf_statuses","text":"<p>rpc macsec_intf_statuses(MacsecIntfStatusesRequest)     MacsecIntfStatusesResponse</p> <p>Returns all MACsec intf status.</p>"},{"location":"api-reference/macsec/#messages","title":"Messages","text":""},{"location":"api-reference/macsec/#bulkmacsecintfprofileisrequest","title":"BulkMacsecIntfProfileIsRequest","text":"Name Value Description requests repeated MacsecIntfProfileIsRequest"},{"location":"api-reference/macsec/#bulkmacsecintfprofileisresponse","title":"BulkMacsecIntfProfileIsResponse","text":"Name Value Description processed uint64 status RpcResponseStatus"},{"location":"api-reference/macsec/#bulkmacsecprofiledelrequest","title":"BulkMacsecProfileDelRequest","text":"Name Value Description requests repeated MacsecProfileDelRequest"},{"location":"api-reference/macsec/#bulkmacsecprofiledelresponse","title":"BulkMacsecProfileDelResponse","text":"Name Value Description processed uint64 status RpcResponseStatus"},{"location":"api-reference/macsec/#bulkmacsecprofilesetrequest","title":"BulkMacsecProfileSetRequest","text":"Name Value Description requests repeated MacsecProfileSetRequest"},{"location":"api-reference/macsec/#bulkmacsecprofilesetresponse","title":"BulkMacsecProfileSetResponse","text":"Name Value Description processed uint64 status RpcResponseStatus"},{"location":"api-reference/macsec/#macseccapablerequest","title":"MacsecCapableRequest","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/macsec/#macseccapableresponse","title":"MacsecCapableResponse","text":"Name Value Description macsec_capable bool"},{"location":"api-reference/macsec/#macsecexistsrequest","title":"MacsecExistsRequest","text":"Name Value Description profile_name string"},{"location":"api-reference/macsec/#macsecexistsresponse","title":"MacsecExistsResponse","text":"Name Value Description exists bool"},{"location":"api-reference/macsec/#macsecintfcountersrequest","title":"MacsecIntfCountersRequest","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/macsec/#macsecintfcountersresponse","title":"MacsecIntfCountersResponse","text":"Name Value Description counters MacsecIntfCounters"},{"location":"api-reference/macsec/#macsecintfprofileisrequest","title":"MacsecIntfProfileIsRequest","text":"Name Value Description intf_id IntfId profile_name string"},{"location":"api-reference/macsec/#macsecintfprofileisresponse","title":"MacsecIntfProfileIsResponse","text":"Name Value Description response_status RpcResponseStatus"},{"location":"api-reference/macsec/#macsecintfprofilerequest","title":"MacsecIntfProfileRequest","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/macsec/#macsecintfprofileresponse","title":"MacsecIntfProfileResponse","text":"Name Value Description profile_name string"},{"location":"api-reference/macsec/#macsecintfstatusrequest","title":"MacsecIntfStatusRequest","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/macsec/#macsecintfstatusresponse","title":"MacsecIntfStatusResponse","text":"Name Value Description status MacsecIntfStatus"},{"location":"api-reference/macsec/#macsecintfstatusesrequest","title":"MacsecIntfStatusesRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/macsec/#macsecintfstatusesresponse","title":"MacsecIntfStatusesResponse","text":"Name Value Description intf_id IntfId"},{"location":"api-reference/macsec/#macsecprofiledelrequest","title":"MacsecProfileDelRequest","text":"Name Value Description profile_name string"},{"location":"api-reference/macsec/#macsecprofiledelresponse","title":"MacsecProfileDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/macsec/#macsecprofilerequest","title":"MacsecProfileRequest","text":"Name Value Description profile_name string"},{"location":"api-reference/macsec/#macsecprofileresponse","title":"MacsecProfileResponse","text":"Name Value Description profile MacsecProfile"},{"location":"api-reference/macsec/#macsecprofilesetrequest","title":"MacsecProfileSetRequest","text":"Name Value Description profile MacsecProfile"},{"location":"api-reference/macsec/#macsecprofilesetresponse","title":"MacsecProfileSetResponse","text":"Name Value Description response_status RpcResponseStatus"},{"location":"api-reference/macsec/#macsecprofilesrequest","title":"MacsecProfilesRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/macsec/#macsecprofilesresponse","title":"MacsecProfilesResponse","text":"Name Value Description name string"},{"location":"api-reference/macsec/#macsecwatchrequest","title":"MacsecWatchRequest","text":"Name Value Description oneof overloads.all_intfs bool oneof overloads.intf_id IntfId ack bool"},{"location":"api-reference/macsec/#macsecwatchresponse","title":"MacsecWatchResponse","text":"Name Value Description intf_id IntfId status MacsecIntfStatus ack bool"},{"location":"api-reference/macsec_types/","title":"macsec_types.proto","text":""},{"location":"api-reference/macsec_types/#messages","title":"Messages","text":""},{"location":"api-reference/macsec_types/#macsecintfcounters","title":"MacsecIntfCounters","text":"Name Value Description out_pkts_encrypted uint64 out_octets_encrypted uint64 in_pkts_decrypted uint64 in_octets_decrypted uint64 in_pkts_not_valid uint64"},{"location":"api-reference/macsec_types/#macsecintfstatus","title":"MacsecIntfStatus","text":"Name Value Description key_status MacsecIntfKeyStatus traffic_status MacsecIntfTrafficStatus"},{"location":"api-reference/macsec_types/#macseckey","title":"MacsecKey","text":"Name Value Description cak string ckn string encoded bool"},{"location":"api-reference/macsec_types/#macsecprofile","title":"MacsecProfile","text":"Name Value Description profile_name string primary_key MacsecKey fallback_key MacsecKey oneof key_server_priority_present.key_server_priority uint32 Default value is 16. rekey_period uint32 oneof mka_life_time_present.mka_life_time uint32 Default value is 6. oneof cipher_present.cipher MacsecCipherSuite Default value is GCM_AES_XPN_128. dot1x bool include_sci bool bypass_lldp bool The field bypass_lldp is for reading back only. Setting it has no effect. Please use lldp_bypass_level instead. lldp_bypass_level MacsecBypass oneof traffic_policy_present.traffic_policy MacsecProfileTrafficPolicy Default value is TRAFFIC_POLICY_ACTIVE_SAK. allow_unprotected bool Deprecated. Please use traffic_policy instead. Only used if traffic_policy_present is not set. oneof replay_protection_present.replay_protection bool Default value is True. replay_protection_window uint32 key_retirement_immediate bool intf_ids repeated IntfId For reading back only. Setting it has no effect."},{"location":"api-reference/macsec_types/#enums","title":"Enums","text":""},{"location":"api-reference/macsec_types/#macsecbypass","title":"MacsecBypass","text":"<p>Bypass level for a protocol.</p> Name Value Description MACSEC_BYPASS_NULL 0 MACSEC_BYPASS_AUTHORIZED 1 MACSEC_BYPASS_UNAUTHORIZED 2"},{"location":"api-reference/macsec_types/#macsecciphersuite","title":"MacsecCipherSuite","text":"<p>Cipher suites used for MACsec.</p> Name Value Description MACSEC_CIPHER_SUITE_CIPHER_NULL 0 MACSEC_CIPHER_SUITE_GCM_AES_128 1 MACSEC_CIPHER_SUITE_GCM_AES_256 2 MACSEC_CIPHER_SUITE_GCM_AES_XPN_128 3 MACSEC_CIPHER_SUITE_GCM_AES_XPN_256 4"},{"location":"api-reference/macsec_types/#macsecintfkeystatus","title":"MacsecIntfKeyStatus","text":"<p>Which key an interface is using if a profile is configured.</p> Name Value Description MACSEC_INTF_KEY_INVALID 0 MACSEC_INTF_KEY_NO_PROFILE 1 MACSEC_INTF_KEY_NONE 2 MACSEC_INTF_KEY_PRIMARY 3 MACSEC_INTF_KEY_FALLBACK 4 MACSEC_INTF_KEY_PRIMARY_CACHED 5 MACSEC_INTF_KEY_FALLBACK_CACHED 6 MACSEC_INTF_KEY_STATIC_SAK 7"},{"location":"api-reference/macsec_types/#macsecintftrafficstatus","title":"MacsecIntfTrafficStatus","text":"<p>Traffic status on an interface.</p> Name Value Description MACSEC_INTF_TRAFFIC_INVALID 0 MACSEC_INTF_TRAFFIC_PROTECTED 1 MACSEC_INTF_TRAFFIC_UNPROTECTED 2 MACSEC_INTF_TRAFFIC_BLOCKED 3"},{"location":"api-reference/macsec_types/#macsecprofiletrafficpolicy","title":"MacsecProfileTrafficPolicy","text":"<p>Traffic policy on a profile.</p> Name Value Description MACSEC_PROFILE_TRAFFIC_POLICY_NULL 0 MACSEC_PROFILE_TRAFFIC_POLICY_ACTIVE_SAK 1 MACSEC_PROFILE_TRAFFIC_POLICY_UNPROTECTED 2 MACSEC_PROFILE_TRAFFIC_POLICY_BLOCKED 3"},{"location":"api-reference/mpls_route/","title":"mpls_route.proto","text":""},{"location":"api-reference/mpls_route/#mplsroutemgrservice","title":"MplsRouteMgrService","text":""},{"location":"api-reference/mpls_route/#watch","title":"watch","text":"<p>rpc watch(MplsRouteWatchRequest)     MplsRouteWatchResponse</p> <p>Subscription to monitor changes to MPLS routes in hardware. This request stays active until the client cancels or the server shuts down.</p> <p>EosSdk reference: eos::mpls_route_handler (class)</p>"},{"location":"api-reference/mpls_route/#watch_mpls_integrated","title":"watch_mpls_integrated","text":"<p>rpc watch_mpls_integrated(MplsIntegratedAckRequest)     MplsIntegratedAckResponse</p> <p>Subscription to monitor accurate programming of MPLS routes in hardware along with the NHG it was pointing to and its programmed version. This request stays active until the client cancels or the server shuts down.</p> <p>MplsIntegratedAckResponse will be generated only for versioned MPLS routes that point to a single versioned nexthop group (NHG version could be explicitly set by the client or auto-versioned), i.e., 'version_id' field set as part of 'MplsRouteSetRequest' and 'MplsRouteVia' contains non-empty 'nexthop_group' field.</p>"},{"location":"api-reference/mpls_route/#resync_init","title":"resync_init","text":"<p>rpc resync_init(MplsRouteResyncInitRequest)     MplsRouteResyncInitResponse</p> <p>Initiate a MPLS resync proccess. Starts a blank configuration to be applied once resync_complete is called.</p> <p>EosSdk reference: eos::mpls_route_mgr::resync_init</p>"},{"location":"api-reference/mpls_route/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(MplsRouteResyncCompleteRequest)     MplsRouteResyncCompleteResponse</p> <p>Ends the current MPLS resync process. Deletes the current configuration and applies all changes since resync_init was called.</p> <p>EosSdk reference: eos::mpls_route_mgr::resync_complete</p>"},{"location":"api-reference/mpls_route/#mpls_routes","title":"mpls_routes","text":"<p>rpc mpls_routes(MplsRoutesRequest)     MplsRoutesResponse</p> <p>Returns a list of all configured MPLS routes.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_iter</p>"},{"location":"api-reference/mpls_route/#mpls_route_statuses","title":"mpls_route_statuses","text":"<p>rpc mpls_route_statuses(MplsRouteStatusesRequest)     MplsRouteStatusesResponse</p> <p>Returns a list of all MPLS routes in hardware.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_status_iter_t</p>"},{"location":"api-reference/mpls_route/#mpls_route_vias","title":"mpls_route_vias","text":"<p>rpc mpls_route_vias(MplsRouteViasRequest)     MplsRouteViasResponse</p> <p>Returns a list of configured MPLS vias for a specified route.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_iter_t</p>"},{"location":"api-reference/mpls_route/#mpls_route_via_statuses","title":"mpls_route_via_statuses","text":"<p>rpc mpls_route_via_statuses(MplsRouteViaStatusesRequest)     MplsRouteViaStatusesResponse</p> <p>Returns a list of MPLS vias in hardware for a specified MPLS route or FEC.</p> <p>The vias returned for a MPLS FEC are unbound meaning they do not have a route key.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_status_iter_t</p>"},{"location":"api-reference/mpls_route/#exists","title":"exists","text":"<p>rpc exists(MplsRouteExistsRequest)     MplsRouteExistsResponse</p> <p>Queries whether the specified route or via exists in the switch config.</p> <p>EosSdk reference: eos::mpls_route_mgr::exists</p>"},{"location":"api-reference/mpls_route/#mpls_route_set","title":"mpls_route_set","text":"<p>rpc mpls_route_set(MplsRouteSetRequest)     MplsRouteSetResponse</p> <p>Inserts or updates an MPLS static route in the switch config.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_set</p>"},{"location":"api-reference/mpls_route/#bulk_mpls_route_set","title":"bulk_mpls_route_set","text":"<p>rpc bulk_mpls_route_set(BulkMplsRouteSetRequest)     BulkMplsRouteSetResponse</p> <p>Inserts or updates multiple MPLS static routes in the switch config in a single call.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_set</p>"},{"location":"api-reference/mpls_route/#mpls_route_del","title":"mpls_route_del","text":"<p>rpc mpls_route_del(MplsRouteDelRequest)     MplsRouteDelResponse</p> <p>Removes the MPLS route and all vias matching its route key.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_del</p>"},{"location":"api-reference/mpls_route/#bulk_mpls_route_del","title":"bulk_mpls_route_del","text":"<p>rpc bulk_mpls_route_del(BulkMplsRouteDelRequest)     BulkMplsRouteDelResponse</p> <p>Removes multiple MPLS routes and all vias matching their route keys in a single call.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_del</p>"},{"location":"api-reference/mpls_route/#mpls_route_via_set","title":"mpls_route_via_set","text":"<p>rpc mpls_route_via_set(MplsRouteViaSetRequest)     MplsRouteViaSetResponse</p> <p>Add the specified via to its associated MPLS route.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set</p>"},{"location":"api-reference/mpls_route/#bulk_mpls_route_via_set","title":"bulk_mpls_route_via_set","text":"<p>rpc bulk_mpls_route_via_set(BulkMplsRouteViaSetRequest)     BulkMplsRouteViaSetResponse</p> <p>Adds multiple vias to their associated MPLS routes in a single call.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_set</p>"},{"location":"api-reference/mpls_route/#mpls_route_via_del","title":"mpls_route_via_del","text":"<p>rpc mpls_route_via_del(MplsRouteViaDelRequest)     MplsRouteViaDelResponse</p> <p>Removes the specified via from its associated MPLS route. If all vias are removed from a route it will still exist but it will have no nexthop information.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del</p>"},{"location":"api-reference/mpls_route/#bulk_mpls_route_via_del","title":"bulk_mpls_route_via_del","text":"<p>rpc bulk_mpls_route_via_del(BulkMplsRouteViaDelRequest)     BulkMplsRouteViaDelResponse</p> <p>Removes multiple vias from their associated MPLS routes in a single call. If all vias are removed from a route it will still exist but it will have no nexthop information.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_via_del</p>"},{"location":"api-reference/mpls_route/#fec_id","title":"fec_id","text":"<p>rpc fec_id(MplsRouteFecIdRequest)     MplsRouteFecIdResponse</p> <p>Returns the FEC ID corresponding to the specified MPLS route key if the route is programmed in hardware. If it is not programmed in hardware then the FEC ID will be 0 denoting that it is not set.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_fec_id</p>"},{"location":"api-reference/mpls_route/#metric","title":"metric","text":"<p>rpc metric(MplsRouteMetricRequest)     MplsRouteMetricResponse</p> <p>Returns the active metric that is being used in hardware to forward traffic for the specified MPLS route key, or 0 if the route key does not have any active vias programmed.</p> <p>EosSdk reference: eos::mpls_route_mgr::mpls_route_metric</p>"},{"location":"api-reference/mpls_route/#messages","title":"Messages","text":""},{"location":"api-reference/mpls_route/#bulkmplsroutedelrequest","title":"BulkMplsRouteDelRequest","text":"Name Value Description requests repeated MplsRouteDelRequest List of MplsRouteDelRequests."},{"location":"api-reference/mpls_route/#bulkmplsroutedelresponse","title":"BulkMplsRouteDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_route/#bulkmplsroutesetrequest","title":"BulkMplsRouteSetRequest","text":"Name Value Description requests repeated MplsRouteSetRequest List of MplsRouteSetRequests."},{"location":"api-reference/mpls_route/#bulkmplsroutesetresponse","title":"BulkMplsRouteSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_route/#bulkmplsrouteviadelrequest","title":"BulkMplsRouteViaDelRequest","text":"Name Value Description requests repeated MplsRouteViaDelRequest List of MplsRouteViaDelRequests."},{"location":"api-reference/mpls_route/#bulkmplsrouteviadelresponse","title":"BulkMplsRouteViaDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_route/#bulkmplsrouteviasetrequest","title":"BulkMplsRouteViaSetRequest","text":"Name Value Description requests repeated MplsRouteViaSetRequest List of MplsRouteViaSetRequests."},{"location":"api-reference/mpls_route/#bulkmplsrouteviasetresponse","title":"BulkMplsRouteViaSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_route/#mplsintegratedackrequest","title":"MplsIntegratedAckRequest","text":"Name Value Description dump_fields MplsIntegratedFieldsControl"},{"location":"api-reference/mpls_route/#mplsintegratedackresponse","title":"MplsIntegratedAckResponse","text":"Name Value Description stream_ready bool When this field is set to 'True' it indicates RPC server has registered for any future updates and streams them. route_version_info MplsRouteViaSetVersionInfo"},{"location":"api-reference/mpls_route/#mplsintegratedfieldscontrol","title":"MplsIntegratedFieldsControl","text":"Name Value Description fields repeated MplsIntegratedField"},{"location":"api-reference/mpls_route/#mplsroutedelrequest","title":"MplsRouteDelRequest","text":"Name Value Description route_key MplsRouteKey The route key of the route to remove."},{"location":"api-reference/mpls_route/#mplsroutedelresponse","title":"MplsRouteDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteexistsrequest","title":"MplsRouteExistsRequest","text":"Name Value Description oneof overloads.route_key MplsRouteKey The key of the route to query. oneof overloads.route_via MplsRouteVia The route via to query."},{"location":"api-reference/mpls_route/#mplsrouteexistsresponse","title":"MplsRouteExistsResponse","text":"Name Value Description exists bool True if the route or via exists in the switch config otherwise false."},{"location":"api-reference/mpls_route/#mplsroutefecidrequest","title":"MplsRouteFecIdRequest","text":"Name Value Description route_key MplsRouteKey The route key."},{"location":"api-reference/mpls_route/#mplsroutefecidresponse","title":"MplsRouteFecIdResponse","text":"Name Value Description fec_id MplsFecId The FEC ID if the route key is programmed in hardware otherwise 0."},{"location":"api-reference/mpls_route/#mplsroutefieldscontrol","title":"MplsRouteFieldsControl","text":"Name Value Description fields repeated MplsRouteWatchedField"},{"location":"api-reference/mpls_route/#mplsroutemetricrequest","title":"MplsRouteMetricRequest","text":"Name Value Description route_key MplsRouteKey The route key to query. Its metric value is not used."},{"location":"api-reference/mpls_route/#mplsroutemetricresponse","title":"MplsRouteMetricResponse","text":"Name Value Description metric uint32 The metric being used in hardware to forward traffic for the specified route key or 0 if it does not have any active vias programmed."},{"location":"api-reference/mpls_route/#mplsrouteresynccompleterequest","title":"MplsRouteResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteresynccompleteresponse","title":"MplsRouteResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteresyncinitrequest","title":"MplsRouteResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteresyncinitresponse","title":"MplsRouteResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsroutesetrequest","title":"MplsRouteSetRequest","text":"Name Value Description route MplsRoute The MPLS route to insert or update. vias repeated MplsRouteVia MPLS vias to be added to the route. vias_action MplsRouteSetViasAction action associated with vias, i.e., ADD or REPLACE. backup_vias repeated MplsRouteVia MPLS backup vias to be added to the route."},{"location":"api-reference/mpls_route/#mplsroutesetresponse","title":"MplsRouteSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsroutestatusesrequest","title":"MplsRouteStatusesRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsroutestatusesresponse","title":"MplsRouteStatusesResponse","text":"Name Value Description route_key MplsRouteKey The keys of the MPLS routes in hardware."},{"location":"api-reference/mpls_route/#mplsrouteviadelrequest","title":"MplsRouteViaDelRequest","text":"Name Value Description route_via MplsRouteVia The primary via to remove. backup_route_via MplsRouteVia The backup via to remove."},{"location":"api-reference/mpls_route/#mplsrouteviadelresponse","title":"MplsRouteViaDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteviasetrequest","title":"MplsRouteViaSetRequest","text":"Name Value Description route_via MplsRouteVia The primary via to add to the route. backup_route_via MplsRouteVia The backup via to add to the route."},{"location":"api-reference/mpls_route/#mplsrouteviasetresponse","title":"MplsRouteViaSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_route/#mplsrouteviasetversioninfo","title":"MplsRouteViaSetVersionInfo","text":"Name Value Description mpls_route_key MplsRouteKey mpls_route_version_id uint32 nexthop_group_version_info NexthopGroupVersionInfo hw_state ViaSetProgrammedHwState mpls_route_hw_programming_timestamp uint64 MPLS route hw programming timestamp in UTC. Nano seconds from the Unix epoch. via_set_hw_programming_timestamp uint64 Via Set (only NHG is supported) hw programming timestamp in UTC. Nano seconds from the Unix epoch. integrated_hw_programming_timestamp uint64 Timestamp at which MPLS route &amp; via set (only NHG is supported) are programmed in the hardware at given versions in UTC. This field's value is maximum of above fields, mpls_route_hw_programming_timestamp and via_set_hw_programming_timestamp."},{"location":"api-reference/mpls_route/#mplsrouteviastatusesrequest","title":"MplsRouteViaStatusesRequest","text":"Name Value Description oneof overloads.route_key MplsRouteKey The key of the route to query. oneof overloads.fec_id MplsFecId The ID of the fec to query."},{"location":"api-reference/mpls_route/#mplsrouteviastatusesresponse","title":"MplsRouteViaStatusesResponse","text":"Name Value Description route_via MplsRouteVia The vias in hardware for the MPLS route key or FEC."},{"location":"api-reference/mpls_route/#mplsrouteviasrequest","title":"MplsRouteViasRequest","text":"Name Value Description route_key MplsRouteKey The key of the route to query."},{"location":"api-reference/mpls_route/#mplsrouteviasresponse","title":"MplsRouteViasResponse","text":"Name Value Description route_via MplsRouteVia The vias configured for the route. backup_route_via MplsRouteVia The backup vias configured for the route."},{"location":"api-reference/mpls_route/#mplsroutewatchrequest","title":"MplsRouteWatchRequest","text":"Name Value Description ack bool Set to true if an immediate acknowledgement is desired. oneof overload.all bool True if all MPLS routes should be watched. oneof overload.route_key MplsRouteKey The route key of a particular MPLS route to watch. dump_fields MplsRouteFieldsControl"},{"location":"api-reference/mpls_route/#mplsroutewatchresponse","title":"MplsRouteWatchResponse","text":"Name Value Description ack bool If true the agent is now actively watching for events. oneof route_event.on_mpls_route_set OnMplsRouteSet The specified MPLS route has been programmed to hardware or assigned a new FEC ID. oneof route_event.on_mpls_route_del OnMplsRouteDel The specified MPLS route has been deleted from hardware. oneof fec_event.on_mpls_fec_set OnMplsFecSet The specified MPLS FEC has been created or updated in hardware. oneof fec_event.on_mpls_fec_del OnMplsFecDel The specified MPLS FEC has been removed from hardware. on_mpls_route_dump OnMplsRouteDump"},{"location":"api-reference/mpls_route/#mplsroutesrequest","title":"MplsRoutesRequest","text":"Name Value Description report_vias bool If true, the stream response will also include vias for every reported MPLS route key."},{"location":"api-reference/mpls_route/#mplsroutesresponse","title":"MplsRoutesResponse","text":"Name Value Description route MplsRoute A configured MPLS route. vias repeated MplsRouteVia VIAs of the configured route. backup_vias repeated MplsRouteVia Backup VIAs of the configured route."},{"location":"api-reference/mpls_route/#nexthopgroupversioninfo","title":"NexthopGroupVersionInfo","text":"Name Value Description name string version uint32"},{"location":"api-reference/mpls_route/#onmplsfecdel","title":"OnMplsFecDel","text":"<p>Notification for when an MPLS FEC is removed from hardware.</p> Name Value Description fec_id MplsFecId The ID of the FEC which triggered the event."},{"location":"api-reference/mpls_route/#onmplsfecset","title":"OnMplsFecSet","text":"<p>Notification for when an MPLS FEC is created or updated in hardware.</p> Name Value Description fec_id MplsFecId The ID of the FEC which triggered the event."},{"location":"api-reference/mpls_route/#onmplsroutedel","title":"OnMplsRouteDel","text":"<p>Notification for when an MPLS route is deleted from hardware.</p> Name Value Description route_key MplsRouteKey The route key of the MPLS route that triggered the event."},{"location":"api-reference/mpls_route/#onmplsroutedump","title":"OnMplsRouteDump","text":"Name Value Description route MplsRoute vias repeated MplsRouteVia backup_vias repeated MplsRouteVia"},{"location":"api-reference/mpls_route/#onmplsrouteset","title":"OnMplsRouteSet","text":"<p>Notification for when an MPLS route is to be programmed into hardware or when it is assigned a new FEC ID.</p> Name Value Description route_key MplsRouteKey The route key of the MPLS route that triggered the event. fec_id MplsFecId The ID of the MPLS route's associated FEC. version_id uint32 The version of the MPLS route, 0 means version is unset."},{"location":"api-reference/mpls_route/#enums","title":"Enums","text":""},{"location":"api-reference/mpls_route/#mplsintegratedfield","title":"MplsIntegratedField","text":"Name Value Description MPLS_INTEGRATED_ALL_FIELDS 0"},{"location":"api-reference/mpls_route/#mplsroutesetviasaction","title":"MplsRouteSetViasAction","text":"Name Value Description MPLS_ROUTE_SET_VIAS_ADD 0 Use this convenience method to create routes and vias in a single RPC call. While primarily designed for route creation, when utilized with an existing route key, any vias present within the MplsRouteSetRequest message will be appended to the existing set of vias for that route. If adding the vias results in a failure, the route shall be deleted. MPLS_ROUTE_SET_VIAS_REPLACE 1 Choosing this action with an existing route will replace vias in a make-before-break fashion within the RPC server, when possible. Vias that are common between the old set and the new set should remain untouched. If the operation fails, then the original via set is restored."},{"location":"api-reference/mpls_route/#mplsroutewatchedfield","title":"MplsRouteWatchedField","text":"Name Value Description MPLS_ROUTE_ALL_FIELDS 0 MPLS_ROUTE 1 MPLS_ROUTE_VIAS 2"},{"location":"api-reference/mpls_route_types/","title":"mpls_route_types.proto","text":""},{"location":"api-reference/mpls_route_types/#messages","title":"Messages","text":""},{"location":"api-reference/mpls_route_types/#mplsfecid","title":"MplsFecId","text":"<p>Represents a forward equivalency class (FEC) for an MPLS route. One or more routes point to a FEC. The FEC corresponds to a set of MPLS vias that are programmed into hardware.</p> <p>EosSdk reference: eos::mpls_fec_id_t</p> Name Value Description id uint64"},{"location":"api-reference/mpls_route_types/#mplsroute","title":"MplsRoute","text":"<p>An MPLS v4/v6 static route.</p> <p>EosSdk reference: eos::mpls_route_t</p> Name Value Description key MplsRouteKey oneof _version_id.version_id optional uint32 MPLS route version in range &lt;1-65535&gt;"},{"location":"api-reference/mpls_route_types/#mplsroutekey","title":"MplsRouteKey","text":"<p>An MPLS route key. Used for MPLS RIB configuration.</p> <p>EosSdk reference: eos::mpls_route_key_t</p> Name Value Description labels repeated MplsLabel metric uint32 Must be in range 0 to 255."},{"location":"api-reference/mpls_route_types/#mplsroutevia","title":"MplsRouteVia","text":"<p>An MPLS route via, defining the action to take for a specified MPLS route.</p> <p>EosSdk reference: eos::mpls_route_via_t</p> Name Value Description route_key MplsRouteKey hop bytes intf IntfId pushswap_label repeated MplsLabel label_action MplsActions ttl_mode MplsTtlMode payload_type MplsPayloadType skip_egress_acl bool nexthop_group string weight uint32 Defaults to 1 if not specified"},{"location":"api-reference/mpls_route_types/#enums","title":"Enums","text":""},{"location":"api-reference/mpls_route_types/#viasetprogrammedhwstate","title":"ViaSetProgrammedHwState","text":"<p>Programmed hardware state of the MPLS route's via set</p> Name Value Description VIA_SET_HW_UNKNOWN 0 VIA_SET_HW_DROP 1 VIA_SET_HW_PARTIALLY_PROGRAMMED 2 VIA_SET_HW_ALL_PROGRAMMED 3"},{"location":"api-reference/mpls_types/","title":"mpls_types.proto","text":""},{"location":"api-reference/mpls_types/#messages","title":"Messages","text":""},{"location":"api-reference/mpls_types/#mplslabel","title":"MplsLabel","text":"<p>An MPLS label, per RFC 3032.</p> <p>Valid labels must be in the range 0 to 1048575. The value 1048576  denotes the label is unset and therefore invalid. The default value of 0 is the explicit null label. LSRs receiving this label are expected to pop it and perform ultimate IP forwarding.</p> <p>EosSdk reference: eos::mpls_label_t</p> Name Value Description oneof label_present.label uint32 Default value is 1048576 (invalid label)."},{"location":"api-reference/mpls_types/#enums","title":"Enums","text":""},{"location":"api-reference/mpls_types/#mplsactions","title":"MplsActions","text":"<p>The action to take for an MPLS route.</p> <p>EosSdk reference: eos::mpls_action_t</p> Name Value Description MPLS_ACTION_NULL 0 MPLS_ACTION_PUSH 1 MPLS_ACTION_POP 2 MPLS_ACTION_SWAP 3 MPLS_ACTION_FORWARD 4"},{"location":"api-reference/mpls_types/#mplspayloadtype","title":"MplsPayloadType","text":"<p>The inner payload type. Used in a similar way to ethertype, as MPLS does not provide this in the packet.</p> <p>EosSdk reference: eos::mpls_payload_type_t</p> Name Value Description MPLS_PAYLOAD_TYPE_NULL 0 MPLS_PAYLOAD_TYPE_MPLS 1 MPLS_PAYLOAD_TYPE_IPV4 2 MPLS_PAYLOAD_TYPE_IPV6 3 MPLS_PAYLOAD_TYPE_GUESS 4"},{"location":"api-reference/mpls_types/#mplsttlmode","title":"MplsTtlMode","text":"<p>Whether to use the pipe or uniform TTL inheritance mode.</p> <p>EosSdk reference: eos::mpls_ttl_mode_t</p> Name Value Description MPLS_TTL_MODE_NULL 0 MPLS_TTL_MODE_PIPE 1 MPLS_TTL_MODE_UNIFORM 2"},{"location":"api-reference/mpls_vrf_label/","title":"mpls_vrf_label.proto","text":""},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelmgrservice","title":"MplsVrfLabelMgrService","text":""},{"location":"api-reference/mpls_vrf_label/#resync_init","title":"resync_init","text":"<p>rpc resync_init(MplsVrfLabelResyncInitRequest)     MplsVrfLabelResyncInitResponse</p> <p>Initiates an MPLS VRF label resync proccess.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::resync_init</p>"},{"location":"api-reference/mpls_vrf_label/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(MplsVrfLabelResyncCompleteRequest)     MplsVrfLabelResyncCompleteResponse</p> <p>Ends the current MPLS VRF label resync process.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::resync_complete</p>"},{"location":"api-reference/mpls_vrf_label/#mpls_vrf_labels","title":"mpls_vrf_labels","text":"<p>rpc mpls_vrf_labels(MplsVrfLabelsRequest)     MplsVrfLabelsResponse</p> <p>Returns a list of all the MPLS VRF labels currently configured.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label_iter</p>"},{"location":"api-reference/mpls_vrf_label/#mpls_vrf_label","title":"mpls_vrf_label","text":"<p>rpc mpls_vrf_label(MplsVrfLabelRequest)     MplsVrfLabelResponse</p> <p>Returns the current configuration of an MPLS VRF label.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label</p>"},{"location":"api-reference/mpls_vrf_label/#mpls_vrf_label_set","title":"mpls_vrf_label_set","text":"<p>rpc mpls_vrf_label_set(MplsVrfLabelSetRequest)     MplsVrfLabelSetResponse</p> <p>Inserts or updates an MPLS VRF label in the switch config.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label_set</p>"},{"location":"api-reference/mpls_vrf_label/#bulk_mpls_vrf_label_set","title":"bulk_mpls_vrf_label_set","text":"<p>rpc bulk_mpls_vrf_label_set(BulkMplsVrfLabelSetRequest)     BulkMplsVrfLabelSetResponse</p> <p>Inserts or updates multiple MPLS VRF labels in the switch config in a  single call.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label_set</p>"},{"location":"api-reference/mpls_vrf_label/#mpls_vrf_label_del","title":"mpls_vrf_label_del","text":"<p>rpc mpls_vrf_label_del(MplsVrfLabelDelRequest)     MplsVrfLabelDelResponse</p> <p>Removes the MPLS VRF label from configuration.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label_del</p>"},{"location":"api-reference/mpls_vrf_label/#bulk_mpls_vrf_label_del","title":"bulk_mpls_vrf_label_del","text":"<p>rpc bulk_mpls_vrf_label_del(BulkMplsVrfLabelDelRequest)     BulkMplsVrfLabelDelResponse</p> <p>Removes multiple MPLS VRF labels in a single call.</p> <p>EosSdk reference: eos::mpls_vrf_label_mgr::mpls_vrf_label_del</p>"},{"location":"api-reference/mpls_vrf_label/#messages","title":"Messages","text":""},{"location":"api-reference/mpls_vrf_label/#bulkmplsvrflabeldelrequest","title":"BulkMplsVrfLabelDelRequest","text":"Name Value Description requests repeated MplsVrfLabelDelRequest List of MplsVrfLabelDelRequests."},{"location":"api-reference/mpls_vrf_label/#bulkmplsvrflabeldelresponse","title":"BulkMplsVrfLabelDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_vrf_label/#bulkmplsvrflabelsetrequest","title":"BulkMplsVrfLabelSetRequest","text":"Name Value Description requests repeated MplsVrfLabelSetRequest List of MplsVrfLabelSetRequests."},{"location":"api-reference/mpls_vrf_label/#bulkmplsvrflabelsetresponse","title":"BulkMplsVrfLabelSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in the event of failure."},{"location":"api-reference/mpls_vrf_label/#mplsvrflabeldelrequest","title":"MplsVrfLabelDelRequest","text":"Name Value Description label MplsLabel The MPLS label of the MPLS VRF label to remove."},{"location":"api-reference/mpls_vrf_label/#mplsvrflabeldelresponse","title":"MplsVrfLabelDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelrequest","title":"MplsVrfLabelRequest","text":"Name Value Description label MplsLabel The MPLS label of the MPLS VRF label to search."},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelresponse","title":"MplsVrfLabelResponse","text":"Name Value Description vrf_label MplsVrfLabel Current configuration of the MPLS VRF label."},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelresynccompleterequest","title":"MplsVrfLabelResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelresynccompleteresponse","title":"MplsVrfLabelResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelresyncinitrequest","title":"MplsVrfLabelResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelresyncinitresponse","title":"MplsVrfLabelResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelsetrequest","title":"MplsVrfLabelSetRequest","text":"Name Value Description vrf_label MplsVrfLabel The MPLS VRF label to insert or update."},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelsetresponse","title":"MplsVrfLabelSetResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelsrequest","title":"MplsVrfLabelsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/mpls_vrf_label/#mplsvrflabelsresponse","title":"MplsVrfLabelsResponse","text":"Name Value Description vrf_label MplsVrfLabel The configured MPLS VRF labels."},{"location":"api-reference/mpls_vrf_label_types/","title":"mpls_vrf_label_types.proto","text":""},{"location":"api-reference/mpls_vrf_label_types/#messages","title":"Messages","text":""},{"location":"api-reference/mpls_vrf_label_types/#mplsvrflabel","title":"MplsVrfLabel","text":"Name Value Description label MplsLabel vrf_name string"},{"location":"api-reference/nexthop_group/","title":"nexthop_group.proto","text":""},{"location":"api-reference/nexthop_group/#nexthopgroupmgrservice","title":"NexthopGroupMgrService","text":""},{"location":"api-reference/nexthop_group/#watch","title":"watch","text":"<p>rpc watch(WatchNexthopGroupRequest)     WatchNexthopGroupResponse</p> <p>Subscription to monitor changes on nexthop groups. This request stays active until the client cancels or the server shuts down. When all = false and no name is specified, this request has no effect.</p> <p>EosSdk reference: eos::nexthop_group_handler (class)</p>"},{"location":"api-reference/nexthop_group/#resync_init","title":"resync_init","text":"<p>rpc resync_init(ResyncNexthopGroupInitRequest)     ResyncNexthopGroupInitResponse</p> <p>Initiates a resync process. Starts a blank configuration to be applied once resync_complete is called.</p> <p>EosSdk reference: eos::nexthop_group_mgr::resync_init</p>"},{"location":"api-reference/nexthop_group/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(ResyncNexthopGroupCompleteRequest)     ResyncNexthopGroupCompleteResponse</p> <p>Deletes current configuration and applies all changes since resync_init has been called last.</p> <p>EosSdk reference: eos::nexthop_group_mgr::resync_complete</p>"},{"location":"api-reference/nexthop_group/#nexthop_groups","title":"nexthop_groups","text":"<p>rpc nexthop_groups(NexthopGroupsRequest)     NexthopGroupsResponse</p> <p>Returns a list of all configured nexthop groups.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group_iter</p>"},{"location":"api-reference/nexthop_group/#programmed_nexthop_groups","title":"programmed_nexthop_groups","text":"<p>rpc programmed_nexthop_groups(ProgrammedNexthopGroupsRequest)     ProgrammedNexthopGroupsResponse</p> <p>Returns a list of all programmed nexthop groups.</p> <p>EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group_iter</p>"},{"location":"api-reference/nexthop_group/#nexthop_group","title":"nexthop_group","text":"<p>rpc nexthop_group(NexthopGroupRequest)     NexthopGroupResponse</p> <p>Returns the configured nexthop group specified by name, if exists.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group</p>"},{"location":"api-reference/nexthop_group/#counter","title":"counter","text":"<p>rpc counter(CounterRequest)     CounterResponse</p> <p>Returns the counter corresponding to the given nexthop group name and entry.</p> <p>EosSdk reference: eos::nexthop_group_mgr::counter</p>"},{"location":"api-reference/nexthop_group/#nhg_counters","title":"nhg_counters","text":"<p>rpc nhg_counters(NexthopGroupCountersRequest)     NexthopGroupCountersResponse</p> <p>Returns the counter corresponding to the given nexthop group name or a set of nexthop groups that have names matching the regex pattern or all nexthop groups in the system when all=true.  When all = false and no name or regex is specified, this request has no effect.  When multiple fields are set, the last set field takes precedence.</p> <p>EosSdk reference: eos::nexthop_group_handler (class)</p>"},{"location":"api-reference/nexthop_group/#exists","title":"exists","text":"<p>rpc exists(NexthopGroupExistsRequest)     NexthopGroupExistsResponse</p> <p>Queries if the nexthop group with given name exists.</p> <p>EosSdk reference: eos::nexthop_group_mgr::exists</p>"},{"location":"api-reference/nexthop_group/#active","title":"active","text":"<p>rpc active(NexthopGroupActiveRequest)     NexthopGroupActiveResponse</p> <p>Queries whether a nexthop group is active</p> <p>EosSdk reference: eos::nexthop_group_mgr::active</p>"},{"location":"api-reference/nexthop_group/#nexthop_group_set","title":"nexthop_group_set","text":"<p>rpc nexthop_group_set(NexthopGroupSetRequest)     NexthopGroupSetResponse</p> <p>Creates or updates a nexthop group and returns its version ID.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set</p>"},{"location":"api-reference/nexthop_group/#bulk_nexthop_group_set","title":"bulk_nexthop_group_set","text":"<p>rpc bulk_nexthop_group_set(BulkNexthopGroupSetRequest)     BulkNexthopGroupSetResponse</p> <p>Creates or updates multiple nexthops groups in a single call and returns their version IDs.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group_set</p>"},{"location":"api-reference/nexthop_group/#nexthop_group_del","title":"nexthop_group_del","text":"<p>rpc nexthop_group_del(NexthopGroupDelRequest)     NexthopGroupDelResponse</p> <p>Deletes a nexthop group.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del</p>"},{"location":"api-reference/nexthop_group/#bulk_nexthop_group_del","title":"bulk_nexthop_group_del","text":"<p>rpc bulk_nexthop_group_del(BulkNexthopGroupDelRequest)     BulkNexthopGroupDelResponse</p> <p>Deletes multiple nexthop groups in a single call.</p> <p>EosSdk reference: eos::nexthop_group_mgr::nexthop_group_del</p>"},{"location":"api-reference/nexthop_group/#programmed_nexthop_group","title":"programmed_nexthop_group","text":"<p>rpc programmed_nexthop_group(ProgrammedNexthopGroupRequest)     ProgrammedNexthopGroupResponse</p> <p>Queries a programmed nexthop group by name.</p> <p>EosSdk reference: eos::nexthop_group_mgr::programmed_nexthop_group</p>"},{"location":"api-reference/nexthop_group/#messages","title":"Messages","text":""},{"location":"api-reference/nexthop_group/#bulknexthopgroupdelrequest","title":"BulkNexthopGroupDelRequest","text":"Name Value Description requests repeated NexthopGroupDelRequest List of NexthopGroupDelRequest."},{"location":"api-reference/nexthop_group/#bulknexthopgroupdelresponse","title":"BulkNexthopGroupDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/nexthop_group/#bulknexthopgroupsetrequest","title":"BulkNexthopGroupSetRequest","text":"Name Value Description requests repeated NexthopGroupSetRequest List of NexthopGroupSetRequest."},{"location":"api-reference/nexthop_group/#bulknexthopgroupsetresponse","title":"BulkNexthopGroupSetResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure. responses repeated NexthopGroupSetResponse List of NexthopGroupSetResponse."},{"location":"api-reference/nexthop_group/#counterrequest","title":"CounterRequest","text":"Name Value Description name string Name of the nexthop group to search. entry uint32 Entry number (16-bit)."},{"location":"api-reference/nexthop_group/#counterresponse","title":"CounterResponse","text":"Name Value Description counter NexthopGroupCounter Counter data (empty if not found)."},{"location":"api-reference/nexthop_group/#nexthopgroupactiverequest","title":"NexthopGroupActiveRequest","text":"Name Value Description name string Name of the nexthop group."},{"location":"api-reference/nexthop_group/#nexthopgroupactiveresponse","title":"NexthopGroupActiveResponse","text":"Name Value Description active bool True if the specified group is active."},{"location":"api-reference/nexthop_group/#nexthopgroupcountersrequest","title":"NexthopGroupCountersRequest","text":"Name Value Description oneof overloads.all bool All nexthop groups. oneof overloads.name string Name of a particular nexthop group to get the counters for. oneof overloads.regex string ECMAScript regex to be pattern matched against all nexthop group names."},{"location":"api-reference/nexthop_group/#nexthopgroupcountersresponse","title":"NexthopGroupCountersResponse","text":"Name Value Description name string Name of the nexthop_group. counters repeated NexthopGroupCounter List of all nexthop groups' entry counters when all = true or when the name is given in a request that nexthop group's entries counters will be returned."},{"location":"api-reference/nexthop_group/#nexthopgroupdelrequest","title":"NexthopGroupDelRequest","text":"Name Value Description name string Name of the nexthop group to delete."},{"location":"api-reference/nexthop_group/#nexthopgroupdelresponse","title":"NexthopGroupDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#nexthopgroupexistsrequest","title":"NexthopGroupExistsRequest","text":"Name Value Description name string Name of the nexthop_group."},{"location":"api-reference/nexthop_group/#nexthopgroupexistsresponse","title":"NexthopGroupExistsResponse","text":"Name Value Description exists bool True if the nexthop group exists."},{"location":"api-reference/nexthop_group/#nexthopgroupfieldscontrol","title":"NexthopGroupFieldsControl","text":"Name Value Description fields repeated NexthopGroupWatchedField"},{"location":"api-reference/nexthop_group/#nexthopgrouprequest","title":"NexthopGroupRequest","text":"Name Value Description name string Name of the nexthop group to search."},{"location":"api-reference/nexthop_group/#nexthopgroupresponse","title":"NexthopGroupResponse","text":"Name Value Description nhg NexthopGroup Configured nexthop group (empty if not found)."},{"location":"api-reference/nexthop_group/#nexthopgroupsetrequest","title":"NexthopGroupSetRequest","text":"Name Value Description nhg NexthopGroup Details of the new group. oneof _client_version_id.client_version_id optional uint32 Must be in range 1 to 65535"},{"location":"api-reference/nexthop_group/#nexthopgroupsetresponse","title":"NexthopGroupSetResponse","text":"Name Value Description version_id uint32 The nexthop group's version ID."},{"location":"api-reference/nexthop_group/#nexthopgroupsrequest","title":"NexthopGroupsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#nexthopgroupsresponse","title":"NexthopGroupsResponse","text":"Name Value Description nhg NexthopGroup Configured nexthop group."},{"location":"api-reference/nexthop_group/#programmednexthopgrouprequest","title":"ProgrammedNexthopGroupRequest","text":"Name Value Description name string Name of the programmed nexthop group."},{"location":"api-reference/nexthop_group/#programmednexthopgroupresponse","title":"ProgrammedNexthopGroupResponse","text":"Name Value Description nhg NexthopGroup Details of the nexthop group (empty if not found)."},{"location":"api-reference/nexthop_group/#programmednexthopgroupsrequest","title":"ProgrammedNexthopGroupsRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#programmednexthopgroupsresponse","title":"ProgrammedNexthopGroupsResponse","text":"Name Value Description name string Programmed nexthop group."},{"location":"api-reference/nexthop_group/#resyncnexthopgroupcompleterequest","title":"ResyncNexthopGroupCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#resyncnexthopgroupcompleteresponse","title":"ResyncNexthopGroupCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#resyncnexthopgroupinitrequest","title":"ResyncNexthopGroupInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#resyncnexthopgroupinitresponse","title":"ResyncNexthopGroupInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/nexthop_group/#watchnexthopgrouprequest","title":"WatchNexthopGroupRequest","text":"Name Value Description oneof overloads.all bool oneof overloads.name string Name of a particular nexthop group to watch. ack bool Set to true when an ackowledgment is desired. dump_fields NexthopGroupFieldsControl"},{"location":"api-reference/nexthop_group/#watchnexthopgroupresponse","title":"WatchNexthopGroupResponse","text":"<p>Events are streamed as changes happen.</p> Name Value Description name string Interface whose status changed (ignored on confirmation). oneof active_status_present.active_status bool There was a change in the active status. oneof nhg_programmed_present.nhg_programmed bool NHG has been programmed. version_id uint32 The nexthop group's version ID if it has been programmed. Only present when event is for a programmed callback. ack bool If true, this is not an event and the fields below are invalid. nhg NexthopGroup on_nhg_programmed OnNexthopGroupProgrammed"},{"location":"api-reference/nexthop_group/#enums","title":"Enums","text":""},{"location":"api-reference/nexthop_group/#nexthopgroupwatchedfield","title":"NexthopGroupWatchedField","text":"Name Value Description NEXTHOP_GROUP_ALL 0 'NEXTHOP_GROUP_ALL' represents including all the fields in 'WatchNexthopGroupResponse' NEXTHOP_GROUP_ACTIVE 1 NEXTHOP_GROUP_PROGRAMMED 2 NEXTHOP_GROUP_VERSION_ID 3 NEXTHOP_GROUP_NHG 4 NEXTHOP_GROUP_ON_NHG_PROGRAMMED 5"},{"location":"api-reference/nexthop_group_types/","title":"nexthop_group_types.proto","text":""},{"location":"api-reference/nexthop_group_types/#messages","title":"Messages","text":""},{"location":"api-reference/nexthop_group_types/#nexthopgroup","title":"NexthopGroup","text":"Name Value Description name string type NexthopGroupEncapTypes gre_key_type NexthopGroupGreKeyTypes oneof ttl_present.ttl uint32 Default value is 64. source_ip_addr bytes source_intf IntfId autosize bool nexthops map NexthopGroup.NexthopsEntry The numeric key corresponds to the nexthop index position for the entry. destination_ips map NexthopGroup.DestinationIpsEntry counters_unshared bool hierarchical_fecs_enabled bool counters_persistent bool version_id uint32 NOTE: this is actually a 16-bit value. backup_nexthops map NexthopGroup.BackupNexthopsEntry The numeric key corresponds to the nexthop index position for the entry. backup_nexthops_policy NexthopGroupBackupNexthopsPolicy Policy indicating how backup nexthops are to be activated. By default, all backup nexthops are activated when all primary nexthops are inactive. When the policy is set to NEXTHOP_GROUP_BACKUP_NEXTHOPS_ONE_TO_ONE, then the backup entries will be activated on a per entry basis when the corresponding entry in the same index position in the primary nexthops mapping becomes inactive."},{"location":"api-reference/nexthop_group_types/#nexthopgroupbackupnexthopsentry","title":"NexthopGroup.BackupNexthopsEntry","text":"Name Value Description key uint32 value NexthopGroupEntry"},{"location":"api-reference/nexthop_group_types/#nexthopgroupdestinationipsentry","title":"NexthopGroup.DestinationIpsEntry","text":"Name Value Description key uint32 value bytes"},{"location":"api-reference/nexthop_group_types/#nexthopgroupnexthopsentry","title":"NexthopGroup.NexthopsEntry","text":"Name Value Description key uint32 value NexthopGroupEntry"},{"location":"api-reference/nexthop_group_types/#nexthopgroupcounter","title":"NexthopGroupCounter","text":"Name Value Description packets uint64 bytes uint64 valid bool entry_id uint32"},{"location":"api-reference/nexthop_group_types/#nexthopgroupentry","title":"NexthopGroupEntry","text":"Name Value Description mpls_action NexthopGroupMplsAction nexthop_ip bytes intf_id IntfId child_nexthop_group string"},{"location":"api-reference/nexthop_group_types/#nexthopgroupmplsaction","title":"NexthopGroupMplsAction","text":"Name Value Description action MplsActions mpls_labels repeated uint32"},{"location":"api-reference/nexthop_group_types/#onnexthopgroupprogrammed","title":"OnNexthopGroupProgrammed","text":"Name Value Description hw_state NexthopGroupProgrammedHwState counter_state NexthopGroupCounterState"},{"location":"api-reference/nexthop_group_types/#enums","title":"Enums","text":""},{"location":"api-reference/nexthop_group_types/#nexthopgroupbackupnexthopspolicy","title":"NexthopGroupBackupNexthopsPolicy","text":"Name Value Description NEXTHOP_GROUP_BACKUP_NEXTHOPS_ALL_TO_ALL 0 NEXTHOP_GROUP_BACKUP_NEXTHOPS_ONE_TO_ONE 1"},{"location":"api-reference/nexthop_group_types/#nexthopgroupcounterstate","title":"NexthopGroupCounterState","text":"Name Value Description NEXTHOP_GROUP_COUNTER_INACTIVE 0 Nexthop group entry counters are not enabled for this group. NEXTHOP_GROUP_COUNTER_PROGRAMMING_FAILED 1 At least one nexthop group entry counter for this group has failed to be programmed.Confirm that the expected configuration fits within the hardware limits of the system and reconfigure all nexthop groups. NEXTHOP_GROUP_COUNTER_PROGRAMMING_COMPLETE 2 All nexthop group entry counters for this group have been successfully programmed."},{"location":"api-reference/nexthop_group_types/#nexthopgroupencaptypes","title":"NexthopGroupEncapTypes","text":"Name Value Description NEXTHOP_GROUP_ENCAP_TYPE_NULL 0 NEXTHOP_GROUP_ENCAP_IP_IN_IP 1 NEXTHOP_GROUP_ENCAP_GRE 2 NEXTHOP_GROUP_ENCAP_MPLS 3 NEXTHOP_GROUP_ENCAP_MPLS_OVER_GRE 4 NEXTHOP_GROUP_ENCAP_IP 5"},{"location":"api-reference/nexthop_group_types/#nexthopgroupgrekeytypes","title":"NexthopGroupGreKeyTypes","text":"Name Value Description NEXTHOP_GROUP_GRE_KEY_NULL 0 NEXTHOP_GROUP_GRE_KEY_INGRESS_INTF 1"},{"location":"api-reference/nexthop_group_types/#nexthopgroupprogrammedhwstate","title":"NexthopGroupProgrammedHwState","text":"Name Value Description NEXTHOP_GROUP_HW_DROP 0 All nexthop group entries are not programmed in hardware. NEXTHOP_GROUP_HW_PARTIALLY_PROGRAMMED 1 At least one nexthop group entry is programmed in hardware. NEXTHOP_GROUP_HW_ALL_PROGRAMMED 2 All nexthop group entries are programmed in hardware."},{"location":"api-reference/policy_map/","title":"policy_map.proto","text":""},{"location":"api-reference/policy_map/#policymapmgrservice","title":"PolicyMapMgrService","text":""},{"location":"api-reference/policy_map/#watch","title":"watch","text":"<p>rpc watch(PolicyMapWatchRequest)     PolicyMapWatchResponse</p> <p>Subscription to monitor changes on a specified policy map. This request stays active until the client cancels or the server shuts down.</p> <p>EosSdk reference: eos::policy_map_handler (class)</p>"},{"location":"api-reference/policy_map/#resync_init","title":"resync_init","text":"<p>rpc resync_init(PolicyMapResyncInitRequest)     PolicyMapResyncInitResponse</p> <p>Initiates a policy map resync process. Starts a blank configuration to be applied once resync_complete is called.</p> <p>EosSdk reference: eos::policy_map_mgr::resync_init</p>"},{"location":"api-reference/policy_map/#resync_complete","title":"resync_complete","text":"<p>rpc resync_complete(PolicyMapResyncCompleteRequest)     PolicyMapResyncCompleteResponse</p> <p>Ends the current policy map resync process.</p> <p>EosSdk reference: eos::policy_map_mgr::resync_complete</p>"},{"location":"api-reference/policy_map/#exists","title":"exists","text":"<p>rpc exists(PolicyMapExistsRequest)     PolicyMapExistsResponse</p> <p>Queries whether the specified policy map is configured or not.</p> <p>EosSdk reference: eos::policy_map_mgr::exists</p>"},{"location":"api-reference/policy_map/#policy_map","title":"policy_map","text":"<p>rpc policy_map(PolicyMapRequest)     PolicyMapResponse</p> <p>Queries a policy map given its key.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map</p>"},{"location":"api-reference/policy_map/#policy_map_is","title":"policy_map_is","text":"<p>rpc policy_map_is(PolicyMapIsRequest)     PolicyMapIsResponse</p> <p>Creates or updates a policy map.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_is</p>"},{"location":"api-reference/policy_map/#bulk_policy_map_is","title":"bulk_policy_map_is","text":"<p>rpc bulk_policy_map_is(BulkPolicyMapIsRequest)     BulkPolicyMapIsResponse</p> <p>Creates or updates multiple policy maps in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_is</p>"},{"location":"api-reference/policy_map/#policy_map_del","title":"policy_map_del","text":"<p>rpc policy_map_del(PolicyMapDelRequest)     PolicyMapDelResponse</p> <p>Deletes a policy map.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_del</p>"},{"location":"api-reference/policy_map/#bulk_policy_map_del","title":"bulk_policy_map_del","text":"<p>rpc bulk_policy_map_del(BulkPolicyMapDelRequest)     BulkPolicyMapDelResponse</p> <p>Deletes multiple policy maps in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_del</p>"},{"location":"api-reference/policy_map/#policy_maps","title":"policy_maps","text":"<p>rpc policy_maps(PolicyMapsRequest)     PolicyMapsResponse</p> <p>Returns a list of the keys of the configured policy maps for a policy feature.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_iter</p>"},{"location":"api-reference/policy_map/#policy_map_apply","title":"policy_map_apply","text":"<p>rpc policy_map_apply(PolicyMapApplyRequest)     PolicyMapApplyResponse</p> <p>Applies or unapplies a policy map on the given interface and direction.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_apply</p>"},{"location":"api-reference/policy_map/#bulk_policy_map_apply","title":"bulk_policy_map_apply","text":"<p>rpc bulk_policy_map_apply(BulkPolicyMapApplyRequest)     BulkPolicyMapApplyResponse</p> <p>Applies or unapplies multiple policy maps on the given interfaces and directions in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_apply</p>"},{"location":"api-reference/policy_map/#policy_map_hw_statuses","title":"policy_map_hw_statuses","text":"<p>rpc policy_map_hw_statuses(PolicyMapHwStatusesRequest)     PolicyMapHwStatusesResponse</p> <p>Returns a list of the policy maps in hardware for a policy feature.</p> <p>EosSdk reference: eos::policy_map_mgr::policy_map_hw_status_iter</p>"},{"location":"api-reference/policy_map/#hw_status","title":"hw_status","text":"<p>rpc hw_status(PolicyMapHwStatusRequest)     PolicyMapHwStatusResponse</p> <p>Queries the hardware status for a specified policy map.</p> <p>EosSdk reference: eos::policy_map_mgr::hw_status</p>"},{"location":"api-reference/policy_map/#traffic_policy_exists","title":"traffic_policy_exists","text":"<p>rpc traffic_policy_exists(TrafficPolicyExistsRequest)     TrafficPolicyExistsResponse</p> <p>Queries whether the specified traffic policy is configured or not.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_exists</p>"},{"location":"api-reference/policy_map/#traffic_policy","title":"traffic_policy","text":"<p>rpc traffic_policy(TrafficPolicyRequest)     TrafficPolicyResponse</p> <p>Queries a traffic policy given its key.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy</p>"},{"location":"api-reference/policy_map/#traffic_policy_is","title":"traffic_policy_is","text":"<p>rpc traffic_policy_is(TrafficPolicyIsRequest)     TrafficPolicyIsResponse</p> <p>Creates or updates a traffic policy.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_is</p>"},{"location":"api-reference/policy_map/#bulk_traffic_policy_is","title":"bulk_traffic_policy_is","text":"<p>rpc bulk_traffic_policy_is(BulkTrafficPolicyIsRequest)     BulkTrafficPolicyIsResponse</p> <p>Creates or updates multiple traffic policies in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_is</p>"},{"location":"api-reference/policy_map/#traffic_policy_del","title":"traffic_policy_del","text":"<p>rpc traffic_policy_del(TrafficPolicyDelRequest)     TrafficPolicyDelResponse</p> <p>Deletes a traffic policy.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_del</p>"},{"location":"api-reference/policy_map/#bulk_traffic_policy_del","title":"bulk_traffic_policy_del","text":"<p>rpc bulk_traffic_policy_del(BulkTrafficPolicyDelRequest)     BulkTrafficPolicyDelResponse</p> <p>Deletes multiple traffic policies in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_del</p>"},{"location":"api-reference/policy_map/#traffic_policies","title":"traffic_policies","text":"<p>rpc traffic_policies(TrafficPoliciesRequest)     TrafficPoliciesResponse</p> <p>Returns a list of the keys of the configured traffic policies.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_iter</p>"},{"location":"api-reference/policy_map/#traffic_policy_apply","title":"traffic_policy_apply","text":"<p>rpc traffic_policy_apply(TrafficPolicyApplyRequest)     TrafficPolicyApplyResponse</p> <p>Applies or unapplies a traffic policy on the given interface and direction.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_apply</p>"},{"location":"api-reference/policy_map/#bulk_traffic_policy_apply","title":"bulk_traffic_policy_apply","text":"<p>rpc bulk_traffic_policy_apply(BulkTrafficPolicyApplyRequest)     BulkTrafficPolicyApplyResponse</p> <p>Applies or unapplies multiple traffic policies on the given interfaces and directions in a single call.</p> <p>EosSdk reference: eos::policy_map_mgr::traffic_policy_apply</p>"},{"location":"api-reference/policy_map/#messages","title":"Messages","text":""},{"location":"api-reference/policy_map/#bulkpolicymapapplyrequest","title":"BulkPolicyMapApplyRequest","text":"Name Value Description requests repeated PolicyMapApplyRequest List of PolicyMapApplyRequests."},{"location":"api-reference/policy_map/#bulkpolicymapapplyresponse","title":"BulkPolicyMapApplyResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#bulkpolicymapdelrequest","title":"BulkPolicyMapDelRequest","text":"Name Value Description requests repeated PolicyMapDelRequest List of PolicyMapDelRequests."},{"location":"api-reference/policy_map/#bulkpolicymapdelresponse","title":"BulkPolicyMapDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#bulkpolicymapisrequest","title":"BulkPolicyMapIsRequest","text":"Name Value Description requests repeated PolicyMapIsRequest List of PolicyMapIsRequests."},{"location":"api-reference/policy_map/#bulkpolicymapisresponse","title":"BulkPolicyMapIsResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#bulktrafficpolicyapplyrequest","title":"BulkTrafficPolicyApplyRequest","text":"Name Value Description requests repeated TrafficPolicyApplyRequest List of TrafficPolicyApplyRequests."},{"location":"api-reference/policy_map/#bulktrafficpolicyapplyresponse","title":"BulkTrafficPolicyApplyResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#bulktrafficpolicydelrequest","title":"BulkTrafficPolicyDelRequest","text":"Name Value Description requests repeated TrafficPolicyDelRequest List of TrafficPolicyDelRequests."},{"location":"api-reference/policy_map/#bulktrafficpolicydelresponse","title":"BulkTrafficPolicyDelResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#bulktrafficpolicyisrequest","title":"BulkTrafficPolicyIsRequest","text":"Name Value Description requests repeated TrafficPolicyIsRequest List of TrafficPolicyIsRequests."},{"location":"api-reference/policy_map/#bulktrafficpolicyisresponse","title":"BulkTrafficPolicyIsResponse","text":"Name Value Description processed uint64 Number of consecutive successful requests. status RpcResponseStatus Success or error details in case of failure."},{"location":"api-reference/policy_map/#policymapapplyrequest","title":"PolicyMapApplyRequest","text":"<p>Note: When unapplying a PBR policy map, the specified interface's policy map will be unapplied regardless of whether it matches the specified policy map name.</p> Name Value Description key PolicyMapKey The key of the policy map to [un]apply. intf_id IntfId The inteface ID of the interface to [un]apply the policy map. direction AclDirection The direction in which to [un]apply the policy map. apply bool True if the policy map should be applied otherwise false if it should be unapplied."},{"location":"api-reference/policy_map/#policymapapplyresponse","title":"PolicyMapApplyResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapdelrequest","title":"PolicyMapDelRequest","text":"Name Value Description key PolicyMapKey The key of the policy map to delete."},{"location":"api-reference/policy_map/#policymapdelresponse","title":"PolicyMapDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapexistsrequest","title":"PolicyMapExistsRequest","text":"Name Value Description key PolicyMapKey The key of the policy map to query."},{"location":"api-reference/policy_map/#policymapexistsresponse","title":"PolicyMapExistsResponse","text":"Name Value Description exists bool True if the policy map is configured otherwise false."},{"location":"api-reference/policy_map/#policymaphwstatusrequest","title":"PolicyMapHwStatusRequest","text":"Name Value Description key PolicyMapKey The key of the policy map to get the hardware status for."},{"location":"api-reference/policy_map/#policymaphwstatusresponse","title":"PolicyMapHwStatusResponse","text":"Name Value Description hw_statuses PolicyMapHwStatuses The hardware status of the policy map."},{"location":"api-reference/policy_map/#policymaphwstatusesrequest","title":"PolicyMapHwStatusesRequest","text":"Name Value Description feature PolicyFeature The policy feature."},{"location":"api-reference/policy_map/#policymaphwstatusesresponse","title":"PolicyMapHwStatusesResponse","text":"Name Value Description key PolicyMapKey The keys of the policy maps for the feature."},{"location":"api-reference/policy_map/#policymapisrequest","title":"PolicyMapIsRequest","text":"Name Value Description policy_map PolicyMap The policy map to create or update."},{"location":"api-reference/policy_map/#policymapisresponse","title":"PolicyMapIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymaprequest","title":"PolicyMapRequest","text":"Name Value Description key PolicyMapKey The key of the policy map to query."},{"location":"api-reference/policy_map/#policymapresponse","title":"PolicyMapResponse","text":"Name Value Description policy_map PolicyMap The policy map corresponding to the key or empty if not found."},{"location":"api-reference/policy_map/#policymapresynccompleterequest","title":"PolicyMapResyncCompleteRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapresynccompleteresponse","title":"PolicyMapResyncCompleteResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapresyncinitrequest","title":"PolicyMapResyncInitRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapresyncinitresponse","title":"PolicyMapResyncInitResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#policymapwatchrequest","title":"PolicyMapWatchRequest","text":"Name Value Description oneof overloads.all bool True if all policy maps should be watched. oneof overloads.key PolicyMapKey The key of the policy map to recieve notifications for. ack bool Set to true if an immediate acknowledgment is desired."},{"location":"api-reference/policy_map/#policymapwatchresponse","title":"PolicyMapWatchResponse","text":"Name Value Description key PolicyMapKey The key of the policy map that triggered the event. oneof policy_map_event.event_type PolicyMapEventType The type of event. oneof policy_map_event.sync_fail_message string Provides details when policy map commit or apply operation fails. ack bool If true, this is not an event and the fields below are invalid."},{"location":"api-reference/policy_map/#policymapsrequest","title":"PolicyMapsRequest","text":"Name Value Description feature PolicyFeature The policy feature."},{"location":"api-reference/policy_map/#policymapsresponse","title":"PolicyMapsResponse","text":"Name Value Description key PolicyMapKey The key of the feature's configured policy maps."},{"location":"api-reference/policy_map/#trafficpoliciesrequest","title":"TrafficPoliciesRequest","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#trafficpoliciesresponse","title":"TrafficPoliciesResponse","text":"Name Value Description key PolicyMapKey The key of one of the feature's configured policy maps."},{"location":"api-reference/policy_map/#trafficpolicyapplyrequest","title":"TrafficPolicyApplyRequest","text":"Name Value Description key string The key of the traffic policy to [un]apply. intf_id IntfId The inteface ID of the interface to [un]apply the policy map. direction TrafficPolicyDirection The direction in which to [un]apply the traffic policy. apply bool True if the traffic policy should be applied otherwise false if it should be unapplied."},{"location":"api-reference/policy_map/#trafficpolicyapplyresponse","title":"TrafficPolicyApplyResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#trafficpolicydelrequest","title":"TrafficPolicyDelRequest","text":"Name Value Description key string The key of the traffic policy to delete."},{"location":"api-reference/policy_map/#trafficpolicydelresponse","title":"TrafficPolicyDelResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#trafficpolicyexistsrequest","title":"TrafficPolicyExistsRequest","text":"Name Value Description key string The key of the traffic policy to query."},{"location":"api-reference/policy_map/#trafficpolicyexistsresponse","title":"TrafficPolicyExistsResponse","text":"Name Value Description exists bool True if the traffic policy is configured otherwise false."},{"location":"api-reference/policy_map/#trafficpolicyisrequest","title":"TrafficPolicyIsRequest","text":"Name Value Description traffic_policy TrafficPolicy The traffic policy to create or update."},{"location":"api-reference/policy_map/#trafficpolicyisresponse","title":"TrafficPolicyIsResponse","text":"<p>Empty message.   </p>"},{"location":"api-reference/policy_map/#trafficpolicyrequest","title":"TrafficPolicyRequest","text":"Name Value Description key string The key of the traffic policy to query."},{"location":"api-reference/policy_map/#trafficpolicyresponse","title":"TrafficPolicyResponse","text":"Name Value Description traffic_policy TrafficPolicy The traffic policy corresponding to the key or empty if not found."},{"location":"api-reference/policy_map/#enums","title":"Enums","text":""},{"location":"api-reference/policy_map/#policymapeventtype","title":"PolicyMapEventType","text":"Name Value Description POLICY_MAP_EVENT_NULL 0 POLICY_MAP_EVENT_SYNC 1 POLICY_MAP_EVENT_CONFIG_SET 2 POLICY_MAP_EVENT_TP_CONFIG_SET 3"},{"location":"api-reference/policy_map_counters/","title":"policy_map_counters.proto","text":""},{"location":"api-reference/policy_map_counters/#policymapcountersmgrservice","title":"PolicyMapCountersMgrService","text":""},{"location":"api-reference/policy_map_counters/#watch_policy_map_counters","title":"watch_policy_map_counters","text":"<p>rpc watch_policy_map_counters(PolicyMapCountersWatchRequest)     PolicyMapCountersWatchResponse</p>"},{"location":"api-reference/policy_map_counters/#messages","title":"Messages","text":""},{"location":"api-reference/policy_map_counters/#policymapcounterswatchrequest","title":"PolicyMapCountersWatchRequest","text":"Name Value Description oneof _compress_keys.compress_keys optional bool When set to true, messages will mostly carry a short key that can be mapped to the descriptive key. Disabling compression is not supported, theferefore the default choice for this argument is <code>true</code>. policy_action_caching PolicyActionCaching"},{"location":"api-reference/policy_map_counters/#policymapcounterswatchresponse","title":"PolicyMapCountersWatchResponse","text":"Name Value Description counters repeated PolicyMapCounters stream_ready bool"},{"location":"api-reference/policy_map_counters/#enums","title":"Enums","text":""},{"location":"api-reference/policy_map_counters/#policyactioncaching","title":"PolicyActionCaching","text":"Name Value Description POLICY_MAP_COUNTERS_WITH_POLICY_ACTION_REQUIRED 0 POLICY_MAP_COUNTERS_WITH_POLICY_ACTION_EVENTUALLY 1"},{"location":"api-reference/policy_map_counters_types/","title":"policy_map_counters_types.proto","text":""},{"location":"api-reference/policy_map_counters_types/#messages","title":"Messages","text":""},{"location":"api-reference/policy_map_counters_types/#policymapcounters","title":"PolicyMapCounters","text":"<p>The policy map counter entry</p> Name Value Description key_id uint64 Short key key_name PolicyMapCountersKey Long key counters PolicyMapRuleCounters Counter data policy_action PolicyMapCountersAction Associated output action operation PolicyMapCountersOperation Update action of the entry"},{"location":"api-reference/policy_map_counters_types/#policymapcountersaction","title":"PolicyMapCountersAction","text":"<p>Output action associated with counter data</p> Name Value Description oneof action.deny bool oneof action.out_action PolicyMapCountersOutAction"},{"location":"api-reference/policy_map_counters_types/#policymapcounterskey","title":"PolicyMapCountersKey","text":"<p>Key that uniquely identifies a counter</p> Name Value Description policy_key PolicyMapKey Policy map key class_name string Policy class name acl_rule string ACL rule name"},{"location":"api-reference/policy_map_counters_types/#policymapcountersoutaction","title":"PolicyMapCountersOutAction","text":"<p>Next-hop information of output action</p> Name Value Description oneof nexthop.nexthops PolicyMapCountersOutAction.NexthopAction oneof nexthop.nexthop_group string ttl uint32 Egress TTL"},{"location":"api-reference/policy_map_counters_types/#policymapcountersoutactionnexthopaction","title":"PolicyMapCountersOutAction.NexthopAction","text":"<p>Next-hop list details</p> Name Value Description recursive bool Recursive (indirect) next-hop nexthop_addrs repeated bytes List of next-hop addresses vrf string Egress VRF name"},{"location":"api-reference/policy_map_counters_types/#policymaprulecounters","title":"PolicyMapRuleCounters","text":"<p>Counter data</p> Name Value Description packets_count uint64 Packet count bytes_count uint64 Byte count last_update_timestamp double Counter update timestamp (wallclock, seconds)"},{"location":"api-reference/policy_map_counters_types/#enums","title":"Enums","text":""},{"location":"api-reference/policy_map_counters_types/#policymapcountersoperation","title":"PolicyMapCountersOperation","text":"<p>Possible update actions</p> Name Value Description POLICY_MAP_COUNTERS_UPDATE 0 Entry updates previous value POLICY_MAP_COUNTERS_DELETE 1 Entry deletes previous value"},{"location":"api-reference/policy_map_types/","title":"policy_map_types.proto","text":""},{"location":"api-reference/policy_map_types/#messages","title":"Messages","text":""},{"location":"api-reference/policy_map_types/#policymap","title":"PolicyMap","text":"Name Value Description key PolicyMapKey rules map PolicyMap.RulesEntry"},{"location":"api-reference/policy_map_types/#policymaprulesentry","title":"PolicyMap.RulesEntry","text":"Name Value Description key uint32 value PolicyMapRule"},{"location":"api-reference/policy_map_types/#policymapaction","title":"PolicyMapAction","text":"Name Value Description action_type PolicyActionType nexthop_group_name string nexthops repeated bytes vrf string dscp uint32 Must be in range 0 to 255. traffic_class uint32 Must be in range 0 to 255."},{"location":"api-reference/policy_map_types/#policymaphwstatuskey","title":"PolicyMapHwStatusKey","text":"Name Value Description intf_id IntfId direction AclDirection"},{"location":"api-reference/policy_map_types/#policymaphwstatuses","title":"PolicyMapHwStatuses","text":"Name Value Description status_values repeated PolicyMapStatusValue"},{"location":"api-reference/policy_map_types/#policymapkey","title":"PolicyMapKey","text":"Name Value Description name string feature PolicyFeature"},{"location":"api-reference/policy_map_types/#policymaprule","title":"PolicyMapRule","text":"Name Value Description class_map_key PolicyMapKey oneof policy_map_rule_type_present.policy_map_rule_type PolicyMapRuleType Default value is POLICY_RULE_TYPE_CLASSMAP. raw_rule AclRuleIp actions repeated PolicyMapAction"},{"location":"api-reference/policy_map_types/#policymapstatusvalue","title":"PolicyMapStatusValue","text":"Name Value Description hw_status_key PolicyMapHwStatusKey status PolicyMapStatus"},{"location":"api-reference/policy_map_types/#trafficpolicy","title":"TrafficPolicy","text":"<p>A traffic policy instance.</p> <p>EosSdk reference: eos::traffic_policy_t</p> Name Value Description key string named_counters repeated string rules map TrafficPolicy.RulesEntry"},{"location":"api-reference/policy_map_types/#trafficpolicyrulesentry","title":"TrafficPolicy.RulesEntry","text":"Name Value Description key uint32 value TrafficPolicyRule"},{"location":"api-reference/policy_map_types/#trafficpolicyaction","title":"TrafficPolicyAction","text":"<p>A single traffic-policy action.</p> <p>EosSdk reference: eos::traffic_policy_action_t</p> Name Value Description action_type TrafficPolicyActionType counter_name string goto_class_name string goto_next bool dscp uint32 traffic_class uint32 vrf string mirror_session string police_rate uint64 police_burst_size uint64 police_rate_unit PoliceRateUnit police_burst_unit PoliceBurstUnit nexthop_groups repeated string nexthops repeated bytes"},{"location":"api-reference/policy_map_types/#trafficpolicyrule","title":"TrafficPolicyRule","text":"<p>A traffic policy rule, describing traffic match and actions.</p> <p>EosSdk reference: eos::traffic_policy_rule_t</p> Name Value Description match_rule_name string traffic_policy_rule_type TrafficPolicyRuleType raw_rule TpRuleFilter actions repeated TrafficPolicyAction"},{"location":"api-reference/policy_map_types/#enums","title":"Enums","text":""},{"location":"api-reference/policy_map_types/#policeburstunit","title":"PoliceBurstUnit","text":"Name Value Description POLICE_BURST_UNIT_NULL 0 NULL refers to the default unit in SDK (POLICE_BURST_UNIT_BYTES) POLICE_BURST_UNIT_BYTES 1 POLICE_BURST_UNIT_KBYTES 2 POLICE_BURST_UNIT_MBYTES 3"},{"location":"api-reference/policy_map_types/#policerateunit","title":"PoliceRateUnit","text":"Name Value Description POLICE_RATE_UNIT_NULL 0 NULL refers to the default unit in SDK (POLICE_RATE_UNIT_BPS) POLICE_RATE_UNIT_BPS 1 POLICE_RATE_UNIT_KBPS 2 POLICE_RATE_UNIT_MBPS 3 POLICE_RATE_UNIT_GBPS 4"},{"location":"api-reference/policy_map_types/#policyactiontype","title":"PolicyActionType","text":"<p>The actions a policy map rule may apply to classified packets.</p> Name Value Description POLICY_ACTION_NULL 0 POLICY_ACTION_NONE 1 POLICY_ACTION_DROP 2 POLICY_ACTION_NEXTHOP 3 POLICY_ACTION_NEXTHOP_GROUP 4 POLICY_ACTION_DSCP 5 POLICY_ACTION_TRAFFIC_CLASS 6"},{"location":"api-reference/policy_map_types/#policyfeature","title":"PolicyFeature","text":"<p>A hardware feature a policy map can be used with.</p> Name Value Description POLICY_FEATURE_NULL 0 POLICY_FEATURE_PBR 1 POLICY_FEATURE_QOS 2 POLICY_FEATURE_TAP_AGG 3 POLICY_FEATURE_TRAFFIC_POLICY 4"},{"location":"api-reference/policy_map_types/#policymapruletype","title":"PolicyMapRuleType","text":"Name Value Description POLICY_RULE_TYPE_NOT_SET 0 POLICY_RULE_TYPE_CLASSMAP 1 POLICY_RULE_TYPE_IPV4 2 POLICY_RULE_TYPE_IPV6 3"},{"location":"api-reference/policy_map_types/#policymapstatus","title":"PolicyMapStatus","text":"<p>The policy map hardware status type.</p> Name Value Description POLICY_STATUS_NULL 0 POLICY_STATUS_NOT_FOUND 1 POLICY_STATUS_IN_PROGRESS 2 POLICY_STATUS_FAILED 3 POLICY_STATUS_SUCCESS 4"},{"location":"api-reference/policy_map_types/#trafficpolicyactiontype","title":"TrafficPolicyActionType","text":"Name Value Description TRAFFIC_POLICY_ACTION_NULL 0 TRAFFIC_POLICY_ACTION_DROP 1 TRAFFIC_POLICY_ACTION_POLICE 2 TRAFFIC_POLICY_ACTION_COUNT 3 TRAFFIC_POLICY_ACTION_LOG 4 TRAFFIC_POLICY_ACTION_GOTO 5 TRAFFIC_POLICY_ACTION_DSCP 6 TRAFFIC_POLICY_ACTION_TRAFFIC_CLASS 7 TRAFFIC_POLICY_ACTION_SET_VRF 8 TRAFFIC_POLICY_ACTION_SET_VRF_SECONDARY 9 TRAFFIC_POLICY_ACTION_USE_VRF_SECONDARY 10 TRAFFIC_POLICY_ACTION_MIRROR 11 TRAFFIC_POLICY_ACTION_SFLOW 12 TRAFFIC_POLICY_ACTION_NEXTHOP 13 TRAFFIC_POLICY_ACTION_NEXTHOP_GROUP 14"},{"location":"api-reference/policy_map_types/#trafficpolicydirection","title":"TrafficPolicyDirection","text":"Name Value Description TRAFFIC_POLICY_DIRECTION_NULL 0 TRAFFIC_POLICY_DIRECTION_INPUT 1"},{"location":"api-reference/rpc_types/","title":"rpc_types.proto","text":""},{"location":"api-reference/rpc_types/#messages","title":"Messages","text":""},{"location":"api-reference/rpc_types/#bulkresponse","title":"BulkResponse","text":"Name Value Description processed uint64 status RpcResponseStatus"},{"location":"api-reference/rpc_types/#rpcresponsestatus","title":"RpcResponseStatus","text":"Name Value Description status RpcStatusCodes error_string string"},{"location":"api-reference/rpc_types/#enums","title":"Enums","text":""},{"location":"api-reference/rpc_types/#rpcstatuscodes","title":"RpcStatusCodes","text":"<p>The status codes below match gRPC StatusCodes in both naming and numeric values.</p> Name Value Description RPC_STATUS_OK 0 RPC_STATUS_CANCELLED 1 RPC_STATUS_UNKNOWN 2 RPC_STATUS_INVALID_ARGUMENT 3 RPC_STATUS_DEADLINE_EXCEEDED 4 RPC_STATUS_NOT_FOUND 5 RPC_STATUS_ALREDY_EXISTS 6 RPC_STATUS_ALREADY_EXISTS 6 RPC_STATUS_PERMISSION_DENIED 7 RPC_STATUS_UNAUTHENTICATED 8 RPC_STATUS_RESOURCE_EXHAUSTED 9 RPC_STATUS_FAILED_PRECONDITION 10 RPC_STATUS_ABORTED 11 RPC_STATUS_OUT_OF_RANGE 12 RPC_STATUS_UNIMPLEMENTED 13 RPC_STATUS_INTERNAL 14 RPC_STATUS_UNAVAILABLE 15 RPC_STATUS_DATA_LOSS 16 RPC_DO_NOT_USE 17"},{"location":"api-reference/structured_filter_types/","title":"structured_filter_types.proto","text":""},{"location":"api-reference/structured_filter_types/#messages","title":"Messages","text":""},{"location":"api-reference/structured_filter_types/#portfield","title":"PortField","text":"<p>Field type used to configure the port ranges or port field-sets.</p> <p>EosSdk reference: eos::port_field_t</p> Name Value Description src_ports repeated Range dst_ports repeated Range src_port_field_sets repeated string dst_port_field_sets repeated string"},{"location":"api-reference/structured_filter_types/#protocolfield","title":"ProtocolField","text":"<p>Field type used to configure the protocol ranges or protocol field-sets.</p> <p>EosSdk reference: eos::protocol_field_t</p> Name Value Description ports map ProtocolField.PortsEntry"},{"location":"api-reference/structured_filter_types/#protocolfieldportsentry","title":"ProtocolField.PortsEntry","text":"Name Value Description key uint32 value PortField"},{"location":"api-reference/structured_filter_types/#range","title":"Range","text":"Name Value Description range_start uint32 range_end uint32"},{"location":"api-reference/structured_filter_types/#tprulefilter","title":"TpRuleFilter","text":"<p>This type is used to store the configs of all match fields of a traffic-policy rule.</p> <p>EosSdk reference: eos::tp_rule_filter_t</p> Name Value Description src_addrs repeated IpAddrMask src_addr_field_sets repeated string dst_addrs repeated IpAddrMask dst_addr_field_sets repeated string protocol_values repeated TpRuleFilter.ProtocolValue filter_type TrafficPolicyRuleType"},{"location":"api-reference/structured_filter_types/#tprulefilterprotocolvalue","title":"TpRuleFilter.ProtocolValue","text":"Name Value Description protocol_range Range protocol_field ProtocolField"},{"location":"api-reference/structured_filter_types/#enums","title":"Enums","text":""},{"location":"api-reference/structured_filter_types/#trafficpolicyruletype","title":"TrafficPolicyRuleType","text":"Name Value Description TRAFFIC_POLICY_RULE_TYPE_NULL 0 TRAFFIC_POLICY_RULE_TYPE_IPV4 1 TRAFFIC_POLICY_RULE_TYPE_IPV6 2"},{"location":"guides/","title":"Guides","text":"<p>This sections contains guides and examples for EOS SDK RPC.</p> <ul> <li>Basic configuration</li> <li>Exposing the RPC port</li> <li>Error handling</li> <li>Known issues and limitations</li> <li>Sample RPC C++ client</li> <li>Security configuration</li> </ul>"},{"location":"guides/aclrules/","title":"Exposing the RPC port","text":"<p>The default port for EosSdkRpc (9543) is not permitted within the default control-plane ACL. Hence, even though the transport may be listening on an external addresses, we still need to grant access to the port configured for the transport with an ACL. For those who have already set up a custom ACL to the control plane, a rule needs to be added: <code>permit tcp &lt;source&gt; &lt;dest&gt; eq 9543</code> (replace <code>9543</code> with your configured port for the EosSdkRpc transport).</p>"},{"location":"guides/aclrules/#creating-a-custom-control-plane-acl","title":"Creating a custom control-plane ACL:","text":"<p>To set up a custom ACL for the control plane, we start by obtaining the default ACL:</p>"},{"location":"guides/aclrules/#obtain-and-clean-the-default-control-plane-acl","title":"Obtain and clean the default control-plane ACL:","text":"<p>We can view the default control-plane ACL via: <pre><code># sh ip access-lists default-control-plane-acl\nIP Access List default-control-plane-acl [readonly]\n       counters per-entry\n       10 permit icmp any any\n       20 permit ip any any tracked [match 482 packets, 0:35:48 ago]\n       30 permit udp any any eq bfd ttl eq 255\n       40 permit udp any any eq bfd-echo ttl eq 254\n       50 permit udp any any eq multihop-bfd micro-bfd sbfd\n       60 permit udp any eq sbfd any eq sbfd-initiator\n       70 permit ospf any any\n       80 permit tcp any any eq ssh telnet www snmp bgp https msdp ldp netconf-ssh gnmi [match 3 packets, 0:39:06 ago]\n       90 permit udp any any eq bootps bootpc snmp rip ntp ldp ptp-event ptp-general\n       100 permit tcp any any eq mlag ttl eq 255\n       110 permit udp any any eq mlag ttl eq 255\n       120 permit vrrp any any\n       130 permit ahp any any\n       140 permit pim any any\n       150 permit igmp any any\n       160 permit tcp any any range 5900 5910\n       170 permit tcp any any range 50000 50100\n       180 permit udp any any range 51000 51100\n       190 permit tcp any any eq 3333\n       200 permit tcp any any eq nat ttl eq 255\n       210 permit tcp any eq bgp any\n       220 permit rsvp any any\n       230 permit tcp any any eq 6040\n       240 permit tcp any any eq 5541 ttl eq 255\n       250 permit tcp any any eq 5542 ttl eq 255\n       260 permit tcp any any eq 9559\n</code></pre></p> <p>To quickly copy and modify the above ACL we can make use of <code>sed</code> and save the modifications to a new file in '/mnt/flash`:</p> <pre><code>show ip access-lists default-control-plane-acl | redirect flash:cpacl.txt\n</code></pre> <p>Enter bash: <pre><code>#bash\n</code></pre></p> <p>Go to <code>/mnt/flash</code> and remove the match outputs: <pre><code>cd /mnt/flash\nsudo sed -i  \"s/\\[.*//g\" cpacl.txt\n</code></pre></p> <p>The original output should now be clean without any counters information. </p> <p>Now we can just copy that ACLs content into a new ACL, add our new rules (in this case <code>permit tcp any any eq 9543</code>) and apply it on the control-plane.</p>"},{"location":"guides/aclrules/#create-a-new-acl-using-the-cleaned-default-control-plane-acl","title":"Create a new ACL using the cleaned default control-plane ACL","text":"<p>From config mode: <pre><code>ip access-list custom-cp\n&lt;paste the content of the default CP from the file created&gt;\n270 permit tcp any any eq 9543\nexit\n</code></pre></p>"},{"location":"guides/aclrules/#apply-the-newly-created-acl-to-the-control-plane","title":"Apply the newly created ACL to the control-plane","text":"<p>Default VRF <pre><code>system control-plane\n   ip access-group custom-cp in\n</code></pre></p> <p>Non-default VRF: <pre><code>system control-plane\nip access-group custom-cp vrf management in\n</code></pre></p> <p>References:</p> <p>https://eos.arista.com/default-control-plane-acl-explained/ https://aristanetworks.github.io/openmgmt/configuration/security/</p>"},{"location":"guides/configuration/","title":"Basic configuration","text":"<p>This is the recommended method of configuring EosSdkRpc starting from 4.29 release.</p> <p>The new EosSdkRpc CLI is built on top of the existing daemon CLI and allows the configuration of:</p> <ul> <li>Listening interface + port (default port is 9543)</li> <li>RPC services to enable (default is none)</li> <li>Enable/disable the server instance</li> <li>Multiple EosSdkRpc agents</li> </ul> <p>All EosSdkRpc configuration commands reside under the eos-sdk-rpc management mode. Multiple gRPC servers are supported and each EosSdkRpc gRPC server is defined using the transport command:</p> <pre><code>hostname#config\nhostname(config)#management api eos-sdk-rpc\nhostname(config-mgmt-api-gnmi)#transport grpc foo\n</code></pre>"},{"location":"guides/configuration/#configure-listening-endpoints","title":"Configure listening endpoints:","text":"<p>Supported since 4.29.0 release:</p> <ul> <li>Local interface</li> </ul> <p>Supported since 4.30.2 release:</p> <ul> <li>Localhost loopback</li> <li>Localhost unix-socket</li> </ul> <p>Support for configuring multiple endpoints per transport is restricted to only one of each type.</p> <p>e.g configuring two localhost unix-sockets is not supported.</p>"},{"location":"guides/configuration/#listening-interface","title":"Listening interface","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] local interface Management1\n</code></pre>"},{"location":"guides/configuration/#optionally-configure-the-listening-port-the-default-port-is-9543","title":"Optionally configure the listening port (the default port is 9543):","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] local interface Management1 port 9543\n</code></pre> <p>Note</p> <ul> <li>The provided interface must be configured with an active IP address for the server to start, as this is the address that the underlying gRPC server binds to. </li> <li>The configured VRF for that interface is also the VRF that the server listens in.</li> <li>For remote access, the listening port (default 9543, or otherwise) must also be allowed in the system control-plane ACL (for that VRF). See: Exposing the RPC port.</li> <li>Each transport should be configured with a unique interface/port combination.</li> </ul>"},{"location":"guides/configuration/#localhost-loopback-address","title":"Localhost loopback address","text":"<p>Supported since 4.30.2 release.</p> <pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] localhost loopback\n</code></pre>"},{"location":"guides/configuration/#optionally-configure-the-listening-port-the-default-port-is-9543_1","title":"Optionally configure the listening port (the default port is 9543):","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] localhost loopback port 9543\n</code></pre>"},{"location":"guides/configuration/#optionally-configure-the-listening-vrf","title":"Optionally configure the listening VRF:","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] localhost loopback port 9543 vrf foo\n</code></pre> <p>Note</p> <ul> <li>Only one VRF is supported per transport. If a local interface endpoint is also configured and the local interface VRF configuration conflicts with the VRF configured for the localhost loopback endpoint, the local interface VRF will be preferred and the loopback endpoint will be disabled.</li> </ul>"},{"location":"guides/configuration/#localhost-unix-socket","title":"Localhost unix-socket","text":"<p>Supported since 4.30.2 release.</p> <pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] localhost unix file:/tmp/foo.sock\n</code></pre> <p>Note</p> <ul> <li>A client may connect to the unix-domain socket path by using unix:// e.g unix:///tmp/foo.sock <li>Ensure the correct file permissions are in place for the user attempting to connect to the unix-domain socket</li>"},{"location":"guides/configuration/#enable-all-supported-services","title":"Enable all supported services:","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] service all\n</code></pre> <p>Note</p> <ul> <li>If all services are configured, this takes precedence over any given list of supported services.</li> </ul>"},{"location":"guides/configuration/#enable-an-explicit-list-of-supported-services","title":"Enable an explicit list of supported services:","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] service eapiservice agentservice macsecservice\n</code></pre>"},{"location":"guides/configuration/#enabledisable-the-transport","title":"Enable/disable the transport:","text":"<pre><code>hostname(config-mgmt-api-eos-sdk-rpc-foo)#[no] disabled\n</code></pre>"},{"location":"guides/configuration/#multiple-transport-example","title":"Multiple transport example","text":"<p>Configuring a different list of services for each transport. <code>foo</code> is running on the default port (9543) and <code>bar</code> is running on port 9544. Both transports have been bound to the same ip address configured for the Management1 interface.</p> <pre><code>management api eos-sdk-rpc\n  transport grpc foo\n         local interface Management1\n         service AgentService EapiService\n         no disabled\n\n  transport grpc bar\n         local interface Management1 port 9544\n         service AgentService BgpPathService\n         no disabled\n</code></pre> <p>Note</p> <p>At present there should be no conflicts when running the same services across multiple transports, however, there may be limitations for future services - these will be documented.</p>"},{"location":"guides/configuration/#supported-modules","title":"Supported modules","text":"<p>The proto files can be found in the directory <code>/usr/share/EosSdkRpc/proto/</code> on the EOS device. Current Supported modules are:</p> <ul> <li>Agent: allows a client to monitor and query option values (these are set with the option \u2026 value CLI command) or set status in the agent\u2019s registry on SysDb. EosSdkRpc does not use any kind of record on SysDb. This space is entirely at the client\u2019s discretion.</li> <li>EAPI: allows a client to run CLI commands. Show commands and config commands are supported. Show commands are returned in JSON format.</li> <li>Intf: allows a client to monitor interfaces as they are added or removed. Provides functionality to change an interface\u2019s description or administrative status.</li> <li>IP-intf: allow a client to monitor, query, remove or add IP addresses to interfaces.</li> <li>IP-route: allows a client to create, delete, modify or query static routes.</li> <li>Nexthop_group: allows client to create, delete, modify and query nexthop groups.</li> </ul> <p>Each module is organized in the following manner. All RPC proto files are self documented just like the original SDK header counterparts. Whenever generating code for a module, its included dependencies must be explicitly specified too. The table below that lists the required protobufs for each RPC module.</p> Module Required protobufs acl.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, rpc_types.proto agent.proto rpc_types.proto bgp.proto bgp_types.proto bgp_path.proto bgp_path_types.proto, ip_types.proto eapi.proto eapi_types.proto eth_lag_intf.proto eth_lag_intf_types.proto, intf_types.proto, rpc_types.proto eth_phy_intf.proto eth_phy_intf_types.proto, intf_types.proto, rpc_types.proto intf.proto intf_types.proto, rpc_types.proto ip_intf.proto intf_types.proto, ip_intf_types.proto, rpc_types.proto ip_route.proto intf_types.proto, ip_route_types.proto, rpc_types.proto macsec.proto intf_types.proto, macsec_types.proto, rpc_types.proto mpls_route.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, mpls_types.proto, mpls_route_types.proto, rpc_types.proto mpls_vrf_label.proto mpls_types.proto, mpls_vrf_label_types.proto, rpc_types.proto nexthop_group.proto nexthop_group_types.proto, intf_types.proto, mpls_types.proto, rpc_types.proto policy_map.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, policy_map_types.proto, rpc_types.proto"},{"location":"guides/configuration/#previous-configuration","title":"Previous configuration","text":"<p>Releases up to 4.28</p> <p>EosSdkRpc is built on top of EOS SDK and, therefore, needs to be configured the same way as any other agent compiled with EOS SDK: using the daemon configuration mode. The simplest form of configuration is:</p> <pre><code>daemon rpc\nexec /usr/bin/EosSdkRpc\nno shutdown\n</code></pre> <p>As mentioned earlier, the agent listens by default on localhost address so an extra argument is needed to passed on to the executable to change the listening endpoint:</p> <pre><code>daemon rpc\nexec /usr/bin/EosSdkRpc --listen 0.0.0.0:9543\nno shutdown\n</code></pre>"},{"location":"guides/errorhandling/","title":"Error handling","text":""},{"location":"guides/errorhandling/#eos-sdk-errors","title":"EOS SDK errors","text":"<p>The original EOS SDK communicates errors with exceptions by default. The RPC SDK has been designed to behave similarly. For functions that are not bulk calls, the SDK exceptions are translated into gRPC errors and the original error messages are also sent back to the client. gRPC\u2019s framework may also translate these into exceptions back in the client. Here is a list of the SDK exception classes and their gRPC error counterparts:</p> EOS SDK exception class Error code equivalent eos::invalid_range_error OUT_OF_RANGE eos::invalid_argument_error INVALID_ARGUMENT eos::configuration_error FAILED_PRECONDITION eos::unsupported_error UNIMPLEMENTED eos::error INTERNAL std::exception UNKNOWN <p>For the bulk RPC calls, the return structures share the same fields: one counter called processed and a structure called <code>status</code>. The works here are pretty similar to the standard C library: processed means the number of successful calls (like the return value for a call) and <code>status</code> is much like <code>errno</code>. If something went wrong, it holds the cause for the failure.</p>"},{"location":"guides/errorhandling/#other-errors","title":"Other Errors","text":"<p>If AAA authentication is enabled and fails for a given RPC call to that transport, an error message is returned to the client. Example error message: <pre><code>grpc._channel._InactiveRpcError: &lt;_InactiveRpcError of RPC that terminated with:\n        status = StatusCode.UNAUTHENTICATED\n        details = \"Username and password authentication failed.\"\n        \u2026\n</code></pre></p>"},{"location":"guides/howto/","title":"EosSdkRpc HOWTO","text":""},{"location":"guides/howto/#introduction","title":"Introduction","text":"<p>EosSdkRpc is an agent built on top of our EosSdk that uses gRPC as a mechanism to provide remote access to the SDK.</p> <p>This agent is present in development versions of EOS, and is currently enabled via the \"daemon\" command set - starting in the 4.29 release a first-class CLI was created <code>management api eos-sdk-rpc</code> and is now the recommended configuration method. The gRPC interface that the agent supports closely matches the interface provided by EosSdk, and the intent is that the .proto interface can be publicly supported. As well as potentially allowing for remote access, using protobuf to specify the interface isolates customer code from the Linux ABI issues that come with building C++ applications on different compiler, libc, and kernel versions.</p> <p>The default listen point for the agent is <code>localhost:9543</code> but this can be changed to allow external access. Only encrypted access is supported for EosSdkRpc agents configured via the <code>management api eos-sdk-rpc</code> CLI. An ACL should be used to limit the hosts that have access to the agent.</p> <p>The API mirroring is intended to be modular in the same fashion as the SDK itself. Each proto file mirrors one specific SDK module and the RPC definitions and messages also aim to be as close as possible to the original SDK API call, in an attempt to make the learning gap as small as possible.</p> <p>For performance reasons, \u201csetter\u201d RPC calls also come with bulk versions, which minimizes the RPC overhead. These calls differ from their original counterparts by providing a sequence of individual operations which are performed locally in batches, without requiring a round-trip to the client for each operation.</p> <p>Multiple clients are supported by EosSdkRpc and all state is shared between these clients. Requests are fulfilled without regard to which client invoked the RPC call. Any strategy to coordinate multiple clients is out of the scope of this guide.</p>"},{"location":"guides/howto/#configuration","title":"Configuration","text":""},{"location":"guides/howto/#releases-429-and-greater","title":"Releases 4.29 and greater","text":"<p>Note</p> <p>This is now the recommended method of configuring EosSdkRpc starting from 4.29 release.</p> <p>The new EosSdkRpc CLI is built on top of the existing daemon CLI and allows the configuration of:</p> <ul> <li>Listening interface + port (default port is 9543)</li> <li>RPC services to enable (default is none)</li> <li>Enable/disable the server instance</li> <li>Multiple EosSdkRpc agents</li> </ul> <pre><code>management api eos-sdk-rpc\n  transport grpc &lt;insert server name&gt;\n         local interface &lt;insert interface&gt; [ port &lt;port number&gt; ]\n         service all\n         no disabled\n</code></pre>"},{"location":"guides/howto/#multiple-transport-example","title":"Multiple transport example","text":"<p>Configuring a different list of services for each transport. <code>foo</code> is running on the default port (9543) and <code>bar</code> is running on port 9544. Both transports have been bound to the same ip address configured for the Management1 interface.</p> <pre><code>management api eos-sdk-rpc\n  transport grpc foo\n         local interface Management1\n         service AgentService EapiService\n         no disabled\n\n  transport grpc bar\n         local interface Management1 port 9544\n         service AgentService BgpPathService\n         no disabled\n</code></pre> <p>Note</p> <p>At present there should be no conflicts when running the same services across multiple transports, however, there may be limitations for future services - these will be documented.</p> <p>Note</p> <p>A daemon agent is configured by the \u201cmanagement api eos-sdk-rpc\u201d CLI. This is distinguishable from other daemon agents by the use of the transport name as the agent name and  \u201c/usr/bin/EosSdkRpcAgent\u201d as the executeable.</p>"},{"location":"guides/howto/#releases-up-to-428","title":"Releases up to 4.28","text":"<p>EosSdkRpc is built on top of EOS SDK and, therefore, needs to be configured the same way as any other agent compiled with EOS SDK: using the daemon configuration mode. The simplest form of configuration is:</p> <pre><code>daemon rpc\nexec /usr/bin/EosSdkRpc\nno shutdown\n</code></pre> <p>As mentioned earlier, the agent listens by default on localhost address so an extra argument is needed to passed on to the executable to change the listening endpoint:</p> <pre><code>daemon rpc\nexec /usr/bin/EosSdkRpc --listen 0.0.0.0:9543\nno shutdown\n</code></pre>"},{"location":"guides/howto/#exposing-the-rpc-port","title":"Exposing the RPC port","text":"<p>Even though the agent is listening on external addresses, we still need to grant access to the agent port with an ACL. For those who have already set up a custom ACL to the control plane, a rule needs to be added: <code>permit tcp &lt;source&gt; &lt;dest&gt; eq 9543</code> (replace <code>9543</code> with your configured port).</p> <p>To set up a custom ACL for the control plane, we start by obtaining the default ACL:</p> <pre><code># sh ip access-lists default-control-plane-acl\nIP Access List default-control-plane-acl [readonly]\n       counters per-entry\n       10 permit icmp any any\n       20 permit ip any any tracked [match 482 packets, 0:35:48 ago]\n       30 permit udp any any eq bfd ttl eq 255\n       40 permit udp any any eq bfd-echo ttl eq 254\n       50 permit udp any any eq multihop-bfd micro-bfd sbfd\n       60 permit udp any eq sbfd any eq sbfd-initiator\n       70 permit ospf any any\n       80 permit tcp any any eq ssh telnet www snmp bgp https msdp ldp netconf-ssh gnmi [match 3 packets, 0:39:06 ago]\n       90 permit udp any any eq bootps bootpc snmp rip ntp ldp ptp-event ptp-general\n       100 permit tcp any any eq mlag ttl eq 255\n       110 permit udp any any eq mlag ttl eq 255\n       120 permit vrrp any any\n       130 permit ahp any any\n       140 permit pim any any\n       150 permit igmp any any\n       160 permit tcp any any range 5900 5910\n       170 permit tcp any any range 50000 50100\n       180 permit udp any any range 51000 51100\n       190 permit tcp any any eq 3333\n       200 permit tcp any any eq nat ttl eq 255\n       210 permit tcp any eq bgp any\n       220 permit rsvp any any\n       230 permit tcp any any eq 6040\n       240 permit tcp any any eq 5541 ttl eq 255\n       250 permit tcp any any eq 5542 ttl eq 255\n       260 permit tcp any any eq 9559\n</code></pre> <p>The output above can be turned into a new ACL like this one. We can also add the required command to open the RPC port:</p> <pre><code>ip access-list rpc-enabled\ncounters per-entry\n10 permit icmp any any\n20 permit ip any any tracked\n30 permit udp any any eq bfd ttl eq 255\n40 permit udp any any eq bfd-echo ttl eq 254\n50 permit udp any any eq multihop-bfd micro-bfd sbfd\n60 permit udp any eq sbfd any eq sbfd-initiator\n70 permit ospf any any\n80 permit tcp any any eq ssh telnet www snmp bgp https msdp ldp netconf-ssh gnmi\n90 permit udp any any eq bootps bootpc snmp rip ntp ldp ptp-event ptp-general\n100 permit tcp any any eq mlag ttl eq 255\n110 permit udp any any eq mlag ttl eq 255\n120 permit vrrp any any\n130 permit ahp any any\n140 permit pim any any\n150 permit igmp any any\n160 permit tcp any any range 5900 5910\n170 permit tcp any any range 50000 50100\n180 permit udp any any range 51000 51100\n190 permit tcp any any eq 3333\n200 permit tcp any any eq nat ttl eq 255\n210 permit tcp any eq bgp any\n220 permit rsvp any any\n230 permit tcp any any eq 6040\n240 permit tcp any any eq 5541 ttl eq 255\n250 permit tcp any any eq 5542 ttl eq 255\n260 permit tcp any any eq 9559\n270 permit tcp any any eq 9543\nexit\n</code></pre> <p>The new list like this one can be pasted directly into the command prompt.</p> <p>To apply the ACL, we need to run:</p> <pre><code>system control-plane\nip access-group rpc-enabled in\n</code></pre> <p>Reference: https://eos.arista.com/default-control-plane-acl-explained/</p>"},{"location":"guides/howto/#supported-modules","title":"Supported modules","text":"<p>The proto files can be found in the directory <code>/usr/share/EosSdkRpc/proto/</code> on the EOS device. Current Supported modules are:</p> <ul> <li>Agent: allows a client to monitor and query option values (these are set with the option \u2026 value CLI command) or set status in the agent\u2019s registry on SysDb. EosSdkRpc does not use any kind of record on SysDb. This space is entirely at the client\u2019s discretion.</li> <li>EAPI: allows a client to run CLI commands. Show commands and config commands are supported. Show commands are returned in JSON format.</li> <li>Intf: allows a client to monitor interfaces as they are added or removed. Provides functionality to change an interface\u2019s description or administrative status.</li> <li>IP-intf: allow a client to monitor, query, remove or add IP addresses to interfaces.</li> <li>IP-route: allows a client to create, delete, modify or query static routes.</li> <li>Nexthop_group: allows client to create, delete, modify and query nexthop groups.</li> </ul> <p>Each module is organized in the following manner. All RPC proto files are self documented just like the original SDK header counterparts. Whenever generating code for a module, its included dependencies must be explicitly specified too. The table below that lists the required protobufs for each RPC module.</p> Module Required protobufs acl.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, rpc_types.proto agent.proto rpc_types.proto bgp.proto bgp_types.proto bgp_path.proto bgp_path_types.proto, ip_types.proto eapi.proto eapi_types.proto eth_lag_intf.proto eth_lag_intf_types.proto, intf_types.proto, rpc_types.proto eth_phy_intf.proto eth_phy_intf_types.proto, intf_types.proto, rpc_types.proto intf.proto intf_types.proto, rpc_types.proto ip_intf.proto intf_types.proto, ip_intf_types.proto, rpc_types.proto ip_route.proto intf_types.proto, ip_route_types.proto, rpc_types.proto macsec.proto intf_types.proto, macsec_types.proto, rpc_types.proto mpls_route.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, mpls_types.proto, mpls_route_types.proto, rpc_types.proto mpls_vrf_label.proto mpls_types.proto, mpls_vrf_label_types.proto, rpc_types.proto nexthop_group.proto nexthop_group_types.proto, intf_types.proto, mpls_types.proto, rpc_types.proto policy_map.proto acl_types.proto, intf_types.proto, ip_intf_types.proto, policy_map_types.proto, rpc_types.proto"},{"location":"guides/howto/#error-handling","title":"Error handling","text":"<p>The original EOS SDK communicates errors with exceptions by default. The RPC SDK has been designed to behave similarly. For functions that are not bulk calls, the SDK exceptions are translated into gRPC errors and the original error messages are also sent back to the client. gRPC\u2019s framework may also translate these into exceptions back in the client. Here is a list of the SDK exception classes and their gRPC error counterparts:</p> EOS SDK exception class Error code equivalent eos::invalid_range_error OUT_OF_RANGE eos::invalid_argument_error INVALID_ARGUMENT eos::configuration_error FAILED_PRECONDITION eos::unsupported_error UNIMPLEMENTED eos::error INTERNAL std::exception UNKNOWN <p>For the bulk RPC calls, the return structures share the same fields: one counter called processed and a structure called <code>status</code>. The works here are pretty similar to the standard C library: processed means the number of successful calls (like the return value for a call) and <code>status</code> is much like <code>errno</code>. If something went wrong, it holds the cause for the failure.</p>"},{"location":"guides/howto/#simple-c-client","title":"Simple C++ client","text":"<p>One key benefit of the modularized API is that the client does not need to generate every possible interface if it is just going to use one. Here is how to create a simple C++ client that uses the EAPI interface to run the command \u201cshow version\u201d. For the purposes of this demonstration, the requirements are gRPC and Protobuf development packages plus CMake for building.</p> <p>First thing we need to do is to obtain the current proto files. Since they are present in the router, we can just scp them:</p> <pre><code>mkdir EosRpcClient\ncd EosRpcClient\nscp -Cr root@&lt;router&gt;:/usr/share/EosSdkRpc/proto/ .\n</code></pre> <p>This will result in a directory proto being created under our root. Now we have to compile the proto files that we are interested in. We\u2019ll just use <code>eapi.proto</code> and <code>eapi_types.proto</code>. The first file contains messages and rpc definitions so it needs to be processed by protobuf and grpc generators. The second file only contains structures so protobuf is enough.</p> <p>CMake has a good integration with Protobuf and already provides a convenient way to generate C++ files and headers. Unfortunately there is no official solution for gRPC yet. The file described below is a helper module to allow generation of gRPC C++ files with the same convenience as protobuf.</p> gRPC.cmake<pre><code>## A convenient gRPC proto file generator for CMake\n\nfind_library( grpc_LIBRARY grpc REQUIRED )\nfind_library( grpcpp_LIBRARY grpc++ REQUIRED )\nfind_program( grpc_PROTOC_CPP grpc_cpp_plugin )\nset( grpc_LIBRARIES ${grpc_LIBRARY} ${grpcpp_LIBRARY} )\n\nfunction( grpc_generate_cpp GRPC_CC GRPC_H )\n  find_program( PROTOC protoc )\n  foreach(ARG IN ITEMS ${ARGN})\n     string( REGEX REPLACE \"(.*/)?.*\\.proto\" \"\\\\1\"  PROTO_DIR ${ARG} )\n     string( REPLACE ${PROTO_DIR} \"\" NAME ${ARG} )\n     string( REGEX REPLACE \"(.*)\\.proto\" \"\\\\1\"  NAME ${NAME} )\n     string( CONCAT FULL_ARG ${CMAKE_SOURCE_DIR} \"/\" ${ARG})\n     list( APPEND PROTO_files ${FULL_ARG} )\n     list(APPEND CC_files\n        \"${CMAKE_CURRENT_BINARY_DIR}/${NAME}.grpc.pb.cc\"\n     )\n     list(APPEND H_files\n        \"${CMAKE_CURRENT_BINARY_DIR}/${NAME}.grpc.pb.h\"\n     )\n  endforeach()\n  string( CONCAT PROTO_DIR ${CMAKE_SOURCE_DIR} \"/\" ${PROTO_DIR} )\n  set( ${GRPC_CC} ${CC_files} PARENT_SCOPE )\n  set( ${GRPC_H} ${H_files} PARENT_SCOPE )\n  add_custom_command( OUTPUT ${CC_files} ${H_files}\n     COMMAND ${PROTOC}\n        --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${PROTO_DIR}\"\n        --plugin=protoc-gen-grpc=\"${grpc_PROTOC_CPP}\"\n        ${PROTO_files}\n        DEPENDS ${PROTO_files}\n  )\nendfunction()\n</code></pre> <p>Now we can start our own <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code>cmake_minimum_required( VERSION 3.6 )\nproject( eosrpcclient )\n\nset( CMAKE_CXX_STANDARD 17 )\nset( CMAKE_EXPORT_COMPILE_COMMANDS TRUE )\n\n# include_directories for the generated headers.\ninclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )\n\n# add cmake dependencies.\nfind_package( Protobuf )\ninclude( grpc.cmake )\n\n# this variable contains the RPC proto files\nset( GRPC_FILES\n  proto/eapi.proto\n)\n\n# this variable contains protobuf files.\nset( PROTO_FILES\n  proto/eapi_types.proto\n)\n\n# generate the files\nprotobuf_generate_cpp( PROTO_CC PROTO_H ${GRPC_FILES} ${PROTO_FILES} )\ngrpc_generate_cpp( GRPC_CC GRPC_H ${GRPC_FILES} )\n\n# add the generated artifacts to the executable\nadd_executable( eosrpcclient\n  client.cc\n  ${GRPC_CC}\n  ${GRPC_H}\n  ${PROTO_CC}\n  ${PROTO_H}\n)\n\n# set the required libraries\ntarget_link_libraries( eosrpcclient\n  ${grpc_LIBRARIES}\n  ${Protobuf_LIBRARIES}\n)\n</code></pre> <p>We can now add the client code (update the address on <code>CreateChannel</code>):</p> client.cc<pre><code>#include &lt;grpc/grpc.h&gt;\n#include &lt;grpcpp/grpcpp.h&gt;\n#include &lt;grpcpp/client_context.h&gt;\n#include &lt;grpcpp/create_channel.h&gt;\n#include &lt;grpcpp/security/credentials.h&gt;\n\n#include &lt;eapi.grpc.pb.h&gt;\n#include &lt;eapi.pb.h&gt;\n#include &lt;eapi_types.pb.h&gt;\n\n#include &lt;iostream&gt;\n\nint main() {\n  try {\n     // set up client side API\n     auto channel {grpc::CreateChannel(\"&lt;router-addr&gt;:9543\", grpc::InsecureChannelCredentials())};\n     auto eapi {eos::remote::EapiMgrService::Stub(channel)};\n\n     // prepare for the RPC call.\n     // context allows us to set up metadata, compression or authentication on a per-call basis.\n     // see https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html\n     grpc::ClientContext context;\n     // generated request and response objects\n     eos::remote::RunShowCmdRequest request;\n     eos::remote::RunShowCmdResponse response;\n     request.set_command(\"show version\");\n\n     // make the call.\n     eapi.run_show_cmd(&amp;context, request, &amp;response);\n     auto &amp; eapiResponse {response.response()};\n\n     // This particular check is part of the eAPI module\n     // see http://aristanetworks.github.io/EosSdk/docs/2.2.0/ref/eapi.html\n     if(!eapiResponse.success()) {\n        throw std::logic_error( eapiResponse.error_message() );\n     }\n\n     // For a successful show command, responses[0] holds the output as JSON.\n     std::cout &lt;&lt; \"Response to \\\"show version\\\": \" &lt;&lt; eapiResponse.responses()[0] &lt;&lt; '\\n';\n\n  } catch ( const std::exception &amp; e ) {\n     std::cerr &lt;&lt; \"call failed: \" &lt;&lt; e.what() &lt;&lt; '\\n';\n  }\n}\n</code></pre> <p>With this, we can build and test the project:</p> <pre><code>mkdir build\ncd build\ncmake .. &amp;&amp; make\n./eosrpcclient\n</code></pre> <p>And the expected response is something like this:</p> <pre><code>Response to \"show version\": {\"imageFormatVersion\": \"1.0\", \"uptime\": 1506.9400000000001, \"modelName\": \"DCS-7050QX-32-F\", \"internalVersion\": \"4.27.0F-2GB-24596680.eostrunk\", \"memTotal\": 4002848, \"mfgName\": \"Arista\", \"serialNumber\": \"JAS12430029\", \"systemMacAddress\": \"00:1c:73:00:da:78\", \"bootupTimestamp\": 1634646046.0, \"memFree\": 2128936, \"version\": \"4.27.0F-2GB-24596680.eostrunk (engineering build)\", \"configMacAddress\": \"00:00:00:00:00:00\", \"isIntlVersion\": false, \"internalBuildId\": \"7d37543b-18ae-47f7-afe6-a2d4afc6b9ab\", \"hardwareRevision\": \"00.00\", \"hwMacAddress\": \"00:1c:73:00:da:78\", \"architecture\": \"x86_64\"}\n</code></pre>"},{"location":"guides/howto/#expanding-our-previous-example-creating-and-removing-one-evpn-route","title":"Expanding our previous example: creating and removing one EVPN route","text":"<p>Now, let's expand our example to use the SDK (ip_route) to add and remove a single static route. The example below builds on top of the previous.</p> CMakeLists.txt<pre><code>cmake_minimum_required( VERSION 3.6 )\nproject( eosrpcclient )\n\nset( CMAKE_CXX_STANDARD 17 )\nset( CMAKE_EXPORT_COMPILE_COMMANDS TRUE )\n\n# include_directories for the generated headers.\ninclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )\n\n# add cmake dependencies.\nfind_package( Protobuf )\nfind_package( fmt )\ninclude( grpc.cmake )\n\n# this variable contains the RPC proto files\nset( GRPC_FILES\n  proto/eapi.proto\n  proto/ip_route.proto\n)\n\n# this variable is set to the list of protobuf only files.\nset( PROTO_FILES\n  proto/eapi_types.proto\n  proto/intf_types.proto\n  proto/ip_route_types.proto\n  proto/ip_types.proto\n  proto/rpc_types.proto\n)\n\n# generate the files\nprotobuf_generate_cpp( PROTO_CC PROTO_H ${GRPC_FILES} ${PROTO_FILES} )\ngrpc_generate_cpp( GRPC_CC GRPC_H ${GRPC_FILES} )\n\n# add the generated artifacts to the executable\nadd_executable( eosrpcclient\n  client.cc\n  ${GRPC_CC}\n  ${GRPC_H}\n  ${PROTO_CC}\n  ${PROTO_H}\n)\n\n# set the required libraries\ntarget_link_libraries( eosrpcclient\n  ${grpc_LIBRARIES}\n  ${Protobuf_LIBRARIES}\n  fmt::fmt\n)\n</code></pre> <p>And the updated code, with some added functions:</p> client.cc<pre><code>#include &lt;grpc/grpc.h&gt;\n#include &lt;grpcpp/grpcpp.h&gt;\n#include &lt;grpcpp/client_context.h&gt;\n#include &lt;grpcpp/create_channel.h&gt;\n#include &lt;grpcpp/security/credentials.h&gt;\n\n#include &lt;eapi.grpc.pb.h&gt;\n#include &lt;eapi.pb.h&gt;\n#include &lt;eapi_types.pb.h&gt;\n\n#include &lt;ip_route.grpc.pb.h&gt;\n#include &lt;ip_route_types.pb.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;fmt/format.h&gt;\n\nconst std::string intfName = \"&lt;interface&gt;\";\nconst std::string server = \"&lt;router-addr&gt;:9543\";\n\neos::remote::IpRouteKey sampleRouteKey() {\n  eos::remote::IpRouteKey rk;\n  auto &amp; prefix = *rk.mutable_prefix();\n  // IP addresses are specified as binary strings. In the example: 100.0.0.0/8\n  prefix.set_ip_addr(\"\\x64\\0\\0\\0\", 4);\n  prefix.set_length(8);\n  return rk;\n}\n\n// sets an example EVPN via for a route.\neos::remote::IpRouteVia sampleRouteVia() {\n  eos::remote::IpRouteVia via;\n  *via.mutable_key() = sampleRouteKey();\n  via.set_vni(99);\n  // VTEP address 1.0.2.1\n  via.set_vtep_addr(\"\\x01\\0\\x02\\x01\", 4);\n  // virtual mac 00:aa:00:aa:00:bb\n  via.set_router_mac_eth_addr(\"\\0\\xaa\\0\\xaa\\0\\xbb\", 6);\n  via.mutable_intf_id()-&gt;set_name(intfName);\n  return via;\n}\n\nbool routeExists(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient,\n                const eos::remote::IpRouteKey &amp; key) {\n  std::cout &lt;&lt; \"ip_route_exists\\n\";\n  eos::remote::IpRouteExistsRequest existsRequest;\n  eos::remote::IpRouteExistsResponse existsResponse;\n  grpc::ClientContext existsContext;\n  *existsRequest.mutable_key() = key;\n  auto status = ipRouteClient.ip_route_exists(&amp;existsContext, existsRequest,\n     &amp;existsResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n  return existsResponse.exists();\n}\n\nstd::ostream&amp; operator &lt;&lt;(std::ostream &amp; os, const eos::remote::IpRoute &amp; route ) {\n  auto &amp; key = route.key();\n  auto &amp; pfx = key.prefix();\n  const u_char * pfxaddr = reinterpret_cast&lt;const u_char*&gt;(pfx.ip_addr().data());\n  os &lt;&lt; fmt::format( \"key:(pfx={}.{}.{}.{}/{},pref={}), tag={}\",\n     pfxaddr[0], pfxaddr[1], pfxaddr[2], pfxaddr[3], pfx.length(), key.preference(),\n     route.tag());\n  return os;\n}\n\n/// this function lists all configured routes to stdout\nvoid enumerate(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  eos::remote::IpRoutesRequest request;\n  eos::remote::IpRoutesResponse response;\n  grpc::ClientContext context;\n  auto responseReader(ipRouteClient.ip_routes(&amp;context, request));\n  std::cout &lt;&lt; \"routes:\\n\";\n  while (responseReader-&gt;Read(&amp;response)) {\n     std::cout &lt;&lt; '\\t' &lt;&lt; response.response() &lt;&lt; '\\n';\n  }\n}\n\n/// This function creates a single EVPN route for prefix 100.0.0.0/8 to vtep 1.0.2.1\nvoid createEvpnRoute(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  // create route\n  std::cout &lt;&lt; \"ip_route_set\\n\";\n  eos::remote::IpRouteSetRequest request;\n  eos::remote::IpRouteSetResponse response;\n  grpc::ClientContext context;\n  request.set_action(::eos::remote::IpRouteActions::IP_ROUTE_ACTION_FORWARD);\n  auto &amp; route = *request.mutable_route();\n  *route.mutable_key() = sampleRouteKey();\n  auto status = ipRouteClient.ip_route_set(&amp;context, request, &amp;response);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  // set via for route\n  std::cout &lt;&lt; \"ip_route_via_set\\n\";\n  eos::remote::IpRouteViaSetRequest viaRequest;\n  eos::remote::IpRouteViaSetResponse viaResponse;\n  grpc::ClientContext viaContext;\n  *viaRequest.mutable_via() = sampleRouteVia();\n  status = ipRouteClient.ip_route_via_set(&amp;viaContext, viaRequest, &amp;viaResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n  if (!routeExists(ipRouteClient, route.key() )) {\n     throw std::runtime_error(\"ip_route_exists - not found\");\n  }\n}\n\n// This function deletes the via and the route created by the previous function.\nvoid removeEvpnRoute(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  // deletes a via for our test route.\n  std::cout &lt;&lt; \"ip_route_via_del\\n\";\n  eos::remote::IpRouteViaDelRequest viaRequest;\n  eos::remote::IpRouteViaDelResponse viaResponse;\n  grpc::ClientContext viaContext;\n  *viaRequest.mutable_via() = sampleRouteVia();\n  auto status = ipRouteClient.ip_route_via_del(&amp;viaContext, viaRequest, &amp;viaResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  std::cout &lt;&lt; \"ip_route_del\\n\";\n  eos::remote::IpRouteDelRequest request;\n  eos::remote::IpRouteDelResponse response;\n  grpc::ClientContext context;\n  *request.mutable_key() = sampleRouteKey();\n  status = ipRouteClient.ip_route_del(&amp;context, request, &amp;response);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  std::cout &lt;&lt; '!';\n  if (routeExists(ipRouteClient, request.key())) {\n     throw std::runtime_error(\"ip_route_exists - not deleted\");\n  }\n}\n\nint main() {\n  try {\n     // set up client side API\n     auto channel {grpc::CreateChannel(server, grpc::InsecureChannelCredentials())};\n     auto eapi {eos::remote::EapiMgrService::Stub(channel)};\n     auto ipRoute {eos::remote::IpRouteMgrService::Stub(channel)};\n\n     // prepare for the RPC call.\n     // context allows us to set up metadata, compression or authentication on a\n     // per-call basis.\n     // see https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html\n     grpc::ClientContext context;\n     // generated request and response objects\n     eos::remote::RunShowCmdRequest request;\n     eos::remote::RunShowCmdResponse response;\n     request.set_command(\"show version\");\n\n     // make the call.\n     eapi.run_show_cmd(&amp;context, request, &amp;response);\n     auto &amp; eapiResponse {response.response()};\n\n     // This particular check is part of the eAPI module\n     // see http://aristanetworks.github.io/EosSdk/docs/2.2.0/ref/eapi.html\n     if(!eapiResponse.success()) {\n        throw std::logic_error( eapiResponse.error_message() );\n     }\n\n     // for a successful show command, responses[0] holds the JSON output.\n     std::cout &lt;&lt; \"Response to \\\"show version\\\": \" &lt;&lt; eapiResponse.responses()[0]\n        &lt;&lt; '\\n';\n\n     createEvpnRoute(ipRoute);\n     enumerate(ipRoute);\n     removeEvpnRoute(ipRoute);\n     enumerate(ipRoute);\n  } catch ( const std::exception &amp; e ) {\n     std::cerr &lt;&lt; \"call failed: \" &lt;&lt; e.what() &lt;&lt; '\\n';\n  }\n}\n</code></pre> <p>Running the program will yield the output, detailing the steps on creating and deleting a route:</p> <pre><code>$ ./eosrpcclient \nResponse to \"show version\": {\"mfgName\": \"Arista\", \"modelName\": \"DCS-7060PX4-32-F\", \"hardwareRevision\": \"11.00\", \"serialNumber\": \"JPE19290418\", \"systemMacAddress\": \"fc:bd:67:2b:2d:95\", \"hwMacAddress\": \"fc:bd:67:2b:2d:95\", \"configMacAddress\": \"00:00:00:00:00:00\", \"version\": \"4.28.2F-28045261.eostrunk.1 (engineering build)\", \"architecture\": \"x86_64\", \"internalVersion\": \"4.28.2F-28045261.eostrunk.1\", \"internalBuildId\": \"6505e1eb-b158-4179-9aa0-0b7486239433\", \"imageFormatVersion\": \"3.0\", \"imageOptimization\": \"Default\", \"bootupTimestamp\": 1658137083.7456691, \"uptime\": 8067.6000000000004, \"memTotal\": 8165876, \"memFree\": 5713744, \"isIntlVersion\": false}\nip_route_set\nip_route_via_set\nip_route_exists\nroutes:\n        key:(pfx=100.0.0.0/8,pref=0), tag=0\nip_route_via_del\nip_route_del\n!ip_route_exists\nroutes:\n$\n</code></pre> <p>To verify the route creation with CLI, we can debug the program and set a breakpoint before each of the new functions.</p> <pre><code>$ gdb eosrpcclient \nGNU gdb (GDB) Fedora 11.2-2.fc35\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"x86_64-redhat-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n&lt;https://www.gnu.org/software/gdb/bugs/&gt;.\nFind the GDB manual and other documentation resources online at:\n    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.\n\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from eosrpcclient...\n\n(gdb) br createEvpnRoute\nBreakpoint 1 at 0x4099dc\n(gdb) br removeEvpnRoute\nBreakpoint 2 at 0x409e6d\n(gdb) r\nStarting program: /home/paulo/src/EosRpcClient/build/eosrpcclient \n[New Thread 0x7ffff6d16640 (LWP 50219)]\n[New Thread 0x7ffff6515640 (LWP 50220)]\n[New Thread 0x7ffff5d14640 (LWP 50221)]\nResponse to \"show version\": {\"imageFormatVersion\": \"3.0\", \"uptime\": 6693.9300000000003, \"modelName\": \"DCS-7280SR-32C2-F\", \"internalVersion\": \"4.28.1F-27290106.eostrunk\", \"memTotal\": 8165212, \"mfgName\": \"Arista\", \"serialNumber\": \"JAS17450022\", \"systemMacAddress\": \"74:83:ef:01:80:56\", \"bootupTimestamp\": 1652463541.5252528, \"memFree\": 5481240, \"version\": \"4.28.1F-27290106.eostrunk (engineering build)\", \"configMacAddress\": \"00:00:00:00:00:00\", \"isIntlVersion\": false, \"imageOptimization\": \"Default\", \"internalBuildId\": \"6d0e8967-f438-4e05-a8d2-176df292e4b6\", \"hardwareRevision\": \"20.00\", \"hwMacAddress\": \"74:83:ef:01:80:56\", \"architecture\": \"x86_64\"}\n\nThread 1 \"eosrpcclient\" hit Breakpoint 1, 0x00000000004099dc in createEvpnRoute(std::shared_ptr&lt;grpc::Channel&gt; const&amp;) ()\n(gdb)\n</code></pre> <p>At this point, we can verify on the switch there are no EVPN routes:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516      \n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source       \n--------- ---------- --------- ------------\n</code></pre> <p>Continuing the program:</p> <pre><code>(gdb) c\nContinuing.\n[New Thread 0x7ffff5513640 (LWP 50911)]\n\nThread 1 \"eosrpcclient\" hit Breakpoint 2, 0x0000000000409e6d in removeEvpnRoute(std::shared_ptr&lt;grpc::Channel&gt; const&amp;) ()\n(gdb) \n</code></pre> <p>We can see a new VNI 99 created:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516\n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source \n--------- ---------- --------- ------------ \n99        4090                 evpn\n</code></pre> <p>Continuing once again to remove the route:</p> <pre><code>(gdb) c\nContinuing.\n[Thread 0x7ffff5513640 (LWP 50911) exited]\n[Thread 0x7ffff5d14640 (LWP 50221) exited]\n[Thread 0x7ffff6515640 (LWP 50220) exited]\n[Thread 0x7ffff6d16640 (LWP 50219) exited]\n[Inferior 1 (process 49995) exited normally]\n(gdb) \n</code></pre> <p>And verifying the route has been removed:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516\n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source\n--------- ---------- --------- ------------ \n</code></pre>"},{"location":"guides/howto/#known-issues-and-limitations","title":"Known Issues and Limitations","text":""},{"location":"guides/howto/#eossdk-default-fields","title":"EosSdk default fields","text":"<p>From release  4.29.2F onwards, the fields listed below have been made explicitly optional in the proto files, with the purpose of differentiating between a field that has been explicitly set to zero from an unset field. Unset fields are mapped to EOS SDK default values.</p> <p>Some of the types in EosSdk have non-zero default values for some of their fields. Most of the time EosSdkRpc uses default values of zero (or the equivalent). Therefore, when using EosSdkRpc if these fields with non-zero default values are not explicitly specified there can be a difference in behavior when setting the same configuration in EosSdk and EosSdkRpc. A list of the supported fields in EosSdkRpc which have non-zero default values in EosSdk is provided. The equivalent to the EosSdk default value is also specified for each field. These values can be manually set when using EosSdkRpc to ensure consistency with what their values in EosSdk would be. Note that if the client is already explicitly setting values for these fields in EosSdk/EosSdkRpc the default values do not matter.</p> File Message Field Equivalent EosSdk Default Value acl_types.proto AclTtlSpec oper ACL_RANGE_ANY acl_types.proto AclPortSpec oper ACL_RANGE_ANY acl_types.proto AclRuleBase action ACL_PERMIT acl_types.proto AclRuleIp vlan_mask xFFF acl_types.proto AclRuleIp inner_vlan_mask 0xFFF acl_types.proto AclRuleIp ip_type ACL_IP_TYPE_ANY acl_types.proto AclRuleIp icmp_type ALL_ICMP (65535) acl_types.proto AclRuleIp icmp_code ALL_ICMP (65535) acl_types.proto AclRuleEth vlan_mask 0xFFF acl_types.proto AclRuleEth inner_vlan_mask 0xFFF acl_types.proto AclRuleEth eth_protocol 0xFFFFFFFF ip_route_types.proto IpRouteKey preference 1 macsec_types.proto MacsecProfile key_server_priority 16 macsec_types.proto MacsecProfile mka_life_time* 6 macsec_types.proto MacsecProfile cipher* GCM_AES_XPN_128 macsec_types.proto MacsecProfile traffic_policy TRAFFIC_POLICY_ACTIVE_SAK macsec_types.proto MacsecProfile replay_protection True nexthop_group_types.proto NexthopGroup ttl 64 policy_map_types.proto PolicyMapRule policy_map_rule_type POLICY_RULE_TYPE_CLASSMAP <p>*The default value of 0 in the EosSdkRpc will automatically be replaced by the EosSdk default value. </p>"},{"location":"guides/limitations/","title":"Limitations","text":""},{"location":"guides/limitations/#known-issues-and-limitations","title":"Known Issues and Limitations","text":""},{"location":"guides/limitations/#eossdk-default-fields","title":"EosSdk default fields","text":"<p>From release  4.29.2F onwards, the fields listed below have been made explicitly optional in the proto files, with the purpose of differentiating between a field that has been explicitly set to zero from an unset field. Unset fields are mapped to EOS SDK default values.</p> <p>Some of the types in EosSdk have non-zero default values for some of their fields. Most of the time EosSdkRpc uses default values of zero (or the equivalent). Therefore, when using EosSdkRpc if these fields with non-zero default values are not explicitly specified there can be a difference in behavior when setting the same configuration in EosSdk and EosSdkRpc. A list of the supported fields in EosSdkRpc which have non-zero default values in EosSdk is provided. The equivalent to the EosSdk default value is also specified for each field. These values can be manually set when using EosSdkRpc to ensure consistency with what their values in EosSdk would be. Note that if the client is already explicitly setting values for these fields in EosSdk/EosSdkRpc the default values do not matter.</p> File Message Field Equivalent EosSdk Default Value acl_types.proto AclTtlSpec oper ACL_RANGE_ANY acl_types.proto AclPortSpec oper ACL_RANGE_ANY acl_types.proto AclRuleBase action ACL_PERMIT acl_types.proto AclRuleIp vlan_mask xFFF acl_types.proto AclRuleIp inner_vlan_mask 0xFFF acl_types.proto AclRuleIp ip_type ACL_IP_TYPE_ANY acl_types.proto AclRuleIp icmp_type ALL_ICMP (65535) acl_types.proto AclRuleIp icmp_code ALL_ICMP (65535) acl_types.proto AclRuleEth vlan_mask 0xFFF acl_types.proto AclRuleEth inner_vlan_mask 0xFFF acl_types.proto AclRuleEth eth_protocol 0xFFFFFFFF ip_route_types.proto IpRouteKey preference 1 macsec_types.proto MacsecProfile key_server_priority 16 macsec_types.proto MacsecProfile mka_life_time* 6 macsec_types.proto MacsecProfile cipher* GCM_AES_XPN_128 macsec_types.proto MacsecProfile traffic_policy TRAFFIC_POLICY_ACTIVE_SAK macsec_types.proto MacsecProfile replay_protection True nexthop_group_types.proto NexthopGroup ttl 64 policy_map_types.proto PolicyMapRule policy_map_rule_type POLICY_RULE_TYPE_CLASSMAP <p>*The default value of 0 in the EosSdkRpc will automatically be replaced by the EosSdk default value. </p>"},{"location":"guides/limitations/#iprouteservice","title":"IpRouteService","text":"<p>Only the EosSdkRpc transport which creates the routes may modify them.</p>"},{"location":"guides/security/","title":"Security Configuration","text":""},{"location":"guides/security/#acl-rules","title":"ACL rules","text":"<p>Currently, the default port for EosSdkRpc (port: 9543) is not permitted by the default control-plane ACL. The port must be explicitly permitted to allow remote access.</p> <p>See see the exposing the RPC port.</p>"},{"location":"guides/security/#remote-clients","title":"Remote clients","text":"<p>Transports must be configured with an SSL profile for remote clients to successfully issue an RPC request to EosSdkRpc. In an insecure (non-TLS/mTLS) remote client attempts to execute an RPC they will be met with an unauthenticated grpc::Status.</p>"},{"location":"guides/security/#tls-and-mutual-tls","title":"TLS and mutual TLS","text":"<p>Supported since 4.29.2F release.</p> <p>gRPC supports various security mechanisms, including Transport Layer Security (TLS) for securing communication between clients and servers. You can configure security options when setting up the server and client by first configuring an SSL profile within EOS:</p>"},{"location":"guides/security/#eos-ssl-profile-configuration","title":"EOS SSL profile configuration","text":""},{"location":"guides/security/#tls","title":"TLS","text":"<p>With TLS only the client verifies the server using the server certificate and trusted certificate (CA cert). <pre><code>hostname(config)#\nhostname(config)#management security\nhostname(config-mgmt-security)#ssl profile myprofile\nhostname(config-mgmt-sec-ssl-profile-myprofile)#certificate server.pem key server.key\n</code></pre></p>"},{"location":"guides/security/#mutual-tls","title":"Mutual TLS","text":"<p>With mutual TLS (mTLS) both the client and server verify eachother using trusted certificates (CA certs) and hence must both provide their own certificates. <pre><code>hostname(config)#\nhostname(config)#management security\nhostname(config-mgmt-security)#ssl profile myprofile\nhostname(config-mgmt-sec-ssl-profile-myprofile)#certificate server.pem key server.key\nhostname(config-mgmt-sec-ssl-profile-myprofile)#trust certificate ca.pem\n</code></pre></p> <p>Certificates should be in PEM format and certificate chains are also supported.</p> <p>Ensure the SSL profile is valid:</p> <p>Ensure the configured ssl profile is valid (in this case <code>myprofile</code>). The server will fail to start if the configured ssl profile is considered invalid: <pre><code>hostname(config)#show mananagement security ssl profile\n   Profile                      State\n---------------------------- -----------\n   myprofile                    valid\n</code></pre></p>"},{"location":"guides/security/#eossdkrpc-ssl-profile-configuration","title":"EosSdkRpc SSL profile configuration","text":"<p>Once the SSL profile is configured and valid, the ssl profile may then be referenced in the EosSdkRpc transport configuration: <pre><code>hostname(config)#\nhostname(config)#management api eos-sdk-rpc\nhostname(config-mgmt-api-eos-sdk-rpc)#transport grpc foo\nhostname(config-mgmt-api-eos-sdk-rpc-foo)#ssl profile myprofile\n</code></pre></p> <p>If listening on multiple endpoints each endpoint address must exist as a SAN entry in the certificate.</p> <ul> <li><code>&lt;interface IP&gt;</code> for local interface</li> <li><code>localhost</code> for localhost unix-socket</li> <li><code>127.0.0.1</code> for localhost loopback</li> </ul> <p>The client should then use the equivalent of a secure channel in your desired language, passing a valid client key and certificate, and also in the case of mTLS, the CA of the server certificate.</p>"},{"location":"guides/security/#optional-aaa-authentication-may-also-be-enabled-via-the-following-configuration","title":"Optional AAA authentication may also be enabled via the following configuration:","text":"<pre><code>hostname(config)#\nhostname(config)#management api eos-sdk-rpc\nhostname(config-mgmt-api-eos-sdk-rpc)#transport grpc foo\nhostname(config-mgmt-api-eos-sdk-rpc-foo)#metadata username authentication channel secure  \n</code></pre> <p>AAA authentication is currently only available for transports configured with an SSL profile.</p> <p>When enabled, this feature requires the client to include a valid username and password in the metadata of the RPC call. </p> <ul> <li>The username should be stored as a key-value pair with string \u201cusername\u201d as the key and the user's username as the value.</li> <li>The password should be stored as a key-value pair with string \u201cpassword\u201d as the key and the user's password as the value.</li> </ul>"},{"location":"guides/security/#aaa-authentication-failure","title":"AAA authentication failure","text":"<p>If user authentication fails for a given RPC call, an error message is returned to the client. Example error message: <pre><code>grpc._channel._InactiveRpcError: &lt;_InactiveRpcError of RPC that terminated with:\n        status = StatusCode.UNAUTHENTICATED\n        details = \"Username and password authentication failed.\"\n        \u2026\n</code></pre></p> <p>Python</p> <p>Example for setting the username/password for each RPC request made on the given channel: <pre><code>class AuthenticationCallCredentials( grpc.AuthMetadataPlugin ):\ndef __init__( self, credentials ):\n  self.creds = credentials\n\ndef __call__( self, context, callback ):\n  callback( self.creds, None )\n\ntlsCredentials = grpc.ssl_channel_credentials( certsAsString )\ncallCredentials = grpc.metadata_call_credentials(\n         AuthenticationCallCredentials(\n        (\n           ( 'username', f'{username}' ),\n           ( 'password', f'{password}' ),\n        )\n         ) )\ncompositeCredentials = grpc.composite_channel_credentials(\n      tlsCredentials, authCredentials )\nself.channel = grpc.secure_channel( address, compositeCredentials )\n</code></pre></p>"},{"location":"guides/simplecppclient/","title":"Simple C++ client","text":"<p>One key benefit of the modularized API is that the client does not need to generate every possible interface if it is just going to use one. Here is how to create a simple C++ client that uses the EAPI interface to run the command \u201cshow version\u201d. For the purposes of this demonstration, the requirements are gRPC and Protobuf development packages plus CMake for building.</p>"},{"location":"guides/simplecppclient/#obtaining-the-eossdkrpc-proto-files","title":"Obtaining the EosSdkRpc proto files","text":"<p>First thing we need to do is to obtain the current proto files (either from the github, or the EOS device itself). Since they are present in the router, we can just scp them:</p> <pre><code>mkdir EosRpcClient\ncd EosRpcClient\nscp -Cr root@&lt;router&gt;:/usr/share/EosSdkRpc/proto/ .\n</code></pre>"},{"location":"guides/simplecppclient/#generating-c-from-the-proto-files","title":"Generating C++ from the proto files","text":"<p>This will result in a directory proto being created under our root. Now we have to compile the proto files that we are interested in. We\u2019ll just use <code>eapi.proto</code> and <code>eapi_types.proto</code>. The first file contains messages and rpc definitions so it needs to be processed by protobuf and grpc generators. The second file only contains structures so protobuf is enough.</p> <p>CMake has a good integration with Protobuf and already provides a convenient way to generate C++ files and headers. Unfortunately there is no official solution for gRPC yet. The file described below is a helper module to allow generation of gRPC C++ files with the same convenience as protobuf.</p> gRPC.cmake<pre><code>## A convenient gRPC proto file generator for CMake\n\nfind_library( grpc_LIBRARY grpc REQUIRED )\nfind_library( grpcpp_LIBRARY grpc++ REQUIRED )\nfind_program( grpc_PROTOC_CPP grpc_cpp_plugin )\nset( grpc_LIBRARIES ${grpc_LIBRARY} ${grpcpp_LIBRARY} )\n\nfunction( grpc_generate_cpp GRPC_CC GRPC_H )\n  find_program( PROTOC protoc )\n  foreach(ARG IN ITEMS ${ARGN})\n     string( REGEX REPLACE \"(.*/)?.*\\.proto\" \"\\\\1\"  PROTO_DIR ${ARG} )\n     string( REPLACE ${PROTO_DIR} \"\" NAME ${ARG} )\n     string( REGEX REPLACE \"(.*)\\.proto\" \"\\\\1\"  NAME ${NAME} )\n     string( CONCAT FULL_ARG ${CMAKE_SOURCE_DIR} \"/\" ${ARG})\n     list( APPEND PROTO_files ${FULL_ARG} )\n     list(APPEND CC_files\n        \"${CMAKE_CURRENT_BINARY_DIR}/${NAME}.grpc.pb.cc\"\n     )\n     list(APPEND H_files\n        \"${CMAKE_CURRENT_BINARY_DIR}/${NAME}.grpc.pb.h\"\n     )\n  endforeach()\n  string( CONCAT PROTO_DIR ${CMAKE_SOURCE_DIR} \"/\" ${PROTO_DIR} )\n  set( ${GRPC_CC} ${CC_files} PARENT_SCOPE )\n  set( ${GRPC_H} ${H_files} PARENT_SCOPE )\n  add_custom_command( OUTPUT ${CC_files} ${H_files}\n     COMMAND ${PROTOC}\n        --grpc_out \"${CMAKE_CURRENT_BINARY_DIR}\"\n        -I \"${PROTO_DIR}\"\n        --plugin=protoc-gen-grpc=\"${grpc_PROTOC_CPP}\"\n        ${PROTO_files}\n        DEPENDS ${PROTO_files}\n  )\nendfunction()\n</code></pre> <p>Now we can start our own <code>CMakeLists.txt</code>:</p> CMakeLists.txt<pre><code>cmake_minimum_required( VERSION 3.6 )\nproject( eosrpcclient )\n\nset( CMAKE_CXX_STANDARD 17 )\nset( CMAKE_EXPORT_COMPILE_COMMANDS TRUE )\n\n# include_directories for the generated headers.\ninclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )\n\n# add cmake dependencies.\nfind_package( Protobuf )\ninclude( grpc.cmake )\n\n# this variable contains the RPC proto files\nset( GRPC_FILES\n  proto/eapi.proto\n)\n\n# this variable contains protobuf files.\nset( PROTO_FILES\n  proto/eapi_types.proto\n)\n\n# generate the files\nprotobuf_generate_cpp( PROTO_CC PROTO_H ${GRPC_FILES} ${PROTO_FILES} )\ngrpc_generate_cpp( GRPC_CC GRPC_H ${GRPC_FILES} )\n\n# add the generated artifacts to the executable\nadd_executable( eosrpcclient\n  client.cc\n  ${GRPC_CC}\n  ${GRPC_H}\n  ${PROTO_CC}\n  ${PROTO_H}\n)\n\n# set the required libraries\ntarget_link_libraries( eosrpcclient\n  ${grpc_LIBRARIES}\n  ${Protobuf_LIBRARIES}\n)\n</code></pre>"},{"location":"guides/simplecppclient/#creating-the-client","title":"Creating the client","text":"<p>We can now add the client code (update the address on <code>CreateChannel</code>):</p> client.cc<pre><code>#include &lt;grpc/grpc.h&gt;\n#include &lt;grpcpp/grpcpp.h&gt;\n#include &lt;grpcpp/client_context.h&gt;\n#include &lt;grpcpp/create_channel.h&gt;\n#include &lt;grpcpp/security/credentials.h&gt;\n\n#include &lt;eapi.grpc.pb.h&gt;\n#include &lt;eapi.pb.h&gt;\n#include &lt;eapi_types.pb.h&gt;\n\n#include &lt;iostream&gt;\n\nint main() {\n  try {\n     // set up client side API\n     auto channel {grpc::CreateChannel(\"&lt;router-addr&gt;:9543\", grpc::InsecureChannelCredentials())};\n     auto eapi {eos::remote::EapiMgrService::Stub(channel)};\n\n     // prepare for the RPC call.\n     // context allows us to set up metadata, compression or authentication on a per-call basis.\n     // see https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html\n     grpc::ClientContext context;\n     // generated request and response objects\n     eos::remote::RunShowCmdRequest request;\n     eos::remote::RunShowCmdResponse response;\n     request.set_command(\"show version\");\n\n     // make the call.\n     eapi.run_show_cmd(&amp;context, request, &amp;response);\n     auto &amp; eapiResponse {response.response()};\n\n     // This particular check is part of the eAPI module\n     // see http://aristanetworks.github.io/EosSdk/docs/2.2.0/ref/eapi.html\n     if(!eapiResponse.success()) {\n        throw std::logic_error( eapiResponse.error_message() );\n     }\n\n     // For a successful show command, responses[0] holds the output as JSON.\n     std::cout &lt;&lt; \"Response to \\\"show version\\\": \" &lt;&lt; eapiResponse.responses()[0] &lt;&lt; '\\n';\n\n  } catch ( const std::exception &amp; e ) {\n     std::cerr &lt;&lt; \"call failed: \" &lt;&lt; e.what() &lt;&lt; '\\n';\n  }\n}\n</code></pre>"},{"location":"guides/simplecppclient/#build-and-test","title":"Build and test","text":"<p>With this, we can build and test the project:</p> <pre><code>mkdir build\ncd build\ncmake .. &amp;&amp; make\n./eosrpcclient\n</code></pre> <p>And the expected response is something like this:</p> <pre><code>Response to \"show version\": {\"imageFormatVersion\": \"1.0\", \"uptime\": 1506.9400000000001, \"modelName\": \"DCS-7050QX-32-F\", \"internalVersion\": \"4.27.0F-2GB-24596680.eostrunk\", \"memTotal\": 4002848, \"mfgName\": \"Arista\", \"serialNumber\": \"JAS12430029\", \"systemMacAddress\": \"00:1c:73:00:da:78\", \"bootupTimestamp\": 1634646046.0, \"memFree\": 2128936, \"version\": \"4.27.0F-2GB-24596680.eostrunk (engineering build)\", \"configMacAddress\": \"00:00:00:00:00:00\", \"isIntlVersion\": false, \"internalBuildId\": \"7d37543b-18ae-47f7-afe6-a2d4afc6b9ab\", \"hardwareRevision\": \"00.00\", \"hwMacAddress\": \"00:1c:73:00:da:78\", \"architecture\": \"x86_64\"}\n</code></pre>"},{"location":"guides/simplecppclient/#further-examples","title":"Further examples","text":""},{"location":"guides/simplecppclient/#creating-and-removing-one-evpn-route","title":"Creating and removing one EVPN route","text":"<p>Now, let's expand our simple client to use the SDK (ip_route) to add and remove a single static route. The example below builds on top of the previous.</p> CMakeLists.txt<pre><code>cmake_minimum_required( VERSION 3.6 )\nproject( eosrpcclient )\n\nset( CMAKE_CXX_STANDARD 17 )\nset( CMAKE_EXPORT_COMPILE_COMMANDS TRUE )\n\n# include_directories for the generated headers.\ninclude_directories( ${CMAKE_CURRENT_BINARY_DIR} )\n\n# add cmake dependencies.\nfind_package( Protobuf )\nfind_package( fmt )\ninclude( grpc.cmake )\n\n# this variable contains the RPC proto files\nset( GRPC_FILES\n  proto/eapi.proto\n  proto/ip_route.proto\n)\n\n# this variable is set to the list of protobuf only files.\nset( PROTO_FILES\n  proto/eapi_types.proto\n  proto/intf_types.proto\n  proto/ip_route_types.proto\n  proto/ip_types.proto\n  proto/rpc_types.proto\n)\n\n# generate the files\nprotobuf_generate_cpp( PROTO_CC PROTO_H ${GRPC_FILES} ${PROTO_FILES} )\ngrpc_generate_cpp( GRPC_CC GRPC_H ${GRPC_FILES} )\n\n# add the generated artifacts to the executable\nadd_executable( eosrpcclient\n  client.cc\n  ${GRPC_CC}\n  ${GRPC_H}\n  ${PROTO_CC}\n  ${PROTO_H}\n)\n\n# set the required libraries\ntarget_link_libraries( eosrpcclient\n  ${grpc_LIBRARIES}\n  ${Protobuf_LIBRARIES}\n  fmt::fmt\n)\n</code></pre> <p>And the updated code, with some added functions:</p> client.cc<pre><code>#include &lt;grpc/grpc.h&gt;\n#include &lt;grpcpp/grpcpp.h&gt;\n#include &lt;grpcpp/client_context.h&gt;\n#include &lt;grpcpp/create_channel.h&gt;\n#include &lt;grpcpp/security/credentials.h&gt;\n\n#include &lt;eapi.grpc.pb.h&gt;\n#include &lt;eapi.pb.h&gt;\n#include &lt;eapi_types.pb.h&gt;\n\n#include &lt;ip_route.grpc.pb.h&gt;\n#include &lt;ip_route_types.pb.h&gt;\n\n#include &lt;iostream&gt;\n#include &lt;fmt/format.h&gt;\n\nconst std::string intfName = \"&lt;interface&gt;\";\nconst std::string server = \"&lt;router-addr&gt;:9543\";\n\neos::remote::IpRouteKey sampleRouteKey() {\n  eos::remote::IpRouteKey rk;\n  auto &amp; prefix = *rk.mutable_prefix();\n  // IP addresses are specified as binary strings. In the example: 100.0.0.0/8\n  prefix.set_ip_addr(\"\\x64\\0\\0\\0\", 4);\n  prefix.set_length(8);\n  return rk;\n}\n\n// sets an example EVPN via for a route.\neos::remote::IpRouteVia sampleRouteVia() {\n  eos::remote::IpRouteVia via;\n  *via.mutable_key() = sampleRouteKey();\n  via.set_vni(99);\n  // VTEP address 1.0.2.1\n  via.set_vtep_addr(\"\\x01\\0\\x02\\x01\", 4);\n  // virtual mac 00:aa:00:aa:00:bb\n  via.set_router_mac_eth_addr(\"\\0\\xaa\\0\\xaa\\0\\xbb\", 6);\n  via.mutable_intf_id()-&gt;set_name(intfName);\n  return via;\n}\n\nbool routeExists(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient,\n                const eos::remote::IpRouteKey &amp; key) {\n  std::cout &lt;&lt; \"ip_route_exists\\n\";\n  eos::remote::IpRouteExistsRequest existsRequest;\n  eos::remote::IpRouteExistsResponse existsResponse;\n  grpc::ClientContext existsContext;\n  *existsRequest.mutable_key() = key;\n  auto status = ipRouteClient.ip_route_exists(&amp;existsContext, existsRequest,\n     &amp;existsResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n  return existsResponse.exists();\n}\n\nstd::ostream&amp; operator &lt;&lt;(std::ostream &amp; os, const eos::remote::IpRoute &amp; route ) {\n  auto &amp; key = route.key();\n  auto &amp; pfx = key.prefix();\n  const u_char * pfxaddr = reinterpret_cast&lt;const u_char*&gt;(pfx.ip_addr().data());\n  os &lt;&lt; fmt::format( \"key:(pfx={}.{}.{}.{}/{},pref={}), tag={}\",\n     pfxaddr[0], pfxaddr[1], pfxaddr[2], pfxaddr[3], pfx.length(), key.preference(),\n     route.tag());\n  return os;\n}\n\n/// this function lists all configured routes to stdout\nvoid enumerate(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  eos::remote::IpRoutesRequest request;\n  eos::remote::IpRoutesResponse response;\n  grpc::ClientContext context;\n  auto responseReader(ipRouteClient.ip_routes(&amp;context, request));\n  std::cout &lt;&lt; \"routes:\\n\";\n  while (responseReader-&gt;Read(&amp;response)) {\n     std::cout &lt;&lt; '\\t' &lt;&lt; response.response() &lt;&lt; '\\n';\n  }\n}\n\n/// This function creates a single EVPN route for prefix 100.0.0.0/8 to vtep 1.0.2.1\nvoid createEvpnRoute(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  // create route\n  std::cout &lt;&lt; \"ip_route_set\\n\";\n  eos::remote::IpRouteSetRequest request;\n  eos::remote::IpRouteSetResponse response;\n  grpc::ClientContext context;\n  request.set_action(::eos::remote::IpRouteActions::IP_ROUTE_ACTION_FORWARD);\n  auto &amp; route = *request.mutable_route();\n  *route.mutable_key() = sampleRouteKey();\n  auto status = ipRouteClient.ip_route_set(&amp;context, request, &amp;response);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  // set via for route\n  std::cout &lt;&lt; \"ip_route_via_set\\n\";\n  eos::remote::IpRouteViaSetRequest viaRequest;\n  eos::remote::IpRouteViaSetResponse viaResponse;\n  grpc::ClientContext viaContext;\n  *viaRequest.mutable_via() = sampleRouteVia();\n  status = ipRouteClient.ip_route_via_set(&amp;viaContext, viaRequest, &amp;viaResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n  if (!routeExists(ipRouteClient, route.key() )) {\n     throw std::runtime_error(\"ip_route_exists - not found\");\n  }\n}\n\n// This function deletes the via and the route created by the previous function.\nvoid removeEvpnRoute(eos::remote::IpRouteMgrService::Stub &amp; ipRouteClient) {\n  // deletes a via for our test route.\n  std::cout &lt;&lt; \"ip_route_via_del\\n\";\n  eos::remote::IpRouteViaDelRequest viaRequest;\n  eos::remote::IpRouteViaDelResponse viaResponse;\n  grpc::ClientContext viaContext;\n  *viaRequest.mutable_via() = sampleRouteVia();\n  auto status = ipRouteClient.ip_route_via_del(&amp;viaContext, viaRequest, &amp;viaResponse);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  std::cout &lt;&lt; \"ip_route_del\\n\";\n  eos::remote::IpRouteDelRequest request;\n  eos::remote::IpRouteDelResponse response;\n  grpc::ClientContext context;\n  *request.mutable_key() = sampleRouteKey();\n  status = ipRouteClient.ip_route_del(&amp;context, request, &amp;response);\n  if (!status.ok()) {\n     throw std::runtime_error(status.error_message());\n  }\n\n  std::cout &lt;&lt; '!';\n  if (routeExists(ipRouteClient, request.key())) {\n     throw std::runtime_error(\"ip_route_exists - not deleted\");\n  }\n}\n\nint main() {\n  try {\n     // set up client side API\n     auto channel {grpc::CreateChannel(server, grpc::InsecureChannelCredentials())};\n     auto eapi {eos::remote::EapiMgrService::Stub(channel)};\n     auto ipRoute {eos::remote::IpRouteMgrService::Stub(channel)};\n\n     // prepare for the RPC call.\n     // context allows us to set up metadata, compression or authentication on a\n     // per-call basis.\n     // see https://grpc.github.io/grpc/cpp/classgrpc_1_1_client_context.html\n     grpc::ClientContext context;\n     // generated request and response objects\n     eos::remote::RunShowCmdRequest request;\n     eos::remote::RunShowCmdResponse response;\n     request.set_command(\"show version\");\n\n     // make the call.\n     eapi.run_show_cmd(&amp;context, request, &amp;response);\n     auto &amp; eapiResponse {response.response()};\n\n     // This particular check is part of the eAPI module\n     // see http://aristanetworks.github.io/EosSdk/docs/2.2.0/ref/eapi.html\n     if(!eapiResponse.success()) {\n        throw std::logic_error( eapiResponse.error_message() );\n     }\n\n     // for a successful show command, responses[0] holds the JSON output.\n     std::cout &lt;&lt; \"Response to \\\"show version\\\": \" &lt;&lt; eapiResponse.responses()[0]\n        &lt;&lt; '\\n';\n\n     createEvpnRoute(ipRoute);\n     enumerate(ipRoute);\n     removeEvpnRoute(ipRoute);\n     enumerate(ipRoute);\n  } catch ( const std::exception &amp; e ) {\n     std::cerr &lt;&lt; \"call failed: \" &lt;&lt; e.what() &lt;&lt; '\\n';\n  }\n}\n</code></pre> <p>Running the program will yield the output, detailing the steps on creating and deleting a route:</p> <pre><code>$ ./eosrpcclient \nResponse to \"show version\": {\"mfgName\": \"Arista\", \"modelName\": \"DCS-7060PX4-32-F\", \"hardwareRevision\": \"11.00\", \"serialNumber\": \"JPE19290418\", \"systemMacAddress\": \"fc:bd:67:2b:2d:95\", \"hwMacAddress\": \"fc:bd:67:2b:2d:95\", \"configMacAddress\": \"00:00:00:00:00:00\", \"version\": \"4.28.2F-28045261.eostrunk.1 (engineering build)\", \"architecture\": \"x86_64\", \"internalVersion\": \"4.28.2F-28045261.eostrunk.1\", \"internalBuildId\": \"6505e1eb-b158-4179-9aa0-0b7486239433\", \"imageFormatVersion\": \"3.0\", \"imageOptimization\": \"Default\", \"bootupTimestamp\": 1658137083.7456691, \"uptime\": 8067.6000000000004, \"memTotal\": 8165876, \"memFree\": 5713744, \"isIntlVersion\": false}\nip_route_set\nip_route_via_set\nip_route_exists\nroutes:\n        key:(pfx=100.0.0.0/8,pref=0), tag=0\nip_route_via_del\nip_route_del\n!ip_route_exists\nroutes:\n$\n</code></pre> <p>To verify the route creation with CLI, we can debug the program and set a breakpoint before each of the new functions.</p> <pre><code>$ gdb eosrpcclient \nGNU gdb (GDB) Fedora 11.2-2.fc35\nCopyright (C) 2022 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\nType \"show copying\" and \"show warranty\" for details.\nThis GDB was configured as \"x86_64-redhat-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n&lt;https://www.gnu.org/software/gdb/bugs/&gt;.\nFind the GDB manual and other documentation resources online at:\n    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.\n\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from eosrpcclient...\n\n(gdb) br createEvpnRoute\nBreakpoint 1 at 0x4099dc\n(gdb) br removeEvpnRoute\nBreakpoint 2 at 0x409e6d\n(gdb) r\nStarting program: /home/paulo/src/EosRpcClient/build/eosrpcclient \n[New Thread 0x7ffff6d16640 (LWP 50219)]\n[New Thread 0x7ffff6515640 (LWP 50220)]\n[New Thread 0x7ffff5d14640 (LWP 50221)]\nResponse to \"show version\": {\"imageFormatVersion\": \"3.0\", \"uptime\": 6693.9300000000003, \"modelName\": \"DCS-7280SR-32C2-F\", \"internalVersion\": \"4.28.1F-27290106.eostrunk\", \"memTotal\": 8165212, \"mfgName\": \"Arista\", \"serialNumber\": \"JAS17450022\", \"systemMacAddress\": \"74:83:ef:01:80:56\", \"bootupTimestamp\": 1652463541.5252528, \"memFree\": 5481240, \"version\": \"4.28.1F-27290106.eostrunk (engineering build)\", \"configMacAddress\": \"00:00:00:00:00:00\", \"isIntlVersion\": false, \"imageOptimization\": \"Default\", \"internalBuildId\": \"6d0e8967-f438-4e05-a8d2-176df292e4b6\", \"hardwareRevision\": \"20.00\", \"hwMacAddress\": \"74:83:ef:01:80:56\", \"architecture\": \"x86_64\"}\n\nThread 1 \"eosrpcclient\" hit Breakpoint 1, 0x00000000004099dc in createEvpnRoute(std::shared_ptr&lt;grpc::Channel&gt; const&amp;) ()\n(gdb)\n</code></pre> <p>At this point, we can verify on the switch there are no EVPN routes:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516      \n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source       \n--------- ---------- --------- ------------\n</code></pre> <p>Continuing the program:</p> <pre><code>(gdb) c\nContinuing.\n[New Thread 0x7ffff5513640 (LWP 50911)]\n\nThread 1 \"eosrpcclient\" hit Breakpoint 2, 0x0000000000409e6d in removeEvpnRoute(std::shared_ptr&lt;grpc::Channel&gt; const&amp;) ()\n(gdb) \n</code></pre> <p>We can see a new VNI 99 created:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516\n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source \n--------- ---------- --------- ------------ \n99        4090                 evpn\n</code></pre> <p>Continuing once again to remove the route:</p> <pre><code>(gdb) c\nContinuing.\n[Thread 0x7ffff5513640 (LWP 50911) exited]\n[Thread 0x7ffff5d14640 (LWP 50221) exited]\n[Thread 0x7ffff6515640 (LWP 50220) exited]\n[Thread 0x7ffff6d16640 (LWP 50219) exited]\n[Inferior 1 (process 49995) exited normally]\n(gdb) \n</code></pre> <p>And verifying the route has been removed:</p> <pre><code>#show vxlan vni\nVNI to VLAN Mapping for Vxlan1\nVNI            VLAN       Source       Interface       802.1Q Tag\n-------------- ---------- ------------ --------------- ----------\n14455119       2516       static       Vxlan1          2516\n\nVNI to dynamic VLAN Mapping for Vxlan1\nVNI       VLAN       VRF       Source\n--------- ---------- --------- ------------ \n</code></pre>"}]}